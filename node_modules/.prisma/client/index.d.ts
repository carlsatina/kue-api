
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model BracketOverride
 * 
 */
export type BracketOverride = $Result.DefaultSelection<Prisma.$BracketOverridePayload>
/**
 * Model SessionInviteLink
 * 
 */
export type SessionInviteLink = $Result.DefaultSelection<Prisma.$SessionInviteLinkPayload>
/**
 * Model Court
 * 
 */
export type Court = $Result.DefaultSelection<Prisma.$CourtPayload>
/**
 * Model CourtSession
 * 
 */
export type CourtSession = $Result.DefaultSelection<Prisma.$CourtSessionPayload>
/**
 * Model Player
 * 
 */
export type Player = $Result.DefaultSelection<Prisma.$PlayerPayload>
/**
 * Model SessionPlayer
 * 
 */
export type SessionPlayer = $Result.DefaultSelection<Prisma.$SessionPlayerPayload>
/**
 * Model QueueEntry
 * 
 */
export type QueueEntry = $Result.DefaultSelection<Prisma.$QueueEntryPayload>
/**
 * Model QueueEntryPlayer
 * 
 */
export type QueueEntryPlayer = $Result.DefaultSelection<Prisma.$QueueEntryPlayerPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model MatchParticipant
 * 
 */
export type MatchParticipant = $Result.DefaultSelection<Prisma.$MatchParticipantPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model ShareLink
 * 
 */
export type ShareLink = $Result.DefaultSelection<Prisma.$ShareLinkPayload>
/**
 * Model SessionShareLink
 * 
 */
export type SessionShareLink = $Result.DefaultSelection<Prisma.$SessionShareLinkPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const RoleName: {
  admin: 'admin',
  staff: 'staff'
};

export type RoleName = (typeof RoleName)[keyof typeof RoleName]


export const SessionStatus: {
  draft: 'draft',
  open: 'open',
  closed: 'closed'
};

export type SessionStatus = (typeof SessionStatus)[keyof typeof SessionStatus]


export const FeeMode: {
  flat: 'flat',
  per_game: 'per_game'
};

export type FeeMode = (typeof FeeMode)[keyof typeof FeeMode]


export const CourtStatus: {
  available: 'available',
  in_match: 'in_match',
  maintenance: 'maintenance'
};

export type CourtStatus = (typeof CourtStatus)[keyof typeof CourtStatus]


export const PlayerStatus: {
  checked_in: 'checked_in',
  present: 'present',
  away: 'away',
  done: 'done'
};

export type PlayerStatus = (typeof PlayerStatus)[keyof typeof PlayerStatus]


export const QueueType: {
  singles: 'singles',
  doubles: 'doubles'
};

export type QueueType = (typeof QueueType)[keyof typeof QueueType]


export const QueueStatus: {
  queued: 'queued',
  assigned: 'assigned',
  removed: 'removed'
};

export type QueueStatus = (typeof QueueStatus)[keyof typeof QueueStatus]


export const MatchStatus: {
  proposed: 'proposed',
  active: 'active',
  ended: 'ended',
  cancelled: 'cancelled'
};

export type MatchStatus = (typeof MatchStatus)[keyof typeof MatchStatus]


export const MatchType: {
  singles: 'singles',
  doubles: 'doubles'
};

export type MatchType = (typeof MatchType)[keyof typeof MatchType]

}

export type RoleName = $Enums.RoleName

export const RoleName: typeof $Enums.RoleName

export type SessionStatus = $Enums.SessionStatus

export const SessionStatus: typeof $Enums.SessionStatus

export type FeeMode = $Enums.FeeMode

export const FeeMode: typeof $Enums.FeeMode

export type CourtStatus = $Enums.CourtStatus

export const CourtStatus: typeof $Enums.CourtStatus

export type PlayerStatus = $Enums.PlayerStatus

export const PlayerStatus: typeof $Enums.PlayerStatus

export type QueueType = $Enums.QueueType

export const QueueType: typeof $Enums.QueueType

export type QueueStatus = $Enums.QueueStatus

export const QueueStatus: typeof $Enums.QueueStatus

export type MatchStatus = $Enums.MatchStatus

export const MatchStatus: typeof $Enums.MatchStatus

export type MatchType = $Enums.MatchType

export const MatchType: typeof $Enums.MatchType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bracketOverride`: Exposes CRUD operations for the **BracketOverride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BracketOverrides
    * const bracketOverrides = await prisma.bracketOverride.findMany()
    * ```
    */
  get bracketOverride(): Prisma.BracketOverrideDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionInviteLink`: Exposes CRUD operations for the **SessionInviteLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionInviteLinks
    * const sessionInviteLinks = await prisma.sessionInviteLink.findMany()
    * ```
    */
  get sessionInviteLink(): Prisma.SessionInviteLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.court`: Exposes CRUD operations for the **Court** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courts
    * const courts = await prisma.court.findMany()
    * ```
    */
  get court(): Prisma.CourtDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courtSession`: Exposes CRUD operations for the **CourtSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourtSessions
    * const courtSessions = await prisma.courtSession.findMany()
    * ```
    */
  get courtSession(): Prisma.CourtSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.player`: Exposes CRUD operations for the **Player** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Players
    * const players = await prisma.player.findMany()
    * ```
    */
  get player(): Prisma.PlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionPlayer`: Exposes CRUD operations for the **SessionPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionPlayers
    * const sessionPlayers = await prisma.sessionPlayer.findMany()
    * ```
    */
  get sessionPlayer(): Prisma.SessionPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueEntry`: Exposes CRUD operations for the **QueueEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueEntries
    * const queueEntries = await prisma.queueEntry.findMany()
    * ```
    */
  get queueEntry(): Prisma.QueueEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.queueEntryPlayer`: Exposes CRUD operations for the **QueueEntryPlayer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QueueEntryPlayers
    * const queueEntryPlayers = await prisma.queueEntryPlayer.findMany()
    * ```
    */
  get queueEntryPlayer(): Prisma.QueueEntryPlayerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.matchParticipant`: Exposes CRUD operations for the **MatchParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MatchParticipants
    * const matchParticipants = await prisma.matchParticipant.findMany()
    * ```
    */
  get matchParticipant(): Prisma.MatchParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shareLink`: Exposes CRUD operations for the **ShareLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShareLinks
    * const shareLinks = await prisma.shareLink.findMany()
    * ```
    */
  get shareLink(): Prisma.ShareLinkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionShareLink`: Exposes CRUD operations for the **SessionShareLink** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionShareLinks
    * const sessionShareLinks = await prisma.sessionShareLink.findMany()
    * ```
    */
  get sessionShareLink(): Prisma.SessionShareLinkDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    User: 'User',
    UserRole: 'UserRole',
    Session: 'Session',
    BracketOverride: 'BracketOverride',
    SessionInviteLink: 'SessionInviteLink',
    Court: 'Court',
    CourtSession: 'CourtSession',
    Player: 'Player',
    SessionPlayer: 'SessionPlayer',
    QueueEntry: 'QueueEntry',
    QueueEntryPlayer: 'QueueEntryPlayer',
    Match: 'Match',
    MatchParticipant: 'MatchParticipant',
    Payment: 'Payment',
    ShareLink: 'ShareLink',
    SessionShareLink: 'SessionShareLink'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "role" | "user" | "userRole" | "session" | "bracketOverride" | "sessionInviteLink" | "court" | "courtSession" | "player" | "sessionPlayer" | "queueEntry" | "queueEntryPlayer" | "match" | "matchParticipant" | "payment" | "shareLink" | "sessionShareLink"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      BracketOverride: {
        payload: Prisma.$BracketOverridePayload<ExtArgs>
        fields: Prisma.BracketOverrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BracketOverrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BracketOverrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>
          }
          findFirst: {
            args: Prisma.BracketOverrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BracketOverrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>
          }
          findMany: {
            args: Prisma.BracketOverrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>[]
          }
          create: {
            args: Prisma.BracketOverrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>
          }
          createMany: {
            args: Prisma.BracketOverrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BracketOverrideCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>[]
          }
          delete: {
            args: Prisma.BracketOverrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>
          }
          update: {
            args: Prisma.BracketOverrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>
          }
          deleteMany: {
            args: Prisma.BracketOverrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BracketOverrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BracketOverrideUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>[]
          }
          upsert: {
            args: Prisma.BracketOverrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BracketOverridePayload>
          }
          aggregate: {
            args: Prisma.BracketOverrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBracketOverride>
          }
          groupBy: {
            args: Prisma.BracketOverrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<BracketOverrideGroupByOutputType>[]
          }
          count: {
            args: Prisma.BracketOverrideCountArgs<ExtArgs>
            result: $Utils.Optional<BracketOverrideCountAggregateOutputType> | number
          }
        }
      }
      SessionInviteLink: {
        payload: Prisma.$SessionInviteLinkPayload<ExtArgs>
        fields: Prisma.SessionInviteLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionInviteLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionInviteLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>
          }
          findFirst: {
            args: Prisma.SessionInviteLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionInviteLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>
          }
          findMany: {
            args: Prisma.SessionInviteLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>[]
          }
          create: {
            args: Prisma.SessionInviteLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>
          }
          createMany: {
            args: Prisma.SessionInviteLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionInviteLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>[]
          }
          delete: {
            args: Prisma.SessionInviteLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>
          }
          update: {
            args: Prisma.SessionInviteLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>
          }
          deleteMany: {
            args: Prisma.SessionInviteLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionInviteLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionInviteLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>[]
          }
          upsert: {
            args: Prisma.SessionInviteLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionInviteLinkPayload>
          }
          aggregate: {
            args: Prisma.SessionInviteLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionInviteLink>
          }
          groupBy: {
            args: Prisma.SessionInviteLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionInviteLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionInviteLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SessionInviteLinkCountAggregateOutputType> | number
          }
        }
      }
      Court: {
        payload: Prisma.$CourtPayload<ExtArgs>
        fields: Prisma.CourtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findFirst: {
            args: Prisma.CourtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findMany: {
            args: Prisma.CourtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          create: {
            args: Prisma.CourtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          createMany: {
            args: Prisma.CourtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourtCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          delete: {
            args: Prisma.CourtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          update: {
            args: Prisma.CourtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          deleteMany: {
            args: Prisma.CourtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourtUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          upsert: {
            args: Prisma.CourtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          aggregate: {
            args: Prisma.CourtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt>
          }
          groupBy: {
            args: Prisma.CourtGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtCountArgs<ExtArgs>
            result: $Utils.Optional<CourtCountAggregateOutputType> | number
          }
        }
      }
      CourtSession: {
        payload: Prisma.$CourtSessionPayload<ExtArgs>
        fields: Prisma.CourtSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>
          }
          findFirst: {
            args: Prisma.CourtSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>
          }
          findMany: {
            args: Prisma.CourtSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>[]
          }
          create: {
            args: Prisma.CourtSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>
          }
          createMany: {
            args: Prisma.CourtSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourtSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>[]
          }
          delete: {
            args: Prisma.CourtSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>
          }
          update: {
            args: Prisma.CourtSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>
          }
          deleteMany: {
            args: Prisma.CourtSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CourtSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>[]
          }
          upsert: {
            args: Prisma.CourtSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtSessionPayload>
          }
          aggregate: {
            args: Prisma.CourtSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourtSession>
          }
          groupBy: {
            args: Prisma.CourtSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CourtSessionCountAggregateOutputType> | number
          }
        }
      }
      Player: {
        payload: Prisma.$PlayerPayload<ExtArgs>
        fields: Prisma.PlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findFirst: {
            args: Prisma.PlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          findMany: {
            args: Prisma.PlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          create: {
            args: Prisma.PlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          createMany: {
            args: Prisma.PlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          delete: {
            args: Prisma.PlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          update: {
            args: Prisma.PlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          deleteMany: {
            args: Prisma.PlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>[]
          }
          upsert: {
            args: Prisma.PlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlayerPayload>
          }
          aggregate: {
            args: Prisma.PlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlayer>
          }
          groupBy: {
            args: Prisma.PlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlayerCountArgs<ExtArgs>
            result: $Utils.Optional<PlayerCountAggregateOutputType> | number
          }
        }
      }
      SessionPlayer: {
        payload: Prisma.$SessionPlayerPayload<ExtArgs>
        fields: Prisma.SessionPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>
          }
          findFirst: {
            args: Prisma.SessionPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>
          }
          findMany: {
            args: Prisma.SessionPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>[]
          }
          create: {
            args: Prisma.SessionPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>
          }
          createMany: {
            args: Prisma.SessionPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>[]
          }
          delete: {
            args: Prisma.SessionPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>
          }
          update: {
            args: Prisma.SessionPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>
          }
          deleteMany: {
            args: Prisma.SessionPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>[]
          }
          upsert: {
            args: Prisma.SessionPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPlayerPayload>
          }
          aggregate: {
            args: Prisma.SessionPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionPlayer>
          }
          groupBy: {
            args: Prisma.SessionPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<SessionPlayerCountAggregateOutputType> | number
          }
        }
      }
      QueueEntry: {
        payload: Prisma.$QueueEntryPayload<ExtArgs>
        fields: Prisma.QueueEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          findFirst: {
            args: Prisma.QueueEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          findMany: {
            args: Prisma.QueueEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>[]
          }
          create: {
            args: Prisma.QueueEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          createMany: {
            args: Prisma.QueueEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>[]
          }
          delete: {
            args: Prisma.QueueEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          update: {
            args: Prisma.QueueEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          deleteMany: {
            args: Prisma.QueueEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>[]
          }
          upsert: {
            args: Prisma.QueueEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPayload>
          }
          aggregate: {
            args: Prisma.QueueEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueEntry>
          }
          groupBy: {
            args: Prisma.QueueEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueEntryCountArgs<ExtArgs>
            result: $Utils.Optional<QueueEntryCountAggregateOutputType> | number
          }
        }
      }
      QueueEntryPlayer: {
        payload: Prisma.$QueueEntryPlayerPayload<ExtArgs>
        fields: Prisma.QueueEntryPlayerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QueueEntryPlayerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QueueEntryPlayerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>
          }
          findFirst: {
            args: Prisma.QueueEntryPlayerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QueueEntryPlayerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>
          }
          findMany: {
            args: Prisma.QueueEntryPlayerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>[]
          }
          create: {
            args: Prisma.QueueEntryPlayerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>
          }
          createMany: {
            args: Prisma.QueueEntryPlayerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QueueEntryPlayerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>[]
          }
          delete: {
            args: Prisma.QueueEntryPlayerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>
          }
          update: {
            args: Prisma.QueueEntryPlayerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>
          }
          deleteMany: {
            args: Prisma.QueueEntryPlayerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QueueEntryPlayerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QueueEntryPlayerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>[]
          }
          upsert: {
            args: Prisma.QueueEntryPlayerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QueueEntryPlayerPayload>
          }
          aggregate: {
            args: Prisma.QueueEntryPlayerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQueueEntryPlayer>
          }
          groupBy: {
            args: Prisma.QueueEntryPlayerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QueueEntryPlayerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QueueEntryPlayerCountArgs<ExtArgs>
            result: $Utils.Optional<QueueEntryPlayerCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      MatchParticipant: {
        payload: Prisma.$MatchParticipantPayload<ExtArgs>
        fields: Prisma.MatchParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>
          }
          findFirst: {
            args: Prisma.MatchParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>
          }
          findMany: {
            args: Prisma.MatchParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>[]
          }
          create: {
            args: Prisma.MatchParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>
          }
          createMany: {
            args: Prisma.MatchParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>[]
          }
          delete: {
            args: Prisma.MatchParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>
          }
          update: {
            args: Prisma.MatchParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>
          }
          deleteMany: {
            args: Prisma.MatchParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>[]
          }
          upsert: {
            args: Prisma.MatchParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchParticipantPayload>
          }
          aggregate: {
            args: Prisma.MatchParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatchParticipant>
          }
          groupBy: {
            args: Prisma.MatchParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<MatchParticipantCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      ShareLink: {
        payload: Prisma.$ShareLinkPayload<ExtArgs>
        fields: Prisma.ShareLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShareLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShareLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          findFirst: {
            args: Prisma.ShareLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShareLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          findMany: {
            args: Prisma.ShareLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          create: {
            args: Prisma.ShareLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          createMany: {
            args: Prisma.ShareLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShareLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          delete: {
            args: Prisma.ShareLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          update: {
            args: Prisma.ShareLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          deleteMany: {
            args: Prisma.ShareLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShareLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShareLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>[]
          }
          upsert: {
            args: Prisma.ShareLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShareLinkPayload>
          }
          aggregate: {
            args: Prisma.ShareLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShareLink>
          }
          groupBy: {
            args: Prisma.ShareLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShareLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShareLinkCountArgs<ExtArgs>
            result: $Utils.Optional<ShareLinkCountAggregateOutputType> | number
          }
        }
      }
      SessionShareLink: {
        payload: Prisma.$SessionShareLinkPayload<ExtArgs>
        fields: Prisma.SessionShareLinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionShareLinkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionShareLinkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>
          }
          findFirst: {
            args: Prisma.SessionShareLinkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionShareLinkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>
          }
          findMany: {
            args: Prisma.SessionShareLinkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>[]
          }
          create: {
            args: Prisma.SessionShareLinkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>
          }
          createMany: {
            args: Prisma.SessionShareLinkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionShareLinkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>[]
          }
          delete: {
            args: Prisma.SessionShareLinkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>
          }
          update: {
            args: Prisma.SessionShareLinkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>
          }
          deleteMany: {
            args: Prisma.SessionShareLinkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionShareLinkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionShareLinkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>[]
          }
          upsert: {
            args: Prisma.SessionShareLinkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionShareLinkPayload>
          }
          aggregate: {
            args: Prisma.SessionShareLinkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionShareLink>
          }
          groupBy: {
            args: Prisma.SessionShareLinkGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionShareLinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionShareLinkCountArgs<ExtArgs>
            result: $Utils.Optional<SessionShareLinkCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    role?: RoleOmit
    user?: UserOmit
    userRole?: UserRoleOmit
    session?: SessionOmit
    bracketOverride?: BracketOverrideOmit
    sessionInviteLink?: SessionInviteLinkOmit
    court?: CourtOmit
    courtSession?: CourtSessionOmit
    player?: PlayerOmit
    sessionPlayer?: SessionPlayerOmit
    queueEntry?: QueueEntryOmit
    queueEntryPlayer?: QueueEntryPlayerOmit
    match?: MatchOmit
    matchParticipant?: MatchParticipantOmit
    payment?: PaymentOmit
    shareLink?: ShareLinkOmit
    sessionShareLink?: SessionShareLinkOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    roles: number
    sessions: number
    courts: number
    players: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    courts?: boolean | UserCountOutputTypeCountCourtsArgs
    players?: boolean | UserCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCourtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
  }


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    courtSessions: number
    sessionPlayers: number
    queueEntries: number
    matches: number
    payments: number
    shareLinks: number
    sessionShareLinks: number
    sessionInviteLinks: number
    bracketOverrides: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courtSessions?: boolean | SessionCountOutputTypeCountCourtSessionsArgs
    sessionPlayers?: boolean | SessionCountOutputTypeCountSessionPlayersArgs
    queueEntries?: boolean | SessionCountOutputTypeCountQueueEntriesArgs
    matches?: boolean | SessionCountOutputTypeCountMatchesArgs
    payments?: boolean | SessionCountOutputTypeCountPaymentsArgs
    shareLinks?: boolean | SessionCountOutputTypeCountShareLinksArgs
    sessionShareLinks?: boolean | SessionCountOutputTypeCountSessionShareLinksArgs
    sessionInviteLinks?: boolean | SessionCountOutputTypeCountSessionInviteLinksArgs
    bracketOverrides?: boolean | SessionCountOutputTypeCountBracketOverridesArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountCourtSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionPlayerWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountQueueEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountShareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionShareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionShareLinkWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionInviteLinkWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountBracketOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BracketOverrideWhereInput
  }


  /**
   * Count Type CourtCountOutputType
   */

  export type CourtCountOutputType = {
    courtSessions: number
  }

  export type CourtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courtSessions?: boolean | CourtCountOutputTypeCountCourtSessionsArgs
  }

  // Custom InputTypes
  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCountOutputType
     */
    select?: CourtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountCourtSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtSessionWhereInput
  }


  /**
   * Count Type PlayerCountOutputType
   */

  export type PlayerCountOutputType = {
    sessionPlayers: number
    queueEntryPlayers: number
    matchParticipants: number
    payments: number
    shareLinks: number
  }

  export type PlayerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionPlayers?: boolean | PlayerCountOutputTypeCountSessionPlayersArgs
    queueEntryPlayers?: boolean | PlayerCountOutputTypeCountQueueEntryPlayersArgs
    matchParticipants?: boolean | PlayerCountOutputTypeCountMatchParticipantsArgs
    payments?: boolean | PlayerCountOutputTypeCountPaymentsArgs
    shareLinks?: boolean | PlayerCountOutputTypeCountShareLinksArgs
  }

  // Custom InputTypes
  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlayerCountOutputType
     */
    select?: PlayerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountSessionPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionPlayerWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountQueueEntryPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryPlayerWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountMatchParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipantWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * PlayerCountOutputType without action
   */
  export type PlayerCountOutputTypeCountShareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
  }


  /**
   * Count Type QueueEntryCountOutputType
   */

  export type QueueEntryCountOutputType = {
    players: number
  }

  export type QueueEntryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    players?: boolean | QueueEntryCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * QueueEntryCountOutputType without action
   */
  export type QueueEntryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryCountOutputType
     */
    select?: QueueEntryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QueueEntryCountOutputType without action
   */
  export type QueueEntryCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryPlayerWhereInput
  }


  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    participants: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | MatchCountOutputTypeCountParticipantsArgs
  }

  // Custom InputTypes
  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipantWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: $Enums.RoleName | null
    createdAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: $Enums.RoleName | null
    createdAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: $Enums.RoleName
    createdAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserRolePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: $Enums.RoleName
      createdAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'RoleName'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    emailVerifiedAt: Date | null
    emailVerifyTokenHash: string | null
    emailVerifyTokenExpiresAt: Date | null
    passwordResetTokenHash: string | null
    passwordResetTokenExpiresAt: Date | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    emailVerifiedAt: Date | null
    emailVerifyTokenHash: string | null
    emailVerifyTokenExpiresAt: Date | null
    passwordResetTokenHash: string | null
    passwordResetTokenExpiresAt: Date | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    emailVerifiedAt: number
    emailVerifyTokenHash: number
    emailVerifyTokenExpiresAt: number
    passwordResetTokenHash: number
    passwordResetTokenExpiresAt: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    emailVerifiedAt?: true
    emailVerifyTokenHash?: true
    emailVerifyTokenExpiresAt?: true
    passwordResetTokenHash?: true
    passwordResetTokenExpiresAt?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    emailVerifiedAt?: true
    emailVerifyTokenHash?: true
    emailVerifyTokenExpiresAt?: true
    passwordResetTokenHash?: true
    passwordResetTokenExpiresAt?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    emailVerifiedAt?: true
    emailVerifyTokenHash?: true
    emailVerifyTokenExpiresAt?: true
    passwordResetTokenHash?: true
    passwordResetTokenExpiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    fullName: string | null
    emailVerifiedAt: Date | null
    emailVerifyTokenHash: string | null
    emailVerifyTokenExpiresAt: Date | null
    passwordResetTokenHash: string | null
    passwordResetTokenExpiresAt: Date | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    emailVerifiedAt?: boolean
    emailVerifyTokenHash?: boolean
    emailVerifyTokenExpiresAt?: boolean
    passwordResetTokenHash?: boolean
    passwordResetTokenExpiresAt?: boolean
    createdAt?: boolean
    roles?: boolean | User$rolesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    courts?: boolean | User$courtsArgs<ExtArgs>
    players?: boolean | User$playersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    emailVerifiedAt?: boolean
    emailVerifyTokenHash?: boolean
    emailVerifyTokenExpiresAt?: boolean
    passwordResetTokenHash?: boolean
    passwordResetTokenExpiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    emailVerifiedAt?: boolean
    emailVerifyTokenHash?: boolean
    emailVerifyTokenExpiresAt?: boolean
    passwordResetTokenHash?: boolean
    passwordResetTokenExpiresAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    emailVerifiedAt?: boolean
    emailVerifyTokenHash?: boolean
    emailVerifyTokenExpiresAt?: boolean
    passwordResetTokenHash?: boolean
    passwordResetTokenExpiresAt?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "fullName" | "emailVerifiedAt" | "emailVerifyTokenHash" | "emailVerifyTokenExpiresAt" | "passwordResetTokenHash" | "passwordResetTokenExpiresAt" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | User$rolesArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    courts?: boolean | User$courtsArgs<ExtArgs>
    players?: boolean | User$playersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      courts: Prisma.$CourtPayload<ExtArgs>[]
      players: Prisma.$PlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      fullName: string | null
      emailVerifiedAt: Date | null
      emailVerifyTokenHash: string | null
      emailVerifyTokenExpiresAt: Date | null
      passwordResetTokenHash: string | null
      passwordResetTokenExpiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    courts<T extends User$courtsArgs<ExtArgs> = {}>(args?: Subset<T, User$courtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    players<T extends User$playersArgs<ExtArgs> = {}>(args?: Subset<T, User$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly emailVerifiedAt: FieldRef<"User", 'DateTime'>
    readonly emailVerifyTokenHash: FieldRef<"User", 'String'>
    readonly emailVerifyTokenExpiresAt: FieldRef<"User", 'DateTime'>
    readonly passwordResetTokenHash: FieldRef<"User", 'String'>
    readonly passwordResetTokenExpiresAt: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.courts
   */
  export type User$courtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    cursor?: CourtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * User.players
   */
  export type User$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    cursor?: PlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleMinAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleMaxAggregateOutputType = {
    userId: string | null
    roleId: string | null
  }

  export type UserRoleCountAggregateOutputType = {
    userId: number
    roleId: number
    _all: number
  }


  export type UserRoleMinAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleMaxAggregateInputType = {
    userId?: true
    roleId?: true
  }

  export type UserRoleCountAggregateInputType = {
    userId?: true
    roleId?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    userId: string
    roleId: string
    _count: UserRoleCountAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    roleId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>

  export type UserRoleSelectScalar = {
    userId?: boolean
    roleId?: boolean
  }

  export type UserRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "roleId", ExtArgs["result"]["userRole"]>
  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      role: Prisma.$RolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      roleId: string
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserRoles and returns the data saved in the database.
     * @param {UserRoleCreateManyAndReturnArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, UserRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles and returns the data updated in the database.
     * @param {UserRoleUpdateManyAndReturnArgs} args - Arguments to update many UserRoles.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserRoles and only return the `userId`
     * const userRoleWithUserIdOnly = await prisma.userRole.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, UserRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */
  interface UserRoleFieldRefs {
    readonly userId: FieldRef<"UserRole", 'String'>
    readonly roleId: FieldRef<"UserRole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole createManyAndReturn
   */
  export type UserRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
  }

  /**
   * UserRole updateManyAndReturn
   */
  export type UserRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
    /**
     * Limit how many UserRoles to delete.
     */
    limit?: number
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserRole
     */
    omit?: UserRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    feeAmount: Decimal | null
    regularJoinLimit: number | null
    newJoinerLimit: number | null
  }

  export type SessionSumAggregateOutputType = {
    feeAmount: Decimal | null
    regularJoinLimit: number | null
    newJoinerLimit: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    name: string | null
    startsAt: Date | null
    endsAt: Date | null
    status: $Enums.SessionStatus | null
    gameType: $Enums.MatchType | null
    feeMode: $Enums.FeeMode | null
    feeAmount: Decimal | null
    defaultBracketType: string | null
    regularJoinLimit: number | null
    newJoinerLimit: number | null
    returnToQueue: boolean | null
    announcements: string | null
    createdBy: string | null
    createdAt: Date | null
    closedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    startsAt: Date | null
    endsAt: Date | null
    status: $Enums.SessionStatus | null
    gameType: $Enums.MatchType | null
    feeMode: $Enums.FeeMode | null
    feeAmount: Decimal | null
    defaultBracketType: string | null
    regularJoinLimit: number | null
    newJoinerLimit: number | null
    returnToQueue: boolean | null
    announcements: string | null
    createdBy: string | null
    createdAt: Date | null
    closedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    name: number
    startsAt: number
    endsAt: number
    status: number
    gameType: number
    feeMode: number
    feeAmount: number
    defaultBracketType: number
    regularJoinLimit: number
    newJoinerLimit: number
    returnToQueue: number
    announcements: number
    createdBy: number
    createdAt: number
    closedAt: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    feeAmount?: true
    regularJoinLimit?: true
    newJoinerLimit?: true
  }

  export type SessionSumAggregateInputType = {
    feeAmount?: true
    regularJoinLimit?: true
    newJoinerLimit?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    name?: true
    startsAt?: true
    endsAt?: true
    status?: true
    gameType?: true
    feeMode?: true
    feeAmount?: true
    defaultBracketType?: true
    regularJoinLimit?: true
    newJoinerLimit?: true
    returnToQueue?: true
    announcements?: true
    createdBy?: true
    createdAt?: true
    closedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    name?: true
    startsAt?: true
    endsAt?: true
    status?: true
    gameType?: true
    feeMode?: true
    feeAmount?: true
    defaultBracketType?: true
    regularJoinLimit?: true
    newJoinerLimit?: true
    returnToQueue?: true
    announcements?: true
    createdBy?: true
    createdAt?: true
    closedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    name?: true
    startsAt?: true
    endsAt?: true
    status?: true
    gameType?: true
    feeMode?: true
    feeAmount?: true
    defaultBracketType?: true
    regularJoinLimit?: true
    newJoinerLimit?: true
    returnToQueue?: true
    announcements?: true
    createdBy?: true
    createdAt?: true
    closedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    name: string
    startsAt: Date | null
    endsAt: Date | null
    status: $Enums.SessionStatus
    gameType: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount: Decimal
    defaultBracketType: string | null
    regularJoinLimit: number
    newJoinerLimit: number
    returnToQueue: boolean
    announcements: string | null
    createdBy: string | null
    createdAt: Date
    closedAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startsAt?: boolean
    endsAt?: boolean
    status?: boolean
    gameType?: boolean
    feeMode?: boolean
    feeAmount?: boolean
    defaultBracketType?: boolean
    regularJoinLimit?: boolean
    newJoinerLimit?: boolean
    returnToQueue?: boolean
    announcements?: boolean
    createdBy?: boolean
    createdAt?: boolean
    closedAt?: boolean
    creator?: boolean | Session$creatorArgs<ExtArgs>
    courtSessions?: boolean | Session$courtSessionsArgs<ExtArgs>
    sessionPlayers?: boolean | Session$sessionPlayersArgs<ExtArgs>
    queueEntries?: boolean | Session$queueEntriesArgs<ExtArgs>
    matches?: boolean | Session$matchesArgs<ExtArgs>
    payments?: boolean | Session$paymentsArgs<ExtArgs>
    shareLinks?: boolean | Session$shareLinksArgs<ExtArgs>
    sessionShareLinks?: boolean | Session$sessionShareLinksArgs<ExtArgs>
    sessionInviteLinks?: boolean | Session$sessionInviteLinksArgs<ExtArgs>
    bracketOverrides?: boolean | Session$bracketOverridesArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startsAt?: boolean
    endsAt?: boolean
    status?: boolean
    gameType?: boolean
    feeMode?: boolean
    feeAmount?: boolean
    defaultBracketType?: boolean
    regularJoinLimit?: boolean
    newJoinerLimit?: boolean
    returnToQueue?: boolean
    announcements?: boolean
    createdBy?: boolean
    createdAt?: boolean
    closedAt?: boolean
    creator?: boolean | Session$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    startsAt?: boolean
    endsAt?: boolean
    status?: boolean
    gameType?: boolean
    feeMode?: boolean
    feeAmount?: boolean
    defaultBracketType?: boolean
    regularJoinLimit?: boolean
    newJoinerLimit?: boolean
    returnToQueue?: boolean
    announcements?: boolean
    createdBy?: boolean
    createdAt?: boolean
    closedAt?: boolean
    creator?: boolean | Session$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    name?: boolean
    startsAt?: boolean
    endsAt?: boolean
    status?: boolean
    gameType?: boolean
    feeMode?: boolean
    feeAmount?: boolean
    defaultBracketType?: boolean
    regularJoinLimit?: boolean
    newJoinerLimit?: boolean
    returnToQueue?: boolean
    announcements?: boolean
    createdBy?: boolean
    createdAt?: boolean
    closedAt?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "startsAt" | "endsAt" | "status" | "gameType" | "feeMode" | "feeAmount" | "defaultBracketType" | "regularJoinLimit" | "newJoinerLimit" | "returnToQueue" | "announcements" | "createdBy" | "createdAt" | "closedAt", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Session$creatorArgs<ExtArgs>
    courtSessions?: boolean | Session$courtSessionsArgs<ExtArgs>
    sessionPlayers?: boolean | Session$sessionPlayersArgs<ExtArgs>
    queueEntries?: boolean | Session$queueEntriesArgs<ExtArgs>
    matches?: boolean | Session$matchesArgs<ExtArgs>
    payments?: boolean | Session$paymentsArgs<ExtArgs>
    shareLinks?: boolean | Session$shareLinksArgs<ExtArgs>
    sessionShareLinks?: boolean | Session$sessionShareLinksArgs<ExtArgs>
    sessionInviteLinks?: boolean | Session$sessionInviteLinksArgs<ExtArgs>
    bracketOverrides?: boolean | Session$bracketOverridesArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Session$creatorArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Session$creatorArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      courtSessions: Prisma.$CourtSessionPayload<ExtArgs>[]
      sessionPlayers: Prisma.$SessionPlayerPayload<ExtArgs>[]
      queueEntries: Prisma.$QueueEntryPayload<ExtArgs>[]
      matches: Prisma.$MatchPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      shareLinks: Prisma.$ShareLinkPayload<ExtArgs>[]
      sessionShareLinks: Prisma.$SessionShareLinkPayload<ExtArgs>[]
      sessionInviteLinks: Prisma.$SessionInviteLinkPayload<ExtArgs>[]
      bracketOverrides: Prisma.$BracketOverridePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      startsAt: Date | null
      endsAt: Date | null
      status: $Enums.SessionStatus
      gameType: $Enums.MatchType
      feeMode: $Enums.FeeMode
      feeAmount: Prisma.Decimal
      defaultBracketType: string | null
      regularJoinLimit: number
      newJoinerLimit: number
      returnToQueue: boolean
      announcements: string | null
      createdBy: string | null
      createdAt: Date
      closedAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Session$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Session$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    courtSessions<T extends Session$courtSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Session$courtSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionPlayers<T extends Session$sessionPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queueEntries<T extends Session$queueEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Session$queueEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matches<T extends Session$matchesArgs<ExtArgs> = {}>(args?: Subset<T, Session$matchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Session$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Session$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareLinks<T extends Session$shareLinksArgs<ExtArgs> = {}>(args?: Subset<T, Session$shareLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionShareLinks<T extends Session$sessionShareLinksArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionShareLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionInviteLinks<T extends Session$sessionInviteLinksArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionInviteLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bracketOverrides<T extends Session$bracketOverridesArgs<ExtArgs> = {}>(args?: Subset<T, Session$bracketOverridesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly name: FieldRef<"Session", 'String'>
    readonly startsAt: FieldRef<"Session", 'DateTime'>
    readonly endsAt: FieldRef<"Session", 'DateTime'>
    readonly status: FieldRef<"Session", 'SessionStatus'>
    readonly gameType: FieldRef<"Session", 'MatchType'>
    readonly feeMode: FieldRef<"Session", 'FeeMode'>
    readonly feeAmount: FieldRef<"Session", 'Decimal'>
    readonly defaultBracketType: FieldRef<"Session", 'String'>
    readonly regularJoinLimit: FieldRef<"Session", 'Int'>
    readonly newJoinerLimit: FieldRef<"Session", 'Int'>
    readonly returnToQueue: FieldRef<"Session", 'Boolean'>
    readonly announcements: FieldRef<"Session", 'String'>
    readonly createdBy: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly closedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.creator
   */
  export type Session$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Session.courtSessions
   */
  export type Session$courtSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    where?: CourtSessionWhereInput
    orderBy?: CourtSessionOrderByWithRelationInput | CourtSessionOrderByWithRelationInput[]
    cursor?: CourtSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtSessionScalarFieldEnum | CourtSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionPlayers
   */
  export type Session$sessionPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    where?: SessionPlayerWhereInput
    orderBy?: SessionPlayerOrderByWithRelationInput | SessionPlayerOrderByWithRelationInput[]
    cursor?: SessionPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionPlayerScalarFieldEnum | SessionPlayerScalarFieldEnum[]
  }

  /**
   * Session.queueEntries
   */
  export type Session$queueEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    where?: QueueEntryWhereInput
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    cursor?: QueueEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * Session.matches
   */
  export type Session$matchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Session.payments
   */
  export type Session$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Session.shareLinks
   */
  export type Session$shareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    cursor?: ShareLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * Session.sessionShareLinks
   */
  export type Session$sessionShareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    where?: SessionShareLinkWhereInput
    orderBy?: SessionShareLinkOrderByWithRelationInput | SessionShareLinkOrderByWithRelationInput[]
    cursor?: SessionShareLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionShareLinkScalarFieldEnum | SessionShareLinkScalarFieldEnum[]
  }

  /**
   * Session.sessionInviteLinks
   */
  export type Session$sessionInviteLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    where?: SessionInviteLinkWhereInput
    orderBy?: SessionInviteLinkOrderByWithRelationInput | SessionInviteLinkOrderByWithRelationInput[]
    cursor?: SessionInviteLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionInviteLinkScalarFieldEnum | SessionInviteLinkScalarFieldEnum[]
  }

  /**
   * Session.bracketOverrides
   */
  export type Session$bracketOverridesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    where?: BracketOverrideWhereInput
    orderBy?: BracketOverrideOrderByWithRelationInput | BracketOverrideOrderByWithRelationInput[]
    cursor?: BracketOverrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BracketOverrideScalarFieldEnum | BracketOverrideScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model BracketOverride
   */

  export type AggregateBracketOverride = {
    _count: BracketOverrideCountAggregateOutputType | null
    _min: BracketOverrideMinAggregateOutputType | null
    _max: BracketOverrideMaxAggregateOutputType | null
  }

  export type BracketOverrideMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    matchId: string | null
    bracketType: string | null
    matchFormat: string | null
    winnerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BracketOverrideMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    matchId: string | null
    bracketType: string | null
    matchFormat: string | null
    winnerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BracketOverrideCountAggregateOutputType = {
    id: number
    sessionId: number
    matchId: number
    bracketType: number
    matchFormat: number
    winnerId: number
    scoreJson: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BracketOverrideMinAggregateInputType = {
    id?: true
    sessionId?: true
    matchId?: true
    bracketType?: true
    matchFormat?: true
    winnerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BracketOverrideMaxAggregateInputType = {
    id?: true
    sessionId?: true
    matchId?: true
    bracketType?: true
    matchFormat?: true
    winnerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BracketOverrideCountAggregateInputType = {
    id?: true
    sessionId?: true
    matchId?: true
    bracketType?: true
    matchFormat?: true
    winnerId?: true
    scoreJson?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BracketOverrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BracketOverride to aggregate.
     */
    where?: BracketOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BracketOverrides to fetch.
     */
    orderBy?: BracketOverrideOrderByWithRelationInput | BracketOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BracketOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BracketOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BracketOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BracketOverrides
    **/
    _count?: true | BracketOverrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BracketOverrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BracketOverrideMaxAggregateInputType
  }

  export type GetBracketOverrideAggregateType<T extends BracketOverrideAggregateArgs> = {
        [P in keyof T & keyof AggregateBracketOverride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBracketOverride[P]>
      : GetScalarType<T[P], AggregateBracketOverride[P]>
  }




  export type BracketOverrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BracketOverrideWhereInput
    orderBy?: BracketOverrideOrderByWithAggregationInput | BracketOverrideOrderByWithAggregationInput[]
    by: BracketOverrideScalarFieldEnum[] | BracketOverrideScalarFieldEnum
    having?: BracketOverrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BracketOverrideCountAggregateInputType | true
    _min?: BracketOverrideMinAggregateInputType
    _max?: BracketOverrideMaxAggregateInputType
  }

  export type BracketOverrideGroupByOutputType = {
    id: string
    sessionId: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId: string | null
    scoreJson: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BracketOverrideCountAggregateOutputType | null
    _min: BracketOverrideMinAggregateOutputType | null
    _max: BracketOverrideMaxAggregateOutputType | null
  }

  type GetBracketOverrideGroupByPayload<T extends BracketOverrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BracketOverrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BracketOverrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BracketOverrideGroupByOutputType[P]>
            : GetScalarType<T[P], BracketOverrideGroupByOutputType[P]>
        }
      >
    >


  export type BracketOverrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    matchId?: boolean
    bracketType?: boolean
    matchFormat?: boolean
    winnerId?: boolean
    scoreJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bracketOverride"]>

  export type BracketOverrideSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    matchId?: boolean
    bracketType?: boolean
    matchFormat?: boolean
    winnerId?: boolean
    scoreJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bracketOverride"]>

  export type BracketOverrideSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    matchId?: boolean
    bracketType?: boolean
    matchFormat?: boolean
    winnerId?: boolean
    scoreJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bracketOverride"]>

  export type BracketOverrideSelectScalar = {
    id?: boolean
    sessionId?: boolean
    matchId?: boolean
    bracketType?: boolean
    matchFormat?: boolean
    winnerId?: boolean
    scoreJson?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BracketOverrideOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "matchId" | "bracketType" | "matchFormat" | "winnerId" | "scoreJson" | "createdAt" | "updatedAt", ExtArgs["result"]["bracketOverride"]>
  export type BracketOverrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type BracketOverrideIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type BracketOverrideIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $BracketOverridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BracketOverride"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      matchId: string
      bracketType: string
      matchFormat: string
      winnerId: string | null
      scoreJson: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bracketOverride"]>
    composites: {}
  }

  type BracketOverrideGetPayload<S extends boolean | null | undefined | BracketOverrideDefaultArgs> = $Result.GetResult<Prisma.$BracketOverridePayload, S>

  type BracketOverrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BracketOverrideFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BracketOverrideCountAggregateInputType | true
    }

  export interface BracketOverrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BracketOverride'], meta: { name: 'BracketOverride' } }
    /**
     * Find zero or one BracketOverride that matches the filter.
     * @param {BracketOverrideFindUniqueArgs} args - Arguments to find a BracketOverride
     * @example
     * // Get one BracketOverride
     * const bracketOverride = await prisma.bracketOverride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BracketOverrideFindUniqueArgs>(args: SelectSubset<T, BracketOverrideFindUniqueArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BracketOverride that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BracketOverrideFindUniqueOrThrowArgs} args - Arguments to find a BracketOverride
     * @example
     * // Get one BracketOverride
     * const bracketOverride = await prisma.bracketOverride.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BracketOverrideFindUniqueOrThrowArgs>(args: SelectSubset<T, BracketOverrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BracketOverride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideFindFirstArgs} args - Arguments to find a BracketOverride
     * @example
     * // Get one BracketOverride
     * const bracketOverride = await prisma.bracketOverride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BracketOverrideFindFirstArgs>(args?: SelectSubset<T, BracketOverrideFindFirstArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BracketOverride that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideFindFirstOrThrowArgs} args - Arguments to find a BracketOverride
     * @example
     * // Get one BracketOverride
     * const bracketOverride = await prisma.bracketOverride.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BracketOverrideFindFirstOrThrowArgs>(args?: SelectSubset<T, BracketOverrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BracketOverrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BracketOverrides
     * const bracketOverrides = await prisma.bracketOverride.findMany()
     * 
     * // Get first 10 BracketOverrides
     * const bracketOverrides = await prisma.bracketOverride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bracketOverrideWithIdOnly = await prisma.bracketOverride.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BracketOverrideFindManyArgs>(args?: SelectSubset<T, BracketOverrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BracketOverride.
     * @param {BracketOverrideCreateArgs} args - Arguments to create a BracketOverride.
     * @example
     * // Create one BracketOverride
     * const BracketOverride = await prisma.bracketOverride.create({
     *   data: {
     *     // ... data to create a BracketOverride
     *   }
     * })
     * 
     */
    create<T extends BracketOverrideCreateArgs>(args: SelectSubset<T, BracketOverrideCreateArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BracketOverrides.
     * @param {BracketOverrideCreateManyArgs} args - Arguments to create many BracketOverrides.
     * @example
     * // Create many BracketOverrides
     * const bracketOverride = await prisma.bracketOverride.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BracketOverrideCreateManyArgs>(args?: SelectSubset<T, BracketOverrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BracketOverrides and returns the data saved in the database.
     * @param {BracketOverrideCreateManyAndReturnArgs} args - Arguments to create many BracketOverrides.
     * @example
     * // Create many BracketOverrides
     * const bracketOverride = await prisma.bracketOverride.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BracketOverrides and only return the `id`
     * const bracketOverrideWithIdOnly = await prisma.bracketOverride.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BracketOverrideCreateManyAndReturnArgs>(args?: SelectSubset<T, BracketOverrideCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BracketOverride.
     * @param {BracketOverrideDeleteArgs} args - Arguments to delete one BracketOverride.
     * @example
     * // Delete one BracketOverride
     * const BracketOverride = await prisma.bracketOverride.delete({
     *   where: {
     *     // ... filter to delete one BracketOverride
     *   }
     * })
     * 
     */
    delete<T extends BracketOverrideDeleteArgs>(args: SelectSubset<T, BracketOverrideDeleteArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BracketOverride.
     * @param {BracketOverrideUpdateArgs} args - Arguments to update one BracketOverride.
     * @example
     * // Update one BracketOverride
     * const bracketOverride = await prisma.bracketOverride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BracketOverrideUpdateArgs>(args: SelectSubset<T, BracketOverrideUpdateArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BracketOverrides.
     * @param {BracketOverrideDeleteManyArgs} args - Arguments to filter BracketOverrides to delete.
     * @example
     * // Delete a few BracketOverrides
     * const { count } = await prisma.bracketOverride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BracketOverrideDeleteManyArgs>(args?: SelectSubset<T, BracketOverrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BracketOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BracketOverrides
     * const bracketOverride = await prisma.bracketOverride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BracketOverrideUpdateManyArgs>(args: SelectSubset<T, BracketOverrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BracketOverrides and returns the data updated in the database.
     * @param {BracketOverrideUpdateManyAndReturnArgs} args - Arguments to update many BracketOverrides.
     * @example
     * // Update many BracketOverrides
     * const bracketOverride = await prisma.bracketOverride.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BracketOverrides and only return the `id`
     * const bracketOverrideWithIdOnly = await prisma.bracketOverride.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BracketOverrideUpdateManyAndReturnArgs>(args: SelectSubset<T, BracketOverrideUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BracketOverride.
     * @param {BracketOverrideUpsertArgs} args - Arguments to update or create a BracketOverride.
     * @example
     * // Update or create a BracketOverride
     * const bracketOverride = await prisma.bracketOverride.upsert({
     *   create: {
     *     // ... data to create a BracketOverride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BracketOverride we want to update
     *   }
     * })
     */
    upsert<T extends BracketOverrideUpsertArgs>(args: SelectSubset<T, BracketOverrideUpsertArgs<ExtArgs>>): Prisma__BracketOverrideClient<$Result.GetResult<Prisma.$BracketOverridePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BracketOverrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideCountArgs} args - Arguments to filter BracketOverrides to count.
     * @example
     * // Count the number of BracketOverrides
     * const count = await prisma.bracketOverride.count({
     *   where: {
     *     // ... the filter for the BracketOverrides we want to count
     *   }
     * })
    **/
    count<T extends BracketOverrideCountArgs>(
      args?: Subset<T, BracketOverrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BracketOverrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BracketOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BracketOverrideAggregateArgs>(args: Subset<T, BracketOverrideAggregateArgs>): Prisma.PrismaPromise<GetBracketOverrideAggregateType<T>>

    /**
     * Group by BracketOverride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BracketOverrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BracketOverrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BracketOverrideGroupByArgs['orderBy'] }
        : { orderBy?: BracketOverrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BracketOverrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBracketOverrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BracketOverride model
   */
  readonly fields: BracketOverrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BracketOverride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BracketOverrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BracketOverride model
   */
  interface BracketOverrideFieldRefs {
    readonly id: FieldRef<"BracketOverride", 'String'>
    readonly sessionId: FieldRef<"BracketOverride", 'String'>
    readonly matchId: FieldRef<"BracketOverride", 'String'>
    readonly bracketType: FieldRef<"BracketOverride", 'String'>
    readonly matchFormat: FieldRef<"BracketOverride", 'String'>
    readonly winnerId: FieldRef<"BracketOverride", 'String'>
    readonly scoreJson: FieldRef<"BracketOverride", 'Json'>
    readonly createdAt: FieldRef<"BracketOverride", 'DateTime'>
    readonly updatedAt: FieldRef<"BracketOverride", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BracketOverride findUnique
   */
  export type BracketOverrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * Filter, which BracketOverride to fetch.
     */
    where: BracketOverrideWhereUniqueInput
  }

  /**
   * BracketOverride findUniqueOrThrow
   */
  export type BracketOverrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * Filter, which BracketOverride to fetch.
     */
    where: BracketOverrideWhereUniqueInput
  }

  /**
   * BracketOverride findFirst
   */
  export type BracketOverrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * Filter, which BracketOverride to fetch.
     */
    where?: BracketOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BracketOverrides to fetch.
     */
    orderBy?: BracketOverrideOrderByWithRelationInput | BracketOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BracketOverrides.
     */
    cursor?: BracketOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BracketOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BracketOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BracketOverrides.
     */
    distinct?: BracketOverrideScalarFieldEnum | BracketOverrideScalarFieldEnum[]
  }

  /**
   * BracketOverride findFirstOrThrow
   */
  export type BracketOverrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * Filter, which BracketOverride to fetch.
     */
    where?: BracketOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BracketOverrides to fetch.
     */
    orderBy?: BracketOverrideOrderByWithRelationInput | BracketOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BracketOverrides.
     */
    cursor?: BracketOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BracketOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BracketOverrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BracketOverrides.
     */
    distinct?: BracketOverrideScalarFieldEnum | BracketOverrideScalarFieldEnum[]
  }

  /**
   * BracketOverride findMany
   */
  export type BracketOverrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * Filter, which BracketOverrides to fetch.
     */
    where?: BracketOverrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BracketOverrides to fetch.
     */
    orderBy?: BracketOverrideOrderByWithRelationInput | BracketOverrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BracketOverrides.
     */
    cursor?: BracketOverrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BracketOverrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BracketOverrides.
     */
    skip?: number
    distinct?: BracketOverrideScalarFieldEnum | BracketOverrideScalarFieldEnum[]
  }

  /**
   * BracketOverride create
   */
  export type BracketOverrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * The data needed to create a BracketOverride.
     */
    data: XOR<BracketOverrideCreateInput, BracketOverrideUncheckedCreateInput>
  }

  /**
   * BracketOverride createMany
   */
  export type BracketOverrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BracketOverrides.
     */
    data: BracketOverrideCreateManyInput | BracketOverrideCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BracketOverride createManyAndReturn
   */
  export type BracketOverrideCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * The data used to create many BracketOverrides.
     */
    data: BracketOverrideCreateManyInput | BracketOverrideCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BracketOverride update
   */
  export type BracketOverrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * The data needed to update a BracketOverride.
     */
    data: XOR<BracketOverrideUpdateInput, BracketOverrideUncheckedUpdateInput>
    /**
     * Choose, which BracketOverride to update.
     */
    where: BracketOverrideWhereUniqueInput
  }

  /**
   * BracketOverride updateMany
   */
  export type BracketOverrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BracketOverrides.
     */
    data: XOR<BracketOverrideUpdateManyMutationInput, BracketOverrideUncheckedUpdateManyInput>
    /**
     * Filter which BracketOverrides to update
     */
    where?: BracketOverrideWhereInput
    /**
     * Limit how many BracketOverrides to update.
     */
    limit?: number
  }

  /**
   * BracketOverride updateManyAndReturn
   */
  export type BracketOverrideUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * The data used to update BracketOverrides.
     */
    data: XOR<BracketOverrideUpdateManyMutationInput, BracketOverrideUncheckedUpdateManyInput>
    /**
     * Filter which BracketOverrides to update
     */
    where?: BracketOverrideWhereInput
    /**
     * Limit how many BracketOverrides to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BracketOverride upsert
   */
  export type BracketOverrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * The filter to search for the BracketOverride to update in case it exists.
     */
    where: BracketOverrideWhereUniqueInput
    /**
     * In case the BracketOverride found by the `where` argument doesn't exist, create a new BracketOverride with this data.
     */
    create: XOR<BracketOverrideCreateInput, BracketOverrideUncheckedCreateInput>
    /**
     * In case the BracketOverride was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BracketOverrideUpdateInput, BracketOverrideUncheckedUpdateInput>
  }

  /**
   * BracketOverride delete
   */
  export type BracketOverrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
    /**
     * Filter which BracketOverride to delete.
     */
    where: BracketOverrideWhereUniqueInput
  }

  /**
   * BracketOverride deleteMany
   */
  export type BracketOverrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BracketOverrides to delete
     */
    where?: BracketOverrideWhereInput
    /**
     * Limit how many BracketOverrides to delete.
     */
    limit?: number
  }

  /**
   * BracketOverride without action
   */
  export type BracketOverrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BracketOverride
     */
    select?: BracketOverrideSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BracketOverride
     */
    omit?: BracketOverrideOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BracketOverrideInclude<ExtArgs> | null
  }


  /**
   * Model SessionInviteLink
   */

  export type AggregateSessionInviteLink = {
    _count: SessionInviteLinkCountAggregateOutputType | null
    _min: SessionInviteLinkMinAggregateOutputType | null
    _max: SessionInviteLinkMaxAggregateOutputType | null
  }

  export type SessionInviteLinkMinAggregateOutputType = {
    id: string | null
    token: string | null
    sessionId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionInviteLinkMaxAggregateOutputType = {
    id: string | null
    token: string | null
    sessionId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionInviteLinkCountAggregateOutputType = {
    id: number
    token: number
    sessionId: number
    revokedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionInviteLinkMinAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionInviteLinkMaxAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionInviteLinkCountAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionInviteLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionInviteLink to aggregate.
     */
    where?: SessionInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionInviteLinks to fetch.
     */
    orderBy?: SessionInviteLinkOrderByWithRelationInput | SessionInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionInviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionInviteLinks
    **/
    _count?: true | SessionInviteLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionInviteLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionInviteLinkMaxAggregateInputType
  }

  export type GetSessionInviteLinkAggregateType<T extends SessionInviteLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionInviteLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionInviteLink[P]>
      : GetScalarType<T[P], AggregateSessionInviteLink[P]>
  }




  export type SessionInviteLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionInviteLinkWhereInput
    orderBy?: SessionInviteLinkOrderByWithAggregationInput | SessionInviteLinkOrderByWithAggregationInput[]
    by: SessionInviteLinkScalarFieldEnum[] | SessionInviteLinkScalarFieldEnum
    having?: SessionInviteLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionInviteLinkCountAggregateInputType | true
    _min?: SessionInviteLinkMinAggregateInputType
    _max?: SessionInviteLinkMaxAggregateInputType
  }

  export type SessionInviteLinkGroupByOutputType = {
    id: string
    token: string
    sessionId: string
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    _count: SessionInviteLinkCountAggregateOutputType | null
    _min: SessionInviteLinkMinAggregateOutputType | null
    _max: SessionInviteLinkMaxAggregateOutputType | null
  }

  type GetSessionInviteLinkGroupByPayload<T extends SessionInviteLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionInviteLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionInviteLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionInviteLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SessionInviteLinkGroupByOutputType[P]>
        }
      >
    >


  export type SessionInviteLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionInviteLink"]>

  export type SessionInviteLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionInviteLink"]>

  export type SessionInviteLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionInviteLink"]>

  export type SessionInviteLinkSelectScalar = {
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionInviteLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "sessionId" | "revokedAt" | "expiresAt" | "createdAt", ExtArgs["result"]["sessionInviteLink"]>
  export type SessionInviteLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type SessionInviteLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type SessionInviteLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $SessionInviteLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionInviteLink"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      sessionId: string
      revokedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["sessionInviteLink"]>
    composites: {}
  }

  type SessionInviteLinkGetPayload<S extends boolean | null | undefined | SessionInviteLinkDefaultArgs> = $Result.GetResult<Prisma.$SessionInviteLinkPayload, S>

  type SessionInviteLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionInviteLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionInviteLinkCountAggregateInputType | true
    }

  export interface SessionInviteLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionInviteLink'], meta: { name: 'SessionInviteLink' } }
    /**
     * Find zero or one SessionInviteLink that matches the filter.
     * @param {SessionInviteLinkFindUniqueArgs} args - Arguments to find a SessionInviteLink
     * @example
     * // Get one SessionInviteLink
     * const sessionInviteLink = await prisma.sessionInviteLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionInviteLinkFindUniqueArgs>(args: SelectSubset<T, SessionInviteLinkFindUniqueArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionInviteLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionInviteLinkFindUniqueOrThrowArgs} args - Arguments to find a SessionInviteLink
     * @example
     * // Get one SessionInviteLink
     * const sessionInviteLink = await prisma.sessionInviteLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionInviteLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionInviteLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionInviteLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkFindFirstArgs} args - Arguments to find a SessionInviteLink
     * @example
     * // Get one SessionInviteLink
     * const sessionInviteLink = await prisma.sessionInviteLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionInviteLinkFindFirstArgs>(args?: SelectSubset<T, SessionInviteLinkFindFirstArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionInviteLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkFindFirstOrThrowArgs} args - Arguments to find a SessionInviteLink
     * @example
     * // Get one SessionInviteLink
     * const sessionInviteLink = await prisma.sessionInviteLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionInviteLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionInviteLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionInviteLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionInviteLinks
     * const sessionInviteLinks = await prisma.sessionInviteLink.findMany()
     * 
     * // Get first 10 SessionInviteLinks
     * const sessionInviteLinks = await prisma.sessionInviteLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionInviteLinkWithIdOnly = await prisma.sessionInviteLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionInviteLinkFindManyArgs>(args?: SelectSubset<T, SessionInviteLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionInviteLink.
     * @param {SessionInviteLinkCreateArgs} args - Arguments to create a SessionInviteLink.
     * @example
     * // Create one SessionInviteLink
     * const SessionInviteLink = await prisma.sessionInviteLink.create({
     *   data: {
     *     // ... data to create a SessionInviteLink
     *   }
     * })
     * 
     */
    create<T extends SessionInviteLinkCreateArgs>(args: SelectSubset<T, SessionInviteLinkCreateArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionInviteLinks.
     * @param {SessionInviteLinkCreateManyArgs} args - Arguments to create many SessionInviteLinks.
     * @example
     * // Create many SessionInviteLinks
     * const sessionInviteLink = await prisma.sessionInviteLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionInviteLinkCreateManyArgs>(args?: SelectSubset<T, SessionInviteLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionInviteLinks and returns the data saved in the database.
     * @param {SessionInviteLinkCreateManyAndReturnArgs} args - Arguments to create many SessionInviteLinks.
     * @example
     * // Create many SessionInviteLinks
     * const sessionInviteLink = await prisma.sessionInviteLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionInviteLinks and only return the `id`
     * const sessionInviteLinkWithIdOnly = await prisma.sessionInviteLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionInviteLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionInviteLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionInviteLink.
     * @param {SessionInviteLinkDeleteArgs} args - Arguments to delete one SessionInviteLink.
     * @example
     * // Delete one SessionInviteLink
     * const SessionInviteLink = await prisma.sessionInviteLink.delete({
     *   where: {
     *     // ... filter to delete one SessionInviteLink
     *   }
     * })
     * 
     */
    delete<T extends SessionInviteLinkDeleteArgs>(args: SelectSubset<T, SessionInviteLinkDeleteArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionInviteLink.
     * @param {SessionInviteLinkUpdateArgs} args - Arguments to update one SessionInviteLink.
     * @example
     * // Update one SessionInviteLink
     * const sessionInviteLink = await prisma.sessionInviteLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionInviteLinkUpdateArgs>(args: SelectSubset<T, SessionInviteLinkUpdateArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionInviteLinks.
     * @param {SessionInviteLinkDeleteManyArgs} args - Arguments to filter SessionInviteLinks to delete.
     * @example
     * // Delete a few SessionInviteLinks
     * const { count } = await prisma.sessionInviteLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionInviteLinkDeleteManyArgs>(args?: SelectSubset<T, SessionInviteLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionInviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionInviteLinks
     * const sessionInviteLink = await prisma.sessionInviteLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionInviteLinkUpdateManyArgs>(args: SelectSubset<T, SessionInviteLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionInviteLinks and returns the data updated in the database.
     * @param {SessionInviteLinkUpdateManyAndReturnArgs} args - Arguments to update many SessionInviteLinks.
     * @example
     * // Update many SessionInviteLinks
     * const sessionInviteLink = await prisma.sessionInviteLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionInviteLinks and only return the `id`
     * const sessionInviteLinkWithIdOnly = await prisma.sessionInviteLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionInviteLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionInviteLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionInviteLink.
     * @param {SessionInviteLinkUpsertArgs} args - Arguments to update or create a SessionInviteLink.
     * @example
     * // Update or create a SessionInviteLink
     * const sessionInviteLink = await prisma.sessionInviteLink.upsert({
     *   create: {
     *     // ... data to create a SessionInviteLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionInviteLink we want to update
     *   }
     * })
     */
    upsert<T extends SessionInviteLinkUpsertArgs>(args: SelectSubset<T, SessionInviteLinkUpsertArgs<ExtArgs>>): Prisma__SessionInviteLinkClient<$Result.GetResult<Prisma.$SessionInviteLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionInviteLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkCountArgs} args - Arguments to filter SessionInviteLinks to count.
     * @example
     * // Count the number of SessionInviteLinks
     * const count = await prisma.sessionInviteLink.count({
     *   where: {
     *     // ... the filter for the SessionInviteLinks we want to count
     *   }
     * })
    **/
    count<T extends SessionInviteLinkCountArgs>(
      args?: Subset<T, SessionInviteLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionInviteLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionInviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionInviteLinkAggregateArgs>(args: Subset<T, SessionInviteLinkAggregateArgs>): Prisma.PrismaPromise<GetSessionInviteLinkAggregateType<T>>

    /**
     * Group by SessionInviteLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionInviteLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionInviteLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionInviteLinkGroupByArgs['orderBy'] }
        : { orderBy?: SessionInviteLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionInviteLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionInviteLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionInviteLink model
   */
  readonly fields: SessionInviteLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionInviteLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionInviteLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionInviteLink model
   */
  interface SessionInviteLinkFieldRefs {
    readonly id: FieldRef<"SessionInviteLink", 'String'>
    readonly token: FieldRef<"SessionInviteLink", 'String'>
    readonly sessionId: FieldRef<"SessionInviteLink", 'String'>
    readonly revokedAt: FieldRef<"SessionInviteLink", 'DateTime'>
    readonly expiresAt: FieldRef<"SessionInviteLink", 'DateTime'>
    readonly createdAt: FieldRef<"SessionInviteLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionInviteLink findUnique
   */
  export type SessionInviteLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionInviteLink to fetch.
     */
    where: SessionInviteLinkWhereUniqueInput
  }

  /**
   * SessionInviteLink findUniqueOrThrow
   */
  export type SessionInviteLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionInviteLink to fetch.
     */
    where: SessionInviteLinkWhereUniqueInput
  }

  /**
   * SessionInviteLink findFirst
   */
  export type SessionInviteLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionInviteLink to fetch.
     */
    where?: SessionInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionInviteLinks to fetch.
     */
    orderBy?: SessionInviteLinkOrderByWithRelationInput | SessionInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionInviteLinks.
     */
    cursor?: SessionInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionInviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionInviteLinks.
     */
    distinct?: SessionInviteLinkScalarFieldEnum | SessionInviteLinkScalarFieldEnum[]
  }

  /**
   * SessionInviteLink findFirstOrThrow
   */
  export type SessionInviteLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionInviteLink to fetch.
     */
    where?: SessionInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionInviteLinks to fetch.
     */
    orderBy?: SessionInviteLinkOrderByWithRelationInput | SessionInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionInviteLinks.
     */
    cursor?: SessionInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionInviteLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionInviteLinks.
     */
    distinct?: SessionInviteLinkScalarFieldEnum | SessionInviteLinkScalarFieldEnum[]
  }

  /**
   * SessionInviteLink findMany
   */
  export type SessionInviteLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionInviteLinks to fetch.
     */
    where?: SessionInviteLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionInviteLinks to fetch.
     */
    orderBy?: SessionInviteLinkOrderByWithRelationInput | SessionInviteLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionInviteLinks.
     */
    cursor?: SessionInviteLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionInviteLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionInviteLinks.
     */
    skip?: number
    distinct?: SessionInviteLinkScalarFieldEnum | SessionInviteLinkScalarFieldEnum[]
  }

  /**
   * SessionInviteLink create
   */
  export type SessionInviteLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionInviteLink.
     */
    data: XOR<SessionInviteLinkCreateInput, SessionInviteLinkUncheckedCreateInput>
  }

  /**
   * SessionInviteLink createMany
   */
  export type SessionInviteLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionInviteLinks.
     */
    data: SessionInviteLinkCreateManyInput | SessionInviteLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionInviteLink createManyAndReturn
   */
  export type SessionInviteLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * The data used to create many SessionInviteLinks.
     */
    data: SessionInviteLinkCreateManyInput | SessionInviteLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionInviteLink update
   */
  export type SessionInviteLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionInviteLink.
     */
    data: XOR<SessionInviteLinkUpdateInput, SessionInviteLinkUncheckedUpdateInput>
    /**
     * Choose, which SessionInviteLink to update.
     */
    where: SessionInviteLinkWhereUniqueInput
  }

  /**
   * SessionInviteLink updateMany
   */
  export type SessionInviteLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionInviteLinks.
     */
    data: XOR<SessionInviteLinkUpdateManyMutationInput, SessionInviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which SessionInviteLinks to update
     */
    where?: SessionInviteLinkWhereInput
    /**
     * Limit how many SessionInviteLinks to update.
     */
    limit?: number
  }

  /**
   * SessionInviteLink updateManyAndReturn
   */
  export type SessionInviteLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * The data used to update SessionInviteLinks.
     */
    data: XOR<SessionInviteLinkUpdateManyMutationInput, SessionInviteLinkUncheckedUpdateManyInput>
    /**
     * Filter which SessionInviteLinks to update
     */
    where?: SessionInviteLinkWhereInput
    /**
     * Limit how many SessionInviteLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionInviteLink upsert
   */
  export type SessionInviteLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionInviteLink to update in case it exists.
     */
    where: SessionInviteLinkWhereUniqueInput
    /**
     * In case the SessionInviteLink found by the `where` argument doesn't exist, create a new SessionInviteLink with this data.
     */
    create: XOR<SessionInviteLinkCreateInput, SessionInviteLinkUncheckedCreateInput>
    /**
     * In case the SessionInviteLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionInviteLinkUpdateInput, SessionInviteLinkUncheckedUpdateInput>
  }

  /**
   * SessionInviteLink delete
   */
  export type SessionInviteLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
    /**
     * Filter which SessionInviteLink to delete.
     */
    where: SessionInviteLinkWhereUniqueInput
  }

  /**
   * SessionInviteLink deleteMany
   */
  export type SessionInviteLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionInviteLinks to delete
     */
    where?: SessionInviteLinkWhereInput
    /**
     * Limit how many SessionInviteLinks to delete.
     */
    limit?: number
  }

  /**
   * SessionInviteLink without action
   */
  export type SessionInviteLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionInviteLink
     */
    select?: SessionInviteLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionInviteLink
     */
    omit?: SessionInviteLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInviteLinkInclude<ExtArgs> | null
  }


  /**
   * Model Court
   */

  export type AggregateCourt = {
    _count: CourtCountAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  export type CourtMinAggregateOutputType = {
    id: string | null
    name: string | null
    notes: string | null
    active: boolean | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type CourtMaxAggregateOutputType = {
    id: string | null
    name: string | null
    notes: string | null
    active: boolean | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type CourtCountAggregateOutputType = {
    id: number
    name: number
    notes: number
    active: number
    createdBy: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type CourtMinAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    active?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type CourtMaxAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    active?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type CourtCountAggregateInputType = {
    id?: true
    name?: true
    notes?: true
    active?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CourtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Court to aggregate.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courts
    **/
    _count?: true | CourtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtMaxAggregateInputType
  }

  export type GetCourtAggregateType<T extends CourtAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt[P]>
      : GetScalarType<T[P], AggregateCourt[P]>
  }




  export type CourtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithAggregationInput | CourtOrderByWithAggregationInput[]
    by: CourtScalarFieldEnum[] | CourtScalarFieldEnum
    having?: CourtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtCountAggregateInputType | true
    _min?: CourtMinAggregateInputType
    _max?: CourtMaxAggregateInputType
  }

  export type CourtGroupByOutputType = {
    id: string
    name: string
    notes: string | null
    active: boolean
    createdBy: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: CourtCountAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  type GetCourtGroupByPayload<T extends CourtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtGroupByOutputType[P]>
            : GetScalarType<T[P], CourtGroupByOutputType[P]>
        }
      >
    >


  export type CourtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    active?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    creator?: boolean | Court$creatorArgs<ExtArgs>
    courtSessions?: boolean | Court$courtSessionsArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["court"]>

  export type CourtSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    active?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    creator?: boolean | Court$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["court"]>

  export type CourtSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    notes?: boolean
    active?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    creator?: boolean | Court$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["court"]>

  export type CourtSelectScalar = {
    id?: boolean
    name?: boolean
    notes?: boolean
    active?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type CourtOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "notes" | "active" | "createdBy" | "createdAt" | "deletedAt", ExtArgs["result"]["court"]>
  export type CourtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Court$creatorArgs<ExtArgs>
    courtSessions?: boolean | Court$courtSessionsArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourtIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Court$creatorArgs<ExtArgs>
  }
  export type CourtIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Court$creatorArgs<ExtArgs>
  }

  export type $CourtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Court"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      courtSessions: Prisma.$CourtSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      notes: string | null
      active: boolean
      createdBy: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["court"]>
    composites: {}
  }

  type CourtGetPayload<S extends boolean | null | undefined | CourtDefaultArgs> = $Result.GetResult<Prisma.$CourtPayload, S>

  type CourtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourtFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourtCountAggregateInputType | true
    }

  export interface CourtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Court'], meta: { name: 'Court' } }
    /**
     * Find zero or one Court that matches the filter.
     * @param {CourtFindUniqueArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtFindUniqueArgs>(args: SelectSubset<T, CourtFindUniqueArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Court that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourtFindUniqueOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtFindFirstArgs>(args?: SelectSubset<T, CourtFindFirstArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Court that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courts
     * const courts = await prisma.court.findMany()
     * 
     * // Get first 10 Courts
     * const courts = await prisma.court.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtWithIdOnly = await prisma.court.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtFindManyArgs>(args?: SelectSubset<T, CourtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Court.
     * @param {CourtCreateArgs} args - Arguments to create a Court.
     * @example
     * // Create one Court
     * const Court = await prisma.court.create({
     *   data: {
     *     // ... data to create a Court
     *   }
     * })
     * 
     */
    create<T extends CourtCreateArgs>(args: SelectSubset<T, CourtCreateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courts.
     * @param {CourtCreateManyArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtCreateManyArgs>(args?: SelectSubset<T, CourtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courts and returns the data saved in the database.
     * @param {CourtCreateManyAndReturnArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courts and only return the `id`
     * const courtWithIdOnly = await prisma.court.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourtCreateManyAndReturnArgs>(args?: SelectSubset<T, CourtCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Court.
     * @param {CourtDeleteArgs} args - Arguments to delete one Court.
     * @example
     * // Delete one Court
     * const Court = await prisma.court.delete({
     *   where: {
     *     // ... filter to delete one Court
     *   }
     * })
     * 
     */
    delete<T extends CourtDeleteArgs>(args: SelectSubset<T, CourtDeleteArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Court.
     * @param {CourtUpdateArgs} args - Arguments to update one Court.
     * @example
     * // Update one Court
     * const court = await prisma.court.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtUpdateArgs>(args: SelectSubset<T, CourtUpdateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courts.
     * @param {CourtDeleteManyArgs} args - Arguments to filter Courts to delete.
     * @example
     * // Delete a few Courts
     * const { count } = await prisma.court.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtDeleteManyArgs>(args?: SelectSubset<T, CourtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courts
     * const court = await prisma.court.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtUpdateManyArgs>(args: SelectSubset<T, CourtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courts and returns the data updated in the database.
     * @param {CourtUpdateManyAndReturnArgs} args - Arguments to update many Courts.
     * @example
     * // Update many Courts
     * const court = await prisma.court.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courts and only return the `id`
     * const courtWithIdOnly = await prisma.court.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourtUpdateManyAndReturnArgs>(args: SelectSubset<T, CourtUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Court.
     * @param {CourtUpsertArgs} args - Arguments to update or create a Court.
     * @example
     * // Update or create a Court
     * const court = await prisma.court.upsert({
     *   create: {
     *     // ... data to create a Court
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court we want to update
     *   }
     * })
     */
    upsert<T extends CourtUpsertArgs>(args: SelectSubset<T, CourtUpsertArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCountArgs} args - Arguments to filter Courts to count.
     * @example
     * // Count the number of Courts
     * const count = await prisma.court.count({
     *   where: {
     *     // ... the filter for the Courts we want to count
     *   }
     * })
    **/
    count<T extends CourtCountArgs>(
      args?: Subset<T, CourtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtAggregateArgs>(args: Subset<T, CourtAggregateArgs>): Prisma.PrismaPromise<GetCourtAggregateType<T>>

    /**
     * Group by Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtGroupByArgs['orderBy'] }
        : { orderBy?: CourtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Court model
   */
  readonly fields: CourtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Court.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Court$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Court$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    courtSessions<T extends Court$courtSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Court$courtSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Court model
   */
  interface CourtFieldRefs {
    readonly id: FieldRef<"Court", 'String'>
    readonly name: FieldRef<"Court", 'String'>
    readonly notes: FieldRef<"Court", 'String'>
    readonly active: FieldRef<"Court", 'Boolean'>
    readonly createdBy: FieldRef<"Court", 'String'>
    readonly createdAt: FieldRef<"Court", 'DateTime'>
    readonly deletedAt: FieldRef<"Court", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Court findUnique
   */
  export type CourtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findUniqueOrThrow
   */
  export type CourtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findFirst
   */
  export type CourtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findFirstOrThrow
   */
  export type CourtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findMany
   */
  export type CourtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Courts to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court create
   */
  export type CourtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to create a Court.
     */
    data: XOR<CourtCreateInput, CourtUncheckedCreateInput>
  }

  /**
   * Court createMany
   */
  export type CourtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Court createManyAndReturn
   */
  export type CourtCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Court update
   */
  export type CourtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to update a Court.
     */
    data: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
    /**
     * Choose, which Court to update.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court updateMany
   */
  export type CourtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courts.
     */
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyInput>
    /**
     * Filter which Courts to update
     */
    where?: CourtWhereInput
    /**
     * Limit how many Courts to update.
     */
    limit?: number
  }

  /**
   * Court updateManyAndReturn
   */
  export type CourtUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * The data used to update Courts.
     */
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyInput>
    /**
     * Filter which Courts to update
     */
    where?: CourtWhereInput
    /**
     * Limit how many Courts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Court upsert
   */
  export type CourtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The filter to search for the Court to update in case it exists.
     */
    where: CourtWhereUniqueInput
    /**
     * In case the Court found by the `where` argument doesn't exist, create a new Court with this data.
     */
    create: XOR<CourtCreateInput, CourtUncheckedCreateInput>
    /**
     * In case the Court was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
  }

  /**
   * Court delete
   */
  export type CourtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter which Court to delete.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court deleteMany
   */
  export type CourtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courts to delete
     */
    where?: CourtWhereInput
    /**
     * Limit how many Courts to delete.
     */
    limit?: number
  }

  /**
   * Court.creator
   */
  export type Court$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Court.courtSessions
   */
  export type Court$courtSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    where?: CourtSessionWhereInput
    orderBy?: CourtSessionOrderByWithRelationInput | CourtSessionOrderByWithRelationInput[]
    cursor?: CourtSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtSessionScalarFieldEnum | CourtSessionScalarFieldEnum[]
  }

  /**
   * Court without action
   */
  export type CourtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Court
     */
    omit?: CourtOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
  }


  /**
   * Model CourtSession
   */

  export type AggregateCourtSession = {
    _count: CourtSessionCountAggregateOutputType | null
    _min: CourtSessionMinAggregateOutputType | null
    _max: CourtSessionMaxAggregateOutputType | null
  }

  export type CourtSessionMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    courtId: string | null
    status: $Enums.CourtStatus | null
    currentMatchId: string | null
    nextMatchId: string | null
    createdAt: Date | null
  }

  export type CourtSessionMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    courtId: string | null
    status: $Enums.CourtStatus | null
    currentMatchId: string | null
    nextMatchId: string | null
    createdAt: Date | null
  }

  export type CourtSessionCountAggregateOutputType = {
    id: number
    sessionId: number
    courtId: number
    status: number
    currentMatchId: number
    nextMatchId: number
    createdAt: number
    _all: number
  }


  export type CourtSessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    courtId?: true
    status?: true
    currentMatchId?: true
    nextMatchId?: true
    createdAt?: true
  }

  export type CourtSessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    courtId?: true
    status?: true
    currentMatchId?: true
    nextMatchId?: true
    createdAt?: true
  }

  export type CourtSessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    courtId?: true
    status?: true
    currentMatchId?: true
    nextMatchId?: true
    createdAt?: true
    _all?: true
  }

  export type CourtSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourtSession to aggregate.
     */
    where?: CourtSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtSessions to fetch.
     */
    orderBy?: CourtSessionOrderByWithRelationInput | CourtSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourtSessions
    **/
    _count?: true | CourtSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtSessionMaxAggregateInputType
  }

  export type GetCourtSessionAggregateType<T extends CourtSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCourtSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourtSession[P]>
      : GetScalarType<T[P], AggregateCourtSession[P]>
  }




  export type CourtSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtSessionWhereInput
    orderBy?: CourtSessionOrderByWithAggregationInput | CourtSessionOrderByWithAggregationInput[]
    by: CourtSessionScalarFieldEnum[] | CourtSessionScalarFieldEnum
    having?: CourtSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtSessionCountAggregateInputType | true
    _min?: CourtSessionMinAggregateInputType
    _max?: CourtSessionMaxAggregateInputType
  }

  export type CourtSessionGroupByOutputType = {
    id: string
    sessionId: string
    courtId: string
    status: $Enums.CourtStatus
    currentMatchId: string | null
    nextMatchId: string | null
    createdAt: Date
    _count: CourtSessionCountAggregateOutputType | null
    _min: CourtSessionMinAggregateOutputType | null
    _max: CourtSessionMaxAggregateOutputType | null
  }

  type GetCourtSessionGroupByPayload<T extends CourtSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CourtSessionGroupByOutputType[P]>
        }
      >
    >


  export type CourtSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    courtId?: boolean
    status?: boolean
    currentMatchId?: boolean
    nextMatchId?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtSession"]>

  export type CourtSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    courtId?: boolean
    status?: boolean
    currentMatchId?: boolean
    nextMatchId?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtSession"]>

  export type CourtSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    courtId?: boolean
    status?: boolean
    currentMatchId?: boolean
    nextMatchId?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courtSession"]>

  export type CourtSessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    courtId?: boolean
    status?: boolean
    currentMatchId?: boolean
    nextMatchId?: boolean
    createdAt?: boolean
  }

  export type CourtSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "courtId" | "status" | "currentMatchId" | "nextMatchId" | "createdAt", ExtArgs["result"]["courtSession"]>
  export type CourtSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }
  export type CourtSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }
  export type CourtSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    court?: boolean | CourtDefaultArgs<ExtArgs>
  }

  export type $CourtSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourtSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      court: Prisma.$CourtPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      courtId: string
      status: $Enums.CourtStatus
      currentMatchId: string | null
      nextMatchId: string | null
      createdAt: Date
    }, ExtArgs["result"]["courtSession"]>
    composites: {}
  }

  type CourtSessionGetPayload<S extends boolean | null | undefined | CourtSessionDefaultArgs> = $Result.GetResult<Prisma.$CourtSessionPayload, S>

  type CourtSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CourtSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CourtSessionCountAggregateInputType | true
    }

  export interface CourtSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourtSession'], meta: { name: 'CourtSession' } }
    /**
     * Find zero or one CourtSession that matches the filter.
     * @param {CourtSessionFindUniqueArgs} args - Arguments to find a CourtSession
     * @example
     * // Get one CourtSession
     * const courtSession = await prisma.courtSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtSessionFindUniqueArgs>(args: SelectSubset<T, CourtSessionFindUniqueArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CourtSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CourtSessionFindUniqueOrThrowArgs} args - Arguments to find a CourtSession
     * @example
     * // Get one CourtSession
     * const courtSession = await prisma.courtSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourtSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionFindFirstArgs} args - Arguments to find a CourtSession
     * @example
     * // Get one CourtSession
     * const courtSession = await prisma.courtSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtSessionFindFirstArgs>(args?: SelectSubset<T, CourtSessionFindFirstArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CourtSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionFindFirstOrThrowArgs} args - Arguments to find a CourtSession
     * @example
     * // Get one CourtSession
     * const courtSession = await prisma.courtSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CourtSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourtSessions
     * const courtSessions = await prisma.courtSession.findMany()
     * 
     * // Get first 10 CourtSessions
     * const courtSessions = await prisma.courtSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtSessionWithIdOnly = await prisma.courtSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtSessionFindManyArgs>(args?: SelectSubset<T, CourtSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CourtSession.
     * @param {CourtSessionCreateArgs} args - Arguments to create a CourtSession.
     * @example
     * // Create one CourtSession
     * const CourtSession = await prisma.courtSession.create({
     *   data: {
     *     // ... data to create a CourtSession
     *   }
     * })
     * 
     */
    create<T extends CourtSessionCreateArgs>(args: SelectSubset<T, CourtSessionCreateArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CourtSessions.
     * @param {CourtSessionCreateManyArgs} args - Arguments to create many CourtSessions.
     * @example
     * // Create many CourtSessions
     * const courtSession = await prisma.courtSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtSessionCreateManyArgs>(args?: SelectSubset<T, CourtSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourtSessions and returns the data saved in the database.
     * @param {CourtSessionCreateManyAndReturnArgs} args - Arguments to create many CourtSessions.
     * @example
     * // Create many CourtSessions
     * const courtSession = await prisma.courtSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourtSessions and only return the `id`
     * const courtSessionWithIdOnly = await prisma.courtSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourtSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CourtSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CourtSession.
     * @param {CourtSessionDeleteArgs} args - Arguments to delete one CourtSession.
     * @example
     * // Delete one CourtSession
     * const CourtSession = await prisma.courtSession.delete({
     *   where: {
     *     // ... filter to delete one CourtSession
     *   }
     * })
     * 
     */
    delete<T extends CourtSessionDeleteArgs>(args: SelectSubset<T, CourtSessionDeleteArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CourtSession.
     * @param {CourtSessionUpdateArgs} args - Arguments to update one CourtSession.
     * @example
     * // Update one CourtSession
     * const courtSession = await prisma.courtSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtSessionUpdateArgs>(args: SelectSubset<T, CourtSessionUpdateArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CourtSessions.
     * @param {CourtSessionDeleteManyArgs} args - Arguments to filter CourtSessions to delete.
     * @example
     * // Delete a few CourtSessions
     * const { count } = await prisma.courtSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtSessionDeleteManyArgs>(args?: SelectSubset<T, CourtSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourtSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourtSessions
     * const courtSession = await prisma.courtSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtSessionUpdateManyArgs>(args: SelectSubset<T, CourtSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourtSessions and returns the data updated in the database.
     * @param {CourtSessionUpdateManyAndReturnArgs} args - Arguments to update many CourtSessions.
     * @example
     * // Update many CourtSessions
     * const courtSession = await prisma.courtSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CourtSessions and only return the `id`
     * const courtSessionWithIdOnly = await prisma.courtSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CourtSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, CourtSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CourtSession.
     * @param {CourtSessionUpsertArgs} args - Arguments to update or create a CourtSession.
     * @example
     * // Update or create a CourtSession
     * const courtSession = await prisma.courtSession.upsert({
     *   create: {
     *     // ... data to create a CourtSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourtSession we want to update
     *   }
     * })
     */
    upsert<T extends CourtSessionUpsertArgs>(args: SelectSubset<T, CourtSessionUpsertArgs<ExtArgs>>): Prisma__CourtSessionClient<$Result.GetResult<Prisma.$CourtSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CourtSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionCountArgs} args - Arguments to filter CourtSessions to count.
     * @example
     * // Count the number of CourtSessions
     * const count = await prisma.courtSession.count({
     *   where: {
     *     // ... the filter for the CourtSessions we want to count
     *   }
     * })
    **/
    count<T extends CourtSessionCountArgs>(
      args?: Subset<T, CourtSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourtSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtSessionAggregateArgs>(args: Subset<T, CourtSessionAggregateArgs>): Prisma.PrismaPromise<GetCourtSessionAggregateType<T>>

    /**
     * Group by CourtSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtSessionGroupByArgs['orderBy'] }
        : { orderBy?: CourtSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourtSession model
   */
  readonly fields: CourtSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourtSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    court<T extends CourtDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourtDefaultArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourtSession model
   */
  interface CourtSessionFieldRefs {
    readonly id: FieldRef<"CourtSession", 'String'>
    readonly sessionId: FieldRef<"CourtSession", 'String'>
    readonly courtId: FieldRef<"CourtSession", 'String'>
    readonly status: FieldRef<"CourtSession", 'CourtStatus'>
    readonly currentMatchId: FieldRef<"CourtSession", 'String'>
    readonly nextMatchId: FieldRef<"CourtSession", 'String'>
    readonly createdAt: FieldRef<"CourtSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourtSession findUnique
   */
  export type CourtSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * Filter, which CourtSession to fetch.
     */
    where: CourtSessionWhereUniqueInput
  }

  /**
   * CourtSession findUniqueOrThrow
   */
  export type CourtSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * Filter, which CourtSession to fetch.
     */
    where: CourtSessionWhereUniqueInput
  }

  /**
   * CourtSession findFirst
   */
  export type CourtSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * Filter, which CourtSession to fetch.
     */
    where?: CourtSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtSessions to fetch.
     */
    orderBy?: CourtSessionOrderByWithRelationInput | CourtSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourtSessions.
     */
    cursor?: CourtSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourtSessions.
     */
    distinct?: CourtSessionScalarFieldEnum | CourtSessionScalarFieldEnum[]
  }

  /**
   * CourtSession findFirstOrThrow
   */
  export type CourtSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * Filter, which CourtSession to fetch.
     */
    where?: CourtSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtSessions to fetch.
     */
    orderBy?: CourtSessionOrderByWithRelationInput | CourtSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourtSessions.
     */
    cursor?: CourtSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourtSessions.
     */
    distinct?: CourtSessionScalarFieldEnum | CourtSessionScalarFieldEnum[]
  }

  /**
   * CourtSession findMany
   */
  export type CourtSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * Filter, which CourtSessions to fetch.
     */
    where?: CourtSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourtSessions to fetch.
     */
    orderBy?: CourtSessionOrderByWithRelationInput | CourtSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourtSessions.
     */
    cursor?: CourtSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourtSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourtSessions.
     */
    skip?: number
    distinct?: CourtSessionScalarFieldEnum | CourtSessionScalarFieldEnum[]
  }

  /**
   * CourtSession create
   */
  export type CourtSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CourtSession.
     */
    data: XOR<CourtSessionCreateInput, CourtSessionUncheckedCreateInput>
  }

  /**
   * CourtSession createMany
   */
  export type CourtSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourtSessions.
     */
    data: CourtSessionCreateManyInput | CourtSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CourtSession createManyAndReturn
   */
  export type CourtSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * The data used to create many CourtSessions.
     */
    data: CourtSessionCreateManyInput | CourtSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourtSession update
   */
  export type CourtSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CourtSession.
     */
    data: XOR<CourtSessionUpdateInput, CourtSessionUncheckedUpdateInput>
    /**
     * Choose, which CourtSession to update.
     */
    where: CourtSessionWhereUniqueInput
  }

  /**
   * CourtSession updateMany
   */
  export type CourtSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourtSessions.
     */
    data: XOR<CourtSessionUpdateManyMutationInput, CourtSessionUncheckedUpdateManyInput>
    /**
     * Filter which CourtSessions to update
     */
    where?: CourtSessionWhereInput
    /**
     * Limit how many CourtSessions to update.
     */
    limit?: number
  }

  /**
   * CourtSession updateManyAndReturn
   */
  export type CourtSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * The data used to update CourtSessions.
     */
    data: XOR<CourtSessionUpdateManyMutationInput, CourtSessionUncheckedUpdateManyInput>
    /**
     * Filter which CourtSessions to update
     */
    where?: CourtSessionWhereInput
    /**
     * Limit how many CourtSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourtSession upsert
   */
  export type CourtSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CourtSession to update in case it exists.
     */
    where: CourtSessionWhereUniqueInput
    /**
     * In case the CourtSession found by the `where` argument doesn't exist, create a new CourtSession with this data.
     */
    create: XOR<CourtSessionCreateInput, CourtSessionUncheckedCreateInput>
    /**
     * In case the CourtSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtSessionUpdateInput, CourtSessionUncheckedUpdateInput>
  }

  /**
   * CourtSession delete
   */
  export type CourtSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
    /**
     * Filter which CourtSession to delete.
     */
    where: CourtSessionWhereUniqueInput
  }

  /**
   * CourtSession deleteMany
   */
  export type CourtSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourtSessions to delete
     */
    where?: CourtSessionWhereInput
    /**
     * Limit how many CourtSessions to delete.
     */
    limit?: number
  }

  /**
   * CourtSession without action
   */
  export type CourtSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtSession
     */
    select?: CourtSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CourtSession
     */
    omit?: CourtSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtSessionInclude<ExtArgs> | null
  }


  /**
   * Model Player
   */

  export type AggregatePlayer = {
    _count: PlayerCountAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  export type PlayerMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    nickname: string | null
    skillLevel: string | null
    contact: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type PlayerMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    nickname: string | null
    skillLevel: string | null
    contact: string | null
    createdBy: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type PlayerCountAggregateOutputType = {
    id: number
    fullName: number
    nickname: number
    skillLevel: number
    contact: number
    createdBy: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type PlayerMinAggregateInputType = {
    id?: true
    fullName?: true
    nickname?: true
    skillLevel?: true
    contact?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type PlayerMaxAggregateInputType = {
    id?: true
    fullName?: true
    nickname?: true
    skillLevel?: true
    contact?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
  }

  export type PlayerCountAggregateInputType = {
    id?: true
    fullName?: true
    nickname?: true
    skillLevel?: true
    contact?: true
    createdBy?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Player to aggregate.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Players
    **/
    _count?: true | PlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlayerMaxAggregateInputType
  }

  export type GetPlayerAggregateType<T extends PlayerAggregateArgs> = {
        [P in keyof T & keyof AggregatePlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlayer[P]>
      : GetScalarType<T[P], AggregatePlayer[P]>
  }




  export type PlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlayerWhereInput
    orderBy?: PlayerOrderByWithAggregationInput | PlayerOrderByWithAggregationInput[]
    by: PlayerScalarFieldEnum[] | PlayerScalarFieldEnum
    having?: PlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlayerCountAggregateInputType | true
    _min?: PlayerMinAggregateInputType
    _max?: PlayerMaxAggregateInputType
  }

  export type PlayerGroupByOutputType = {
    id: string
    fullName: string
    nickname: string | null
    skillLevel: string | null
    contact: string | null
    createdBy: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: PlayerCountAggregateOutputType | null
    _min: PlayerMinAggregateOutputType | null
    _max: PlayerMaxAggregateOutputType | null
  }

  type GetPlayerGroupByPayload<T extends PlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlayerGroupByOutputType[P]>
            : GetScalarType<T[P], PlayerGroupByOutputType[P]>
        }
      >
    >


  export type PlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    nickname?: boolean
    skillLevel?: boolean
    contact?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    creator?: boolean | Player$creatorArgs<ExtArgs>
    sessionPlayers?: boolean | Player$sessionPlayersArgs<ExtArgs>
    queueEntryPlayers?: boolean | Player$queueEntryPlayersArgs<ExtArgs>
    matchParticipants?: boolean | Player$matchParticipantsArgs<ExtArgs>
    payments?: boolean | Player$paymentsArgs<ExtArgs>
    shareLinks?: boolean | Player$shareLinksArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    nickname?: boolean
    skillLevel?: boolean
    contact?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    creator?: boolean | Player$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    nickname?: boolean
    skillLevel?: boolean
    contact?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    creator?: boolean | Player$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["player"]>

  export type PlayerSelectScalar = {
    id?: boolean
    fullName?: boolean
    nickname?: boolean
    skillLevel?: boolean
    contact?: boolean
    createdBy?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type PlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "nickname" | "skillLevel" | "contact" | "createdBy" | "createdAt" | "deletedAt", ExtArgs["result"]["player"]>
  export type PlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Player$creatorArgs<ExtArgs>
    sessionPlayers?: boolean | Player$sessionPlayersArgs<ExtArgs>
    queueEntryPlayers?: boolean | Player$queueEntryPlayersArgs<ExtArgs>
    matchParticipants?: boolean | Player$matchParticipantsArgs<ExtArgs>
    payments?: boolean | Player$paymentsArgs<ExtArgs>
    shareLinks?: boolean | Player$shareLinksArgs<ExtArgs>
    _count?: boolean | PlayerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Player$creatorArgs<ExtArgs>
  }
  export type PlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Player$creatorArgs<ExtArgs>
  }

  export type $PlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Player"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      sessionPlayers: Prisma.$SessionPlayerPayload<ExtArgs>[]
      queueEntryPlayers: Prisma.$QueueEntryPlayerPayload<ExtArgs>[]
      matchParticipants: Prisma.$MatchParticipantPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      shareLinks: Prisma.$ShareLinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      nickname: string | null
      skillLevel: string | null
      contact: string | null
      createdBy: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["player"]>
    composites: {}
  }

  type PlayerGetPayload<S extends boolean | null | undefined | PlayerDefaultArgs> = $Result.GetResult<Prisma.$PlayerPayload, S>

  type PlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlayerCountAggregateInputType | true
    }

  export interface PlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Player'], meta: { name: 'Player' } }
    /**
     * Find zero or one Player that matches the filter.
     * @param {PlayerFindUniqueArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlayerFindUniqueArgs>(args: SelectSubset<T, PlayerFindUniqueArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Player that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlayerFindUniqueOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, PlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlayerFindFirstArgs>(args?: SelectSubset<T, PlayerFindFirstArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Player that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindFirstOrThrowArgs} args - Arguments to find a Player
     * @example
     * // Get one Player
     * const player = await prisma.player.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, PlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Players that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Players
     * const players = await prisma.player.findMany()
     * 
     * // Get first 10 Players
     * const players = await prisma.player.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const playerWithIdOnly = await prisma.player.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlayerFindManyArgs>(args?: SelectSubset<T, PlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Player.
     * @param {PlayerCreateArgs} args - Arguments to create a Player.
     * @example
     * // Create one Player
     * const Player = await prisma.player.create({
     *   data: {
     *     // ... data to create a Player
     *   }
     * })
     * 
     */
    create<T extends PlayerCreateArgs>(args: SelectSubset<T, PlayerCreateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Players.
     * @param {PlayerCreateManyArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlayerCreateManyArgs>(args?: SelectSubset<T, PlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Players and returns the data saved in the database.
     * @param {PlayerCreateManyAndReturnArgs} args - Arguments to create many Players.
     * @example
     * // Create many Players
     * const player = await prisma.player.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, PlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Player.
     * @param {PlayerDeleteArgs} args - Arguments to delete one Player.
     * @example
     * // Delete one Player
     * const Player = await prisma.player.delete({
     *   where: {
     *     // ... filter to delete one Player
     *   }
     * })
     * 
     */
    delete<T extends PlayerDeleteArgs>(args: SelectSubset<T, PlayerDeleteArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Player.
     * @param {PlayerUpdateArgs} args - Arguments to update one Player.
     * @example
     * // Update one Player
     * const player = await prisma.player.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlayerUpdateArgs>(args: SelectSubset<T, PlayerUpdateArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Players.
     * @param {PlayerDeleteManyArgs} args - Arguments to filter Players to delete.
     * @example
     * // Delete a few Players
     * const { count } = await prisma.player.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlayerDeleteManyArgs>(args?: SelectSubset<T, PlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlayerUpdateManyArgs>(args: SelectSubset<T, PlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Players and returns the data updated in the database.
     * @param {PlayerUpdateManyAndReturnArgs} args - Arguments to update many Players.
     * @example
     * // Update many Players
     * const player = await prisma.player.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Players and only return the `id`
     * const playerWithIdOnly = await prisma.player.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, PlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Player.
     * @param {PlayerUpsertArgs} args - Arguments to update or create a Player.
     * @example
     * // Update or create a Player
     * const player = await prisma.player.upsert({
     *   create: {
     *     // ... data to create a Player
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Player we want to update
     *   }
     * })
     */
    upsert<T extends PlayerUpsertArgs>(args: SelectSubset<T, PlayerUpsertArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Players.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerCountArgs} args - Arguments to filter Players to count.
     * @example
     * // Count the number of Players
     * const count = await prisma.player.count({
     *   where: {
     *     // ... the filter for the Players we want to count
     *   }
     * })
    **/
    count<T extends PlayerCountArgs>(
      args?: Subset<T, PlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlayerAggregateArgs>(args: Subset<T, PlayerAggregateArgs>): Prisma.PrismaPromise<GetPlayerAggregateType<T>>

    /**
     * Group by Player.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlayerGroupByArgs['orderBy'] }
        : { orderBy?: PlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Player model
   */
  readonly fields: PlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Player.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Player$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Player$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sessionPlayers<T extends Player$sessionPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Player$sessionPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    queueEntryPlayers<T extends Player$queueEntryPlayersArgs<ExtArgs> = {}>(args?: Subset<T, Player$queueEntryPlayersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchParticipants<T extends Player$matchParticipantsArgs<ExtArgs> = {}>(args?: Subset<T, Player$matchParticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Player$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Player$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shareLinks<T extends Player$shareLinksArgs<ExtArgs> = {}>(args?: Subset<T, Player$shareLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Player model
   */
  interface PlayerFieldRefs {
    readonly id: FieldRef<"Player", 'String'>
    readonly fullName: FieldRef<"Player", 'String'>
    readonly nickname: FieldRef<"Player", 'String'>
    readonly skillLevel: FieldRef<"Player", 'String'>
    readonly contact: FieldRef<"Player", 'String'>
    readonly createdBy: FieldRef<"Player", 'String'>
    readonly createdAt: FieldRef<"Player", 'DateTime'>
    readonly deletedAt: FieldRef<"Player", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Player findUnique
   */
  export type PlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findUniqueOrThrow
   */
  export type PlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player findFirst
   */
  export type PlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findFirstOrThrow
   */
  export type PlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Player to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Players.
     */
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player findMany
   */
  export type PlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter, which Players to fetch.
     */
    where?: PlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Players to fetch.
     */
    orderBy?: PlayerOrderByWithRelationInput | PlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Players.
     */
    cursor?: PlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Players from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Players.
     */
    skip?: number
    distinct?: PlayerScalarFieldEnum | PlayerScalarFieldEnum[]
  }

  /**
   * Player create
   */
  export type PlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a Player.
     */
    data: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
  }

  /**
   * Player createMany
   */
  export type PlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Player createManyAndReturn
   */
  export type PlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to create many Players.
     */
    data: PlayerCreateManyInput | PlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player update
   */
  export type PlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a Player.
     */
    data: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
    /**
     * Choose, which Player to update.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player updateMany
   */
  export type PlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
  }

  /**
   * Player updateManyAndReturn
   */
  export type PlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * The data used to update Players.
     */
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyInput>
    /**
     * Filter which Players to update
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Player upsert
   */
  export type PlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the Player to update in case it exists.
     */
    where: PlayerWhereUniqueInput
    /**
     * In case the Player found by the `where` argument doesn't exist, create a new Player with this data.
     */
    create: XOR<PlayerCreateInput, PlayerUncheckedCreateInput>
    /**
     * In case the Player was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlayerUpdateInput, PlayerUncheckedUpdateInput>
  }

  /**
   * Player delete
   */
  export type PlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
    /**
     * Filter which Player to delete.
     */
    where: PlayerWhereUniqueInput
  }

  /**
   * Player deleteMany
   */
  export type PlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Players to delete
     */
    where?: PlayerWhereInput
    /**
     * Limit how many Players to delete.
     */
    limit?: number
  }

  /**
   * Player.creator
   */
  export type Player$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Player.sessionPlayers
   */
  export type Player$sessionPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    where?: SessionPlayerWhereInput
    orderBy?: SessionPlayerOrderByWithRelationInput | SessionPlayerOrderByWithRelationInput[]
    cursor?: SessionPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionPlayerScalarFieldEnum | SessionPlayerScalarFieldEnum[]
  }

  /**
   * Player.queueEntryPlayers
   */
  export type Player$queueEntryPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    where?: QueueEntryPlayerWhereInput
    orderBy?: QueueEntryPlayerOrderByWithRelationInput | QueueEntryPlayerOrderByWithRelationInput[]
    cursor?: QueueEntryPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueEntryPlayerScalarFieldEnum | QueueEntryPlayerScalarFieldEnum[]
  }

  /**
   * Player.matchParticipants
   */
  export type Player$matchParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    where?: MatchParticipantWhereInput
    orderBy?: MatchParticipantOrderByWithRelationInput | MatchParticipantOrderByWithRelationInput[]
    cursor?: MatchParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchParticipantScalarFieldEnum | MatchParticipantScalarFieldEnum[]
  }

  /**
   * Player.payments
   */
  export type Player$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Player.shareLinks
   */
  export type Player$shareLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    cursor?: ShareLinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * Player without action
   */
  export type PlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Player
     */
    select?: PlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Player
     */
    omit?: PlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlayerInclude<ExtArgs> | null
  }


  /**
   * Model SessionPlayer
   */

  export type AggregateSessionPlayer = {
    _count: SessionPlayerCountAggregateOutputType | null
    _avg: SessionPlayerAvgAggregateOutputType | null
    _sum: SessionPlayerSumAggregateOutputType | null
    _min: SessionPlayerMinAggregateOutputType | null
    _max: SessionPlayerMaxAggregateOutputType | null
  }

  export type SessionPlayerAvgAggregateOutputType = {
    gamesPlayed: number | null
    wins: number | null
    losses: number | null
    totalQueueSeconds: number | null
  }

  export type SessionPlayerSumAggregateOutputType = {
    gamesPlayed: number | null
    wins: number | null
    losses: number | null
    totalQueueSeconds: number | null
  }

  export type SessionPlayerMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    playerId: string | null
    status: $Enums.PlayerStatus | null
    isNewPlayer: boolean | null
    checkedInAt: Date | null
    lastPlayedAt: Date | null
    gamesPlayed: number | null
    wins: number | null
    losses: number | null
    totalQueueSeconds: number | null
  }

  export type SessionPlayerMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    playerId: string | null
    status: $Enums.PlayerStatus | null
    isNewPlayer: boolean | null
    checkedInAt: Date | null
    lastPlayedAt: Date | null
    gamesPlayed: number | null
    wins: number | null
    losses: number | null
    totalQueueSeconds: number | null
  }

  export type SessionPlayerCountAggregateOutputType = {
    id: number
    sessionId: number
    playerId: number
    status: number
    isNewPlayer: number
    checkedInAt: number
    lastPlayedAt: number
    gamesPlayed: number
    wins: number
    losses: number
    totalQueueSeconds: number
    _all: number
  }


  export type SessionPlayerAvgAggregateInputType = {
    gamesPlayed?: true
    wins?: true
    losses?: true
    totalQueueSeconds?: true
  }

  export type SessionPlayerSumAggregateInputType = {
    gamesPlayed?: true
    wins?: true
    losses?: true
    totalQueueSeconds?: true
  }

  export type SessionPlayerMinAggregateInputType = {
    id?: true
    sessionId?: true
    playerId?: true
    status?: true
    isNewPlayer?: true
    checkedInAt?: true
    lastPlayedAt?: true
    gamesPlayed?: true
    wins?: true
    losses?: true
    totalQueueSeconds?: true
  }

  export type SessionPlayerMaxAggregateInputType = {
    id?: true
    sessionId?: true
    playerId?: true
    status?: true
    isNewPlayer?: true
    checkedInAt?: true
    lastPlayedAt?: true
    gamesPlayed?: true
    wins?: true
    losses?: true
    totalQueueSeconds?: true
  }

  export type SessionPlayerCountAggregateInputType = {
    id?: true
    sessionId?: true
    playerId?: true
    status?: true
    isNewPlayer?: true
    checkedInAt?: true
    lastPlayedAt?: true
    gamesPlayed?: true
    wins?: true
    losses?: true
    totalQueueSeconds?: true
    _all?: true
  }

  export type SessionPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionPlayer to aggregate.
     */
    where?: SessionPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionPlayers to fetch.
     */
    orderBy?: SessionPlayerOrderByWithRelationInput | SessionPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionPlayers
    **/
    _count?: true | SessionPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionPlayerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionPlayerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionPlayerMaxAggregateInputType
  }

  export type GetSessionPlayerAggregateType<T extends SessionPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionPlayer[P]>
      : GetScalarType<T[P], AggregateSessionPlayer[P]>
  }




  export type SessionPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionPlayerWhereInput
    orderBy?: SessionPlayerOrderByWithAggregationInput | SessionPlayerOrderByWithAggregationInput[]
    by: SessionPlayerScalarFieldEnum[] | SessionPlayerScalarFieldEnum
    having?: SessionPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionPlayerCountAggregateInputType | true
    _avg?: SessionPlayerAvgAggregateInputType
    _sum?: SessionPlayerSumAggregateInputType
    _min?: SessionPlayerMinAggregateInputType
    _max?: SessionPlayerMaxAggregateInputType
  }

  export type SessionPlayerGroupByOutputType = {
    id: string
    sessionId: string
    playerId: string
    status: $Enums.PlayerStatus
    isNewPlayer: boolean
    checkedInAt: Date
    lastPlayedAt: Date | null
    gamesPlayed: number
    wins: number
    losses: number
    totalQueueSeconds: number
    _count: SessionPlayerCountAggregateOutputType | null
    _avg: SessionPlayerAvgAggregateOutputType | null
    _sum: SessionPlayerSumAggregateOutputType | null
    _min: SessionPlayerMinAggregateOutputType | null
    _max: SessionPlayerMaxAggregateOutputType | null
  }

  type GetSessionPlayerGroupByPayload<T extends SessionPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], SessionPlayerGroupByOutputType[P]>
        }
      >
    >


  export type SessionPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    status?: boolean
    isNewPlayer?: boolean
    checkedInAt?: boolean
    lastPlayedAt?: boolean
    gamesPlayed?: boolean
    wins?: boolean
    losses?: boolean
    totalQueueSeconds?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionPlayer"]>

  export type SessionPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    status?: boolean
    isNewPlayer?: boolean
    checkedInAt?: boolean
    lastPlayedAt?: boolean
    gamesPlayed?: boolean
    wins?: boolean
    losses?: boolean
    totalQueueSeconds?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionPlayer"]>

  export type SessionPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    status?: boolean
    isNewPlayer?: boolean
    checkedInAt?: boolean
    lastPlayedAt?: boolean
    gamesPlayed?: boolean
    wins?: boolean
    losses?: boolean
    totalQueueSeconds?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionPlayer"]>

  export type SessionPlayerSelectScalar = {
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    status?: boolean
    isNewPlayer?: boolean
    checkedInAt?: boolean
    lastPlayedAt?: boolean
    gamesPlayed?: boolean
    wins?: boolean
    losses?: boolean
    totalQueueSeconds?: boolean
  }

  export type SessionPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "playerId" | "status" | "isNewPlayer" | "checkedInAt" | "lastPlayedAt" | "gamesPlayed" | "wins" | "losses" | "totalQueueSeconds", ExtArgs["result"]["sessionPlayer"]>
  export type SessionPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type SessionPlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type SessionPlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $SessionPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionPlayer"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      playerId: string
      status: $Enums.PlayerStatus
      isNewPlayer: boolean
      checkedInAt: Date
      lastPlayedAt: Date | null
      gamesPlayed: number
      wins: number
      losses: number
      totalQueueSeconds: number
    }, ExtArgs["result"]["sessionPlayer"]>
    composites: {}
  }

  type SessionPlayerGetPayload<S extends boolean | null | undefined | SessionPlayerDefaultArgs> = $Result.GetResult<Prisma.$SessionPlayerPayload, S>

  type SessionPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionPlayerCountAggregateInputType | true
    }

  export interface SessionPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionPlayer'], meta: { name: 'SessionPlayer' } }
    /**
     * Find zero or one SessionPlayer that matches the filter.
     * @param {SessionPlayerFindUniqueArgs} args - Arguments to find a SessionPlayer
     * @example
     * // Get one SessionPlayer
     * const sessionPlayer = await prisma.sessionPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionPlayerFindUniqueArgs>(args: SelectSubset<T, SessionPlayerFindUniqueArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionPlayerFindUniqueOrThrowArgs} args - Arguments to find a SessionPlayer
     * @example
     * // Get one SessionPlayer
     * const sessionPlayer = await prisma.sessionPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerFindFirstArgs} args - Arguments to find a SessionPlayer
     * @example
     * // Get one SessionPlayer
     * const sessionPlayer = await prisma.sessionPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionPlayerFindFirstArgs>(args?: SelectSubset<T, SessionPlayerFindFirstArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerFindFirstOrThrowArgs} args - Arguments to find a SessionPlayer
     * @example
     * // Get one SessionPlayer
     * const sessionPlayer = await prisma.sessionPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionPlayers
     * const sessionPlayers = await prisma.sessionPlayer.findMany()
     * 
     * // Get first 10 SessionPlayers
     * const sessionPlayers = await prisma.sessionPlayer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionPlayerWithIdOnly = await prisma.sessionPlayer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionPlayerFindManyArgs>(args?: SelectSubset<T, SessionPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionPlayer.
     * @param {SessionPlayerCreateArgs} args - Arguments to create a SessionPlayer.
     * @example
     * // Create one SessionPlayer
     * const SessionPlayer = await prisma.sessionPlayer.create({
     *   data: {
     *     // ... data to create a SessionPlayer
     *   }
     * })
     * 
     */
    create<T extends SessionPlayerCreateArgs>(args: SelectSubset<T, SessionPlayerCreateArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionPlayers.
     * @param {SessionPlayerCreateManyArgs} args - Arguments to create many SessionPlayers.
     * @example
     * // Create many SessionPlayers
     * const sessionPlayer = await prisma.sessionPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionPlayerCreateManyArgs>(args?: SelectSubset<T, SessionPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionPlayers and returns the data saved in the database.
     * @param {SessionPlayerCreateManyAndReturnArgs} args - Arguments to create many SessionPlayers.
     * @example
     * // Create many SessionPlayers
     * const sessionPlayer = await prisma.sessionPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionPlayers and only return the `id`
     * const sessionPlayerWithIdOnly = await prisma.sessionPlayer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionPlayer.
     * @param {SessionPlayerDeleteArgs} args - Arguments to delete one SessionPlayer.
     * @example
     * // Delete one SessionPlayer
     * const SessionPlayer = await prisma.sessionPlayer.delete({
     *   where: {
     *     // ... filter to delete one SessionPlayer
     *   }
     * })
     * 
     */
    delete<T extends SessionPlayerDeleteArgs>(args: SelectSubset<T, SessionPlayerDeleteArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionPlayer.
     * @param {SessionPlayerUpdateArgs} args - Arguments to update one SessionPlayer.
     * @example
     * // Update one SessionPlayer
     * const sessionPlayer = await prisma.sessionPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionPlayerUpdateArgs>(args: SelectSubset<T, SessionPlayerUpdateArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionPlayers.
     * @param {SessionPlayerDeleteManyArgs} args - Arguments to filter SessionPlayers to delete.
     * @example
     * // Delete a few SessionPlayers
     * const { count } = await prisma.sessionPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionPlayerDeleteManyArgs>(args?: SelectSubset<T, SessionPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionPlayers
     * const sessionPlayer = await prisma.sessionPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionPlayerUpdateManyArgs>(args: SelectSubset<T, SessionPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionPlayers and returns the data updated in the database.
     * @param {SessionPlayerUpdateManyAndReturnArgs} args - Arguments to update many SessionPlayers.
     * @example
     * // Update many SessionPlayers
     * const sessionPlayer = await prisma.sessionPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionPlayers and only return the `id`
     * const sessionPlayerWithIdOnly = await prisma.sessionPlayer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionPlayer.
     * @param {SessionPlayerUpsertArgs} args - Arguments to update or create a SessionPlayer.
     * @example
     * // Update or create a SessionPlayer
     * const sessionPlayer = await prisma.sessionPlayer.upsert({
     *   create: {
     *     // ... data to create a SessionPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionPlayer we want to update
     *   }
     * })
     */
    upsert<T extends SessionPlayerUpsertArgs>(args: SelectSubset<T, SessionPlayerUpsertArgs<ExtArgs>>): Prisma__SessionPlayerClient<$Result.GetResult<Prisma.$SessionPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerCountArgs} args - Arguments to filter SessionPlayers to count.
     * @example
     * // Count the number of SessionPlayers
     * const count = await prisma.sessionPlayer.count({
     *   where: {
     *     // ... the filter for the SessionPlayers we want to count
     *   }
     * })
    **/
    count<T extends SessionPlayerCountArgs>(
      args?: Subset<T, SessionPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionPlayerAggregateArgs>(args: Subset<T, SessionPlayerAggregateArgs>): Prisma.PrismaPromise<GetSessionPlayerAggregateType<T>>

    /**
     * Group by SessionPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionPlayerGroupByArgs['orderBy'] }
        : { orderBy?: SessionPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionPlayer model
   */
  readonly fields: SessionPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionPlayer model
   */
  interface SessionPlayerFieldRefs {
    readonly id: FieldRef<"SessionPlayer", 'String'>
    readonly sessionId: FieldRef<"SessionPlayer", 'String'>
    readonly playerId: FieldRef<"SessionPlayer", 'String'>
    readonly status: FieldRef<"SessionPlayer", 'PlayerStatus'>
    readonly isNewPlayer: FieldRef<"SessionPlayer", 'Boolean'>
    readonly checkedInAt: FieldRef<"SessionPlayer", 'DateTime'>
    readonly lastPlayedAt: FieldRef<"SessionPlayer", 'DateTime'>
    readonly gamesPlayed: FieldRef<"SessionPlayer", 'Int'>
    readonly wins: FieldRef<"SessionPlayer", 'Int'>
    readonly losses: FieldRef<"SessionPlayer", 'Int'>
    readonly totalQueueSeconds: FieldRef<"SessionPlayer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionPlayer findUnique
   */
  export type SessionPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * Filter, which SessionPlayer to fetch.
     */
    where: SessionPlayerWhereUniqueInput
  }

  /**
   * SessionPlayer findUniqueOrThrow
   */
  export type SessionPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * Filter, which SessionPlayer to fetch.
     */
    where: SessionPlayerWhereUniqueInput
  }

  /**
   * SessionPlayer findFirst
   */
  export type SessionPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * Filter, which SessionPlayer to fetch.
     */
    where?: SessionPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionPlayers to fetch.
     */
    orderBy?: SessionPlayerOrderByWithRelationInput | SessionPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionPlayers.
     */
    cursor?: SessionPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionPlayers.
     */
    distinct?: SessionPlayerScalarFieldEnum | SessionPlayerScalarFieldEnum[]
  }

  /**
   * SessionPlayer findFirstOrThrow
   */
  export type SessionPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * Filter, which SessionPlayer to fetch.
     */
    where?: SessionPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionPlayers to fetch.
     */
    orderBy?: SessionPlayerOrderByWithRelationInput | SessionPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionPlayers.
     */
    cursor?: SessionPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionPlayers.
     */
    distinct?: SessionPlayerScalarFieldEnum | SessionPlayerScalarFieldEnum[]
  }

  /**
   * SessionPlayer findMany
   */
  export type SessionPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * Filter, which SessionPlayers to fetch.
     */
    where?: SessionPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionPlayers to fetch.
     */
    orderBy?: SessionPlayerOrderByWithRelationInput | SessionPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionPlayers.
     */
    cursor?: SessionPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionPlayers.
     */
    skip?: number
    distinct?: SessionPlayerScalarFieldEnum | SessionPlayerScalarFieldEnum[]
  }

  /**
   * SessionPlayer create
   */
  export type SessionPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionPlayer.
     */
    data: XOR<SessionPlayerCreateInput, SessionPlayerUncheckedCreateInput>
  }

  /**
   * SessionPlayer createMany
   */
  export type SessionPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionPlayers.
     */
    data: SessionPlayerCreateManyInput | SessionPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionPlayer createManyAndReturn
   */
  export type SessionPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many SessionPlayers.
     */
    data: SessionPlayerCreateManyInput | SessionPlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionPlayer update
   */
  export type SessionPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionPlayer.
     */
    data: XOR<SessionPlayerUpdateInput, SessionPlayerUncheckedUpdateInput>
    /**
     * Choose, which SessionPlayer to update.
     */
    where: SessionPlayerWhereUniqueInput
  }

  /**
   * SessionPlayer updateMany
   */
  export type SessionPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionPlayers.
     */
    data: XOR<SessionPlayerUpdateManyMutationInput, SessionPlayerUncheckedUpdateManyInput>
    /**
     * Filter which SessionPlayers to update
     */
    where?: SessionPlayerWhereInput
    /**
     * Limit how many SessionPlayers to update.
     */
    limit?: number
  }

  /**
   * SessionPlayer updateManyAndReturn
   */
  export type SessionPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * The data used to update SessionPlayers.
     */
    data: XOR<SessionPlayerUpdateManyMutationInput, SessionPlayerUncheckedUpdateManyInput>
    /**
     * Filter which SessionPlayers to update
     */
    where?: SessionPlayerWhereInput
    /**
     * Limit how many SessionPlayers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionPlayer upsert
   */
  export type SessionPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionPlayer to update in case it exists.
     */
    where: SessionPlayerWhereUniqueInput
    /**
     * In case the SessionPlayer found by the `where` argument doesn't exist, create a new SessionPlayer with this data.
     */
    create: XOR<SessionPlayerCreateInput, SessionPlayerUncheckedCreateInput>
    /**
     * In case the SessionPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionPlayerUpdateInput, SessionPlayerUncheckedUpdateInput>
  }

  /**
   * SessionPlayer delete
   */
  export type SessionPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
    /**
     * Filter which SessionPlayer to delete.
     */
    where: SessionPlayerWhereUniqueInput
  }

  /**
   * SessionPlayer deleteMany
   */
  export type SessionPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionPlayers to delete
     */
    where?: SessionPlayerWhereInput
    /**
     * Limit how many SessionPlayers to delete.
     */
    limit?: number
  }

  /**
   * SessionPlayer without action
   */
  export type SessionPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionPlayer
     */
    select?: SessionPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionPlayer
     */
    omit?: SessionPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionPlayerInclude<ExtArgs> | null
  }


  /**
   * Model QueueEntry
   */

  export type AggregateQueueEntry = {
    _count: QueueEntryCountAggregateOutputType | null
    _avg: QueueEntryAvgAggregateOutputType | null
    _sum: QueueEntrySumAggregateOutputType | null
    _min: QueueEntryMinAggregateOutputType | null
    _max: QueueEntryMaxAggregateOutputType | null
  }

  export type QueueEntryAvgAggregateOutputType = {
    position: number | null
  }

  export type QueueEntrySumAggregateOutputType = {
    position: number | null
  }

  export type QueueEntryMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.QueueType | null
    status: $Enums.QueueStatus | null
    position: number | null
    manualOrder: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueueEntryMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    type: $Enums.QueueType | null
    status: $Enums.QueueStatus | null
    position: number | null
    manualOrder: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QueueEntryCountAggregateOutputType = {
    id: number
    sessionId: number
    type: number
    status: number
    position: number
    manualOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QueueEntryAvgAggregateInputType = {
    position?: true
  }

  export type QueueEntrySumAggregateInputType = {
    position?: true
  }

  export type QueueEntryMinAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    status?: true
    position?: true
    manualOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueueEntryMaxAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    status?: true
    position?: true
    manualOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QueueEntryCountAggregateInputType = {
    id?: true
    sessionId?: true
    type?: true
    status?: true
    position?: true
    manualOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QueueEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueEntry to aggregate.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueEntries
    **/
    _count?: true | QueueEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QueueEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QueueEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueEntryMaxAggregateInputType
  }

  export type GetQueueEntryAggregateType<T extends QueueEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueEntry[P]>
      : GetScalarType<T[P], AggregateQueueEntry[P]>
  }




  export type QueueEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryWhereInput
    orderBy?: QueueEntryOrderByWithAggregationInput | QueueEntryOrderByWithAggregationInput[]
    by: QueueEntryScalarFieldEnum[] | QueueEntryScalarFieldEnum
    having?: QueueEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueEntryCountAggregateInputType | true
    _avg?: QueueEntryAvgAggregateInputType
    _sum?: QueueEntrySumAggregateInputType
    _min?: QueueEntryMinAggregateInputType
    _max?: QueueEntryMaxAggregateInputType
  }

  export type QueueEntryGroupByOutputType = {
    id: string
    sessionId: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder: boolean
    createdAt: Date
    updatedAt: Date
    _count: QueueEntryCountAggregateOutputType | null
    _avg: QueueEntryAvgAggregateOutputType | null
    _sum: QueueEntrySumAggregateOutputType | null
    _min: QueueEntryMinAggregateOutputType | null
    _max: QueueEntryMaxAggregateOutputType | null
  }

  type GetQueueEntryGroupByPayload<T extends QueueEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueEntryGroupByOutputType[P]>
            : GetScalarType<T[P], QueueEntryGroupByOutputType[P]>
        }
      >
    >


  export type QueueEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    status?: boolean
    position?: boolean
    manualOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    players?: boolean | QueueEntry$playersArgs<ExtArgs>
    _count?: boolean | QueueEntryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntry"]>

  export type QueueEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    status?: boolean
    position?: boolean
    manualOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntry"]>

  export type QueueEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    type?: boolean
    status?: boolean
    position?: boolean
    manualOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntry"]>

  export type QueueEntrySelectScalar = {
    id?: boolean
    sessionId?: boolean
    type?: boolean
    status?: boolean
    position?: boolean
    manualOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QueueEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "type" | "status" | "position" | "manualOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["queueEntry"]>
  export type QueueEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    players?: boolean | QueueEntry$playersArgs<ExtArgs>
    _count?: boolean | QueueEntryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QueueEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type QueueEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $QueueEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueEntry"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      players: Prisma.$QueueEntryPlayerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      type: $Enums.QueueType
      status: $Enums.QueueStatus
      position: number
      manualOrder: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["queueEntry"]>
    composites: {}
  }

  type QueueEntryGetPayload<S extends boolean | null | undefined | QueueEntryDefaultArgs> = $Result.GetResult<Prisma.$QueueEntryPayload, S>

  type QueueEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueEntryCountAggregateInputType | true
    }

  export interface QueueEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueEntry'], meta: { name: 'QueueEntry' } }
    /**
     * Find zero or one QueueEntry that matches the filter.
     * @param {QueueEntryFindUniqueArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueEntryFindUniqueArgs>(args: SelectSubset<T, QueueEntryFindUniqueArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueueEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueEntryFindUniqueOrThrowArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryFindFirstArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueEntryFindFirstArgs>(args?: SelectSubset<T, QueueEntryFindFirstArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryFindFirstOrThrowArgs} args - Arguments to find a QueueEntry
     * @example
     * // Get one QueueEntry
     * const queueEntry = await prisma.queueEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueueEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueEntries
     * const queueEntries = await prisma.queueEntry.findMany()
     * 
     * // Get first 10 QueueEntries
     * const queueEntries = await prisma.queueEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const queueEntryWithIdOnly = await prisma.queueEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QueueEntryFindManyArgs>(args?: SelectSubset<T, QueueEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueueEntry.
     * @param {QueueEntryCreateArgs} args - Arguments to create a QueueEntry.
     * @example
     * // Create one QueueEntry
     * const QueueEntry = await prisma.queueEntry.create({
     *   data: {
     *     // ... data to create a QueueEntry
     *   }
     * })
     * 
     */
    create<T extends QueueEntryCreateArgs>(args: SelectSubset<T, QueueEntryCreateArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueueEntries.
     * @param {QueueEntryCreateManyArgs} args - Arguments to create many QueueEntries.
     * @example
     * // Create many QueueEntries
     * const queueEntry = await prisma.queueEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueEntryCreateManyArgs>(args?: SelectSubset<T, QueueEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueueEntries and returns the data saved in the database.
     * @param {QueueEntryCreateManyAndReturnArgs} args - Arguments to create many QueueEntries.
     * @example
     * // Create many QueueEntries
     * const queueEntry = await prisma.queueEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueueEntries and only return the `id`
     * const queueEntryWithIdOnly = await prisma.queueEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueueEntry.
     * @param {QueueEntryDeleteArgs} args - Arguments to delete one QueueEntry.
     * @example
     * // Delete one QueueEntry
     * const QueueEntry = await prisma.queueEntry.delete({
     *   where: {
     *     // ... filter to delete one QueueEntry
     *   }
     * })
     * 
     */
    delete<T extends QueueEntryDeleteArgs>(args: SelectSubset<T, QueueEntryDeleteArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueueEntry.
     * @param {QueueEntryUpdateArgs} args - Arguments to update one QueueEntry.
     * @example
     * // Update one QueueEntry
     * const queueEntry = await prisma.queueEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueEntryUpdateArgs>(args: SelectSubset<T, QueueEntryUpdateArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueueEntries.
     * @param {QueueEntryDeleteManyArgs} args - Arguments to filter QueueEntries to delete.
     * @example
     * // Delete a few QueueEntries
     * const { count } = await prisma.queueEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueEntryDeleteManyArgs>(args?: SelectSubset<T, QueueEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueEntries
     * const queueEntry = await prisma.queueEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueEntryUpdateManyArgs>(args: SelectSubset<T, QueueEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueEntries and returns the data updated in the database.
     * @param {QueueEntryUpdateManyAndReturnArgs} args - Arguments to update many QueueEntries.
     * @example
     * // Update many QueueEntries
     * const queueEntry = await prisma.queueEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueueEntries and only return the `id`
     * const queueEntryWithIdOnly = await prisma.queueEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueueEntry.
     * @param {QueueEntryUpsertArgs} args - Arguments to update or create a QueueEntry.
     * @example
     * // Update or create a QueueEntry
     * const queueEntry = await prisma.queueEntry.upsert({
     *   create: {
     *     // ... data to create a QueueEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueEntry we want to update
     *   }
     * })
     */
    upsert<T extends QueueEntryUpsertArgs>(args: SelectSubset<T, QueueEntryUpsertArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueueEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryCountArgs} args - Arguments to filter QueueEntries to count.
     * @example
     * // Count the number of QueueEntries
     * const count = await prisma.queueEntry.count({
     *   where: {
     *     // ... the filter for the QueueEntries we want to count
     *   }
     * })
    **/
    count<T extends QueueEntryCountArgs>(
      args?: Subset<T, QueueEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueEntryAggregateArgs>(args: Subset<T, QueueEntryAggregateArgs>): Prisma.PrismaPromise<GetQueueEntryAggregateType<T>>

    /**
     * Group by QueueEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueEntryGroupByArgs['orderBy'] }
        : { orderBy?: QueueEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueEntry model
   */
  readonly fields: QueueEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    players<T extends QueueEntry$playersArgs<ExtArgs> = {}>(args?: Subset<T, QueueEntry$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueEntry model
   */
  interface QueueEntryFieldRefs {
    readonly id: FieldRef<"QueueEntry", 'String'>
    readonly sessionId: FieldRef<"QueueEntry", 'String'>
    readonly type: FieldRef<"QueueEntry", 'QueueType'>
    readonly status: FieldRef<"QueueEntry", 'QueueStatus'>
    readonly position: FieldRef<"QueueEntry", 'Int'>
    readonly manualOrder: FieldRef<"QueueEntry", 'Boolean'>
    readonly createdAt: FieldRef<"QueueEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"QueueEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QueueEntry findUnique
   */
  export type QueueEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry findUniqueOrThrow
   */
  export type QueueEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry findFirst
   */
  export type QueueEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueEntries.
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueEntries.
     */
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * QueueEntry findFirstOrThrow
   */
  export type QueueEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntry to fetch.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueEntries.
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueEntries.
     */
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * QueueEntry findMany
   */
  export type QueueEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntries to fetch.
     */
    where?: QueueEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntries to fetch.
     */
    orderBy?: QueueEntryOrderByWithRelationInput | QueueEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueEntries.
     */
    cursor?: QueueEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntries.
     */
    skip?: number
    distinct?: QueueEntryScalarFieldEnum | QueueEntryScalarFieldEnum[]
  }

  /**
   * QueueEntry create
   */
  export type QueueEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a QueueEntry.
     */
    data: XOR<QueueEntryCreateInput, QueueEntryUncheckedCreateInput>
  }

  /**
   * QueueEntry createMany
   */
  export type QueueEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueEntries.
     */
    data: QueueEntryCreateManyInput | QueueEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueEntry createManyAndReturn
   */
  export type QueueEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * The data used to create many QueueEntries.
     */
    data: QueueEntryCreateManyInput | QueueEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueueEntry update
   */
  export type QueueEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a QueueEntry.
     */
    data: XOR<QueueEntryUpdateInput, QueueEntryUncheckedUpdateInput>
    /**
     * Choose, which QueueEntry to update.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry updateMany
   */
  export type QueueEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueEntries.
     */
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyInput>
    /**
     * Filter which QueueEntries to update
     */
    where?: QueueEntryWhereInput
    /**
     * Limit how many QueueEntries to update.
     */
    limit?: number
  }

  /**
   * QueueEntry updateManyAndReturn
   */
  export type QueueEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * The data used to update QueueEntries.
     */
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyInput>
    /**
     * Filter which QueueEntries to update
     */
    where?: QueueEntryWhereInput
    /**
     * Limit how many QueueEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueueEntry upsert
   */
  export type QueueEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the QueueEntry to update in case it exists.
     */
    where: QueueEntryWhereUniqueInput
    /**
     * In case the QueueEntry found by the `where` argument doesn't exist, create a new QueueEntry with this data.
     */
    create: XOR<QueueEntryCreateInput, QueueEntryUncheckedCreateInput>
    /**
     * In case the QueueEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueEntryUpdateInput, QueueEntryUncheckedUpdateInput>
  }

  /**
   * QueueEntry delete
   */
  export type QueueEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
    /**
     * Filter which QueueEntry to delete.
     */
    where: QueueEntryWhereUniqueInput
  }

  /**
   * QueueEntry deleteMany
   */
  export type QueueEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueEntries to delete
     */
    where?: QueueEntryWhereInput
    /**
     * Limit how many QueueEntries to delete.
     */
    limit?: number
  }

  /**
   * QueueEntry.players
   */
  export type QueueEntry$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    where?: QueueEntryPlayerWhereInput
    orderBy?: QueueEntryPlayerOrderByWithRelationInput | QueueEntryPlayerOrderByWithRelationInput[]
    cursor?: QueueEntryPlayerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QueueEntryPlayerScalarFieldEnum | QueueEntryPlayerScalarFieldEnum[]
  }

  /**
   * QueueEntry without action
   */
  export type QueueEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntry
     */
    select?: QueueEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntry
     */
    omit?: QueueEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryInclude<ExtArgs> | null
  }


  /**
   * Model QueueEntryPlayer
   */

  export type AggregateQueueEntryPlayer = {
    _count: QueueEntryPlayerCountAggregateOutputType | null
    _min: QueueEntryPlayerMinAggregateOutputType | null
    _max: QueueEntryPlayerMaxAggregateOutputType | null
  }

  export type QueueEntryPlayerMinAggregateOutputType = {
    entryId: string | null
    playerId: string | null
  }

  export type QueueEntryPlayerMaxAggregateOutputType = {
    entryId: string | null
    playerId: string | null
  }

  export type QueueEntryPlayerCountAggregateOutputType = {
    entryId: number
    playerId: number
    _all: number
  }


  export type QueueEntryPlayerMinAggregateInputType = {
    entryId?: true
    playerId?: true
  }

  export type QueueEntryPlayerMaxAggregateInputType = {
    entryId?: true
    playerId?: true
  }

  export type QueueEntryPlayerCountAggregateInputType = {
    entryId?: true
    playerId?: true
    _all?: true
  }

  export type QueueEntryPlayerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueEntryPlayer to aggregate.
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntryPlayers to fetch.
     */
    orderBy?: QueueEntryPlayerOrderByWithRelationInput | QueueEntryPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QueueEntryPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntryPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntryPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QueueEntryPlayers
    **/
    _count?: true | QueueEntryPlayerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QueueEntryPlayerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QueueEntryPlayerMaxAggregateInputType
  }

  export type GetQueueEntryPlayerAggregateType<T extends QueueEntryPlayerAggregateArgs> = {
        [P in keyof T & keyof AggregateQueueEntryPlayer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQueueEntryPlayer[P]>
      : GetScalarType<T[P], AggregateQueueEntryPlayer[P]>
  }




  export type QueueEntryPlayerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QueueEntryPlayerWhereInput
    orderBy?: QueueEntryPlayerOrderByWithAggregationInput | QueueEntryPlayerOrderByWithAggregationInput[]
    by: QueueEntryPlayerScalarFieldEnum[] | QueueEntryPlayerScalarFieldEnum
    having?: QueueEntryPlayerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QueueEntryPlayerCountAggregateInputType | true
    _min?: QueueEntryPlayerMinAggregateInputType
    _max?: QueueEntryPlayerMaxAggregateInputType
  }

  export type QueueEntryPlayerGroupByOutputType = {
    entryId: string
    playerId: string
    _count: QueueEntryPlayerCountAggregateOutputType | null
    _min: QueueEntryPlayerMinAggregateOutputType | null
    _max: QueueEntryPlayerMaxAggregateOutputType | null
  }

  type GetQueueEntryPlayerGroupByPayload<T extends QueueEntryPlayerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QueueEntryPlayerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QueueEntryPlayerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QueueEntryPlayerGroupByOutputType[P]>
            : GetScalarType<T[P], QueueEntryPlayerGroupByOutputType[P]>
        }
      >
    >


  export type QueueEntryPlayerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entryId?: boolean
    playerId?: boolean
    entry?: boolean | QueueEntryDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntryPlayer"]>

  export type QueueEntryPlayerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entryId?: boolean
    playerId?: boolean
    entry?: boolean | QueueEntryDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntryPlayer"]>

  export type QueueEntryPlayerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    entryId?: boolean
    playerId?: boolean
    entry?: boolean | QueueEntryDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["queueEntryPlayer"]>

  export type QueueEntryPlayerSelectScalar = {
    entryId?: boolean
    playerId?: boolean
  }

  export type QueueEntryPlayerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"entryId" | "playerId", ExtArgs["result"]["queueEntryPlayer"]>
  export type QueueEntryPlayerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | QueueEntryDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type QueueEntryPlayerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | QueueEntryDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type QueueEntryPlayerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entry?: boolean | QueueEntryDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $QueueEntryPlayerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QueueEntryPlayer"
    objects: {
      entry: Prisma.$QueueEntryPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      entryId: string
      playerId: string
    }, ExtArgs["result"]["queueEntryPlayer"]>
    composites: {}
  }

  type QueueEntryPlayerGetPayload<S extends boolean | null | undefined | QueueEntryPlayerDefaultArgs> = $Result.GetResult<Prisma.$QueueEntryPlayerPayload, S>

  type QueueEntryPlayerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QueueEntryPlayerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QueueEntryPlayerCountAggregateInputType | true
    }

  export interface QueueEntryPlayerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QueueEntryPlayer'], meta: { name: 'QueueEntryPlayer' } }
    /**
     * Find zero or one QueueEntryPlayer that matches the filter.
     * @param {QueueEntryPlayerFindUniqueArgs} args - Arguments to find a QueueEntryPlayer
     * @example
     * // Get one QueueEntryPlayer
     * const queueEntryPlayer = await prisma.queueEntryPlayer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QueueEntryPlayerFindUniqueArgs>(args: SelectSubset<T, QueueEntryPlayerFindUniqueArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QueueEntryPlayer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QueueEntryPlayerFindUniqueOrThrowArgs} args - Arguments to find a QueueEntryPlayer
     * @example
     * // Get one QueueEntryPlayer
     * const queueEntryPlayer = await prisma.queueEntryPlayer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QueueEntryPlayerFindUniqueOrThrowArgs>(args: SelectSubset<T, QueueEntryPlayerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueEntryPlayer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerFindFirstArgs} args - Arguments to find a QueueEntryPlayer
     * @example
     * // Get one QueueEntryPlayer
     * const queueEntryPlayer = await prisma.queueEntryPlayer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QueueEntryPlayerFindFirstArgs>(args?: SelectSubset<T, QueueEntryPlayerFindFirstArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QueueEntryPlayer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerFindFirstOrThrowArgs} args - Arguments to find a QueueEntryPlayer
     * @example
     * // Get one QueueEntryPlayer
     * const queueEntryPlayer = await prisma.queueEntryPlayer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QueueEntryPlayerFindFirstOrThrowArgs>(args?: SelectSubset<T, QueueEntryPlayerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QueueEntryPlayers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QueueEntryPlayers
     * const queueEntryPlayers = await prisma.queueEntryPlayer.findMany()
     * 
     * // Get first 10 QueueEntryPlayers
     * const queueEntryPlayers = await prisma.queueEntryPlayer.findMany({ take: 10 })
     * 
     * // Only select the `entryId`
     * const queueEntryPlayerWithEntryIdOnly = await prisma.queueEntryPlayer.findMany({ select: { entryId: true } })
     * 
     */
    findMany<T extends QueueEntryPlayerFindManyArgs>(args?: SelectSubset<T, QueueEntryPlayerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QueueEntryPlayer.
     * @param {QueueEntryPlayerCreateArgs} args - Arguments to create a QueueEntryPlayer.
     * @example
     * // Create one QueueEntryPlayer
     * const QueueEntryPlayer = await prisma.queueEntryPlayer.create({
     *   data: {
     *     // ... data to create a QueueEntryPlayer
     *   }
     * })
     * 
     */
    create<T extends QueueEntryPlayerCreateArgs>(args: SelectSubset<T, QueueEntryPlayerCreateArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QueueEntryPlayers.
     * @param {QueueEntryPlayerCreateManyArgs} args - Arguments to create many QueueEntryPlayers.
     * @example
     * // Create many QueueEntryPlayers
     * const queueEntryPlayer = await prisma.queueEntryPlayer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QueueEntryPlayerCreateManyArgs>(args?: SelectSubset<T, QueueEntryPlayerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QueueEntryPlayers and returns the data saved in the database.
     * @param {QueueEntryPlayerCreateManyAndReturnArgs} args - Arguments to create many QueueEntryPlayers.
     * @example
     * // Create many QueueEntryPlayers
     * const queueEntryPlayer = await prisma.queueEntryPlayer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QueueEntryPlayers and only return the `entryId`
     * const queueEntryPlayerWithEntryIdOnly = await prisma.queueEntryPlayer.createManyAndReturn({
     *   select: { entryId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QueueEntryPlayerCreateManyAndReturnArgs>(args?: SelectSubset<T, QueueEntryPlayerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QueueEntryPlayer.
     * @param {QueueEntryPlayerDeleteArgs} args - Arguments to delete one QueueEntryPlayer.
     * @example
     * // Delete one QueueEntryPlayer
     * const QueueEntryPlayer = await prisma.queueEntryPlayer.delete({
     *   where: {
     *     // ... filter to delete one QueueEntryPlayer
     *   }
     * })
     * 
     */
    delete<T extends QueueEntryPlayerDeleteArgs>(args: SelectSubset<T, QueueEntryPlayerDeleteArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QueueEntryPlayer.
     * @param {QueueEntryPlayerUpdateArgs} args - Arguments to update one QueueEntryPlayer.
     * @example
     * // Update one QueueEntryPlayer
     * const queueEntryPlayer = await prisma.queueEntryPlayer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QueueEntryPlayerUpdateArgs>(args: SelectSubset<T, QueueEntryPlayerUpdateArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QueueEntryPlayers.
     * @param {QueueEntryPlayerDeleteManyArgs} args - Arguments to filter QueueEntryPlayers to delete.
     * @example
     * // Delete a few QueueEntryPlayers
     * const { count } = await prisma.queueEntryPlayer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QueueEntryPlayerDeleteManyArgs>(args?: SelectSubset<T, QueueEntryPlayerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueEntryPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QueueEntryPlayers
     * const queueEntryPlayer = await prisma.queueEntryPlayer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QueueEntryPlayerUpdateManyArgs>(args: SelectSubset<T, QueueEntryPlayerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QueueEntryPlayers and returns the data updated in the database.
     * @param {QueueEntryPlayerUpdateManyAndReturnArgs} args - Arguments to update many QueueEntryPlayers.
     * @example
     * // Update many QueueEntryPlayers
     * const queueEntryPlayer = await prisma.queueEntryPlayer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QueueEntryPlayers and only return the `entryId`
     * const queueEntryPlayerWithEntryIdOnly = await prisma.queueEntryPlayer.updateManyAndReturn({
     *   select: { entryId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QueueEntryPlayerUpdateManyAndReturnArgs>(args: SelectSubset<T, QueueEntryPlayerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QueueEntryPlayer.
     * @param {QueueEntryPlayerUpsertArgs} args - Arguments to update or create a QueueEntryPlayer.
     * @example
     * // Update or create a QueueEntryPlayer
     * const queueEntryPlayer = await prisma.queueEntryPlayer.upsert({
     *   create: {
     *     // ... data to create a QueueEntryPlayer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QueueEntryPlayer we want to update
     *   }
     * })
     */
    upsert<T extends QueueEntryPlayerUpsertArgs>(args: SelectSubset<T, QueueEntryPlayerUpsertArgs<ExtArgs>>): Prisma__QueueEntryPlayerClient<$Result.GetResult<Prisma.$QueueEntryPlayerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QueueEntryPlayers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerCountArgs} args - Arguments to filter QueueEntryPlayers to count.
     * @example
     * // Count the number of QueueEntryPlayers
     * const count = await prisma.queueEntryPlayer.count({
     *   where: {
     *     // ... the filter for the QueueEntryPlayers we want to count
     *   }
     * })
    **/
    count<T extends QueueEntryPlayerCountArgs>(
      args?: Subset<T, QueueEntryPlayerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QueueEntryPlayerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QueueEntryPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QueueEntryPlayerAggregateArgs>(args: Subset<T, QueueEntryPlayerAggregateArgs>): Prisma.PrismaPromise<GetQueueEntryPlayerAggregateType<T>>

    /**
     * Group by QueueEntryPlayer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QueueEntryPlayerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QueueEntryPlayerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QueueEntryPlayerGroupByArgs['orderBy'] }
        : { orderBy?: QueueEntryPlayerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QueueEntryPlayerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQueueEntryPlayerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QueueEntryPlayer model
   */
  readonly fields: QueueEntryPlayerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QueueEntryPlayer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QueueEntryPlayerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entry<T extends QueueEntryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QueueEntryDefaultArgs<ExtArgs>>): Prisma__QueueEntryClient<$Result.GetResult<Prisma.$QueueEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QueueEntryPlayer model
   */
  interface QueueEntryPlayerFieldRefs {
    readonly entryId: FieldRef<"QueueEntryPlayer", 'String'>
    readonly playerId: FieldRef<"QueueEntryPlayer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QueueEntryPlayer findUnique
   */
  export type QueueEntryPlayerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntryPlayer to fetch.
     */
    where: QueueEntryPlayerWhereUniqueInput
  }

  /**
   * QueueEntryPlayer findUniqueOrThrow
   */
  export type QueueEntryPlayerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntryPlayer to fetch.
     */
    where: QueueEntryPlayerWhereUniqueInput
  }

  /**
   * QueueEntryPlayer findFirst
   */
  export type QueueEntryPlayerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntryPlayer to fetch.
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntryPlayers to fetch.
     */
    orderBy?: QueueEntryPlayerOrderByWithRelationInput | QueueEntryPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueEntryPlayers.
     */
    cursor?: QueueEntryPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntryPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntryPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueEntryPlayers.
     */
    distinct?: QueueEntryPlayerScalarFieldEnum | QueueEntryPlayerScalarFieldEnum[]
  }

  /**
   * QueueEntryPlayer findFirstOrThrow
   */
  export type QueueEntryPlayerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntryPlayer to fetch.
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntryPlayers to fetch.
     */
    orderBy?: QueueEntryPlayerOrderByWithRelationInput | QueueEntryPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QueueEntryPlayers.
     */
    cursor?: QueueEntryPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntryPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntryPlayers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QueueEntryPlayers.
     */
    distinct?: QueueEntryPlayerScalarFieldEnum | QueueEntryPlayerScalarFieldEnum[]
  }

  /**
   * QueueEntryPlayer findMany
   */
  export type QueueEntryPlayerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * Filter, which QueueEntryPlayers to fetch.
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QueueEntryPlayers to fetch.
     */
    orderBy?: QueueEntryPlayerOrderByWithRelationInput | QueueEntryPlayerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QueueEntryPlayers.
     */
    cursor?: QueueEntryPlayerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QueueEntryPlayers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QueueEntryPlayers.
     */
    skip?: number
    distinct?: QueueEntryPlayerScalarFieldEnum | QueueEntryPlayerScalarFieldEnum[]
  }

  /**
   * QueueEntryPlayer create
   */
  export type QueueEntryPlayerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * The data needed to create a QueueEntryPlayer.
     */
    data: XOR<QueueEntryPlayerCreateInput, QueueEntryPlayerUncheckedCreateInput>
  }

  /**
   * QueueEntryPlayer createMany
   */
  export type QueueEntryPlayerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QueueEntryPlayers.
     */
    data: QueueEntryPlayerCreateManyInput | QueueEntryPlayerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QueueEntryPlayer createManyAndReturn
   */
  export type QueueEntryPlayerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * The data used to create many QueueEntryPlayers.
     */
    data: QueueEntryPlayerCreateManyInput | QueueEntryPlayerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueueEntryPlayer update
   */
  export type QueueEntryPlayerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * The data needed to update a QueueEntryPlayer.
     */
    data: XOR<QueueEntryPlayerUpdateInput, QueueEntryPlayerUncheckedUpdateInput>
    /**
     * Choose, which QueueEntryPlayer to update.
     */
    where: QueueEntryPlayerWhereUniqueInput
  }

  /**
   * QueueEntryPlayer updateMany
   */
  export type QueueEntryPlayerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QueueEntryPlayers.
     */
    data: XOR<QueueEntryPlayerUpdateManyMutationInput, QueueEntryPlayerUncheckedUpdateManyInput>
    /**
     * Filter which QueueEntryPlayers to update
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * Limit how many QueueEntryPlayers to update.
     */
    limit?: number
  }

  /**
   * QueueEntryPlayer updateManyAndReturn
   */
  export type QueueEntryPlayerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * The data used to update QueueEntryPlayers.
     */
    data: XOR<QueueEntryPlayerUpdateManyMutationInput, QueueEntryPlayerUncheckedUpdateManyInput>
    /**
     * Filter which QueueEntryPlayers to update
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * Limit how many QueueEntryPlayers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QueueEntryPlayer upsert
   */
  export type QueueEntryPlayerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * The filter to search for the QueueEntryPlayer to update in case it exists.
     */
    where: QueueEntryPlayerWhereUniqueInput
    /**
     * In case the QueueEntryPlayer found by the `where` argument doesn't exist, create a new QueueEntryPlayer with this data.
     */
    create: XOR<QueueEntryPlayerCreateInput, QueueEntryPlayerUncheckedCreateInput>
    /**
     * In case the QueueEntryPlayer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QueueEntryPlayerUpdateInput, QueueEntryPlayerUncheckedUpdateInput>
  }

  /**
   * QueueEntryPlayer delete
   */
  export type QueueEntryPlayerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
    /**
     * Filter which QueueEntryPlayer to delete.
     */
    where: QueueEntryPlayerWhereUniqueInput
  }

  /**
   * QueueEntryPlayer deleteMany
   */
  export type QueueEntryPlayerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QueueEntryPlayers to delete
     */
    where?: QueueEntryPlayerWhereInput
    /**
     * Limit how many QueueEntryPlayers to delete.
     */
    limit?: number
  }

  /**
   * QueueEntryPlayer without action
   */
  export type QueueEntryPlayerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QueueEntryPlayer
     */
    select?: QueueEntryPlayerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QueueEntryPlayer
     */
    omit?: QueueEntryPlayerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QueueEntryPlayerInclude<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    winnerTeam: number | null
  }

  export type MatchSumAggregateOutputType = {
    winnerTeam: number | null
  }

  export type MatchMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    courtSessionId: string | null
    status: $Enums.MatchStatus | null
    matchType: $Enums.MatchType | null
    startedAt: Date | null
    endedAt: Date | null
    winnerTeam: number | null
    createdAt: Date | null
  }

  export type MatchMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    courtSessionId: string | null
    status: $Enums.MatchStatus | null
    matchType: $Enums.MatchType | null
    startedAt: Date | null
    endedAt: Date | null
    winnerTeam: number | null
    createdAt: Date | null
  }

  export type MatchCountAggregateOutputType = {
    id: number
    sessionId: number
    courtSessionId: number
    status: number
    matchType: number
    startedAt: number
    endedAt: number
    scoreJson: number
    winnerTeam: number
    createdAt: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    winnerTeam?: true
  }

  export type MatchSumAggregateInputType = {
    winnerTeam?: true
  }

  export type MatchMinAggregateInputType = {
    id?: true
    sessionId?: true
    courtSessionId?: true
    status?: true
    matchType?: true
    startedAt?: true
    endedAt?: true
    winnerTeam?: true
    createdAt?: true
  }

  export type MatchMaxAggregateInputType = {
    id?: true
    sessionId?: true
    courtSessionId?: true
    status?: true
    matchType?: true
    startedAt?: true
    endedAt?: true
    winnerTeam?: true
    createdAt?: true
  }

  export type MatchCountAggregateInputType = {
    id?: true
    sessionId?: true
    courtSessionId?: true
    status?: true
    matchType?: true
    startedAt?: true
    endedAt?: true
    scoreJson?: true
    winnerTeam?: true
    createdAt?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    id: string
    sessionId: string
    courtSessionId: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt: Date | null
    endedAt: Date | null
    scoreJson: JsonValue | null
    winnerTeam: number | null
    createdAt: Date
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    courtSessionId?: boolean
    status?: boolean
    matchType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scoreJson?: boolean
    winnerTeam?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    participants?: boolean | Match$participantsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    courtSessionId?: boolean
    status?: boolean
    matchType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scoreJson?: boolean
    winnerTeam?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    courtSessionId?: boolean
    status?: boolean
    matchType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scoreJson?: boolean
    winnerTeam?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    id?: boolean
    sessionId?: boolean
    courtSessionId?: boolean
    status?: boolean
    matchType?: boolean
    startedAt?: boolean
    endedAt?: boolean
    scoreJson?: boolean
    winnerTeam?: boolean
    createdAt?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "courtSessionId" | "status" | "matchType" | "startedAt" | "endedAt" | "scoreJson" | "winnerTeam" | "createdAt", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    participants?: boolean | Match$participantsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type MatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      participants: Prisma.$MatchParticipantPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      courtSessionId: string | null
      status: $Enums.MatchStatus
      matchType: $Enums.MatchType
      startedAt: Date | null
      endedAt: Date | null
      scoreJson: Prisma.JsonValue | null
      winnerTeam: number | null
      createdAt: Date
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const matchWithIdOnly = await prisma.match.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches and returns the data updated in the database.
     * @param {MatchUpdateManyAndReturnArgs} args - Arguments to update many Matches.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Matches and only return the `id`
     * const matchWithIdOnly = await prisma.match.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends Match$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Match$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly id: FieldRef<"Match", 'String'>
    readonly sessionId: FieldRef<"Match", 'String'>
    readonly courtSessionId: FieldRef<"Match", 'String'>
    readonly status: FieldRef<"Match", 'MatchStatus'>
    readonly matchType: FieldRef<"Match", 'MatchType'>
    readonly startedAt: FieldRef<"Match", 'DateTime'>
    readonly endedAt: FieldRef<"Match", 'DateTime'>
    readonly scoreJson: FieldRef<"Match", 'Json'>
    readonly winnerTeam: FieldRef<"Match", 'Int'>
    readonly createdAt: FieldRef<"Match", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match updateManyAndReturn
   */
  export type MatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match.participants
   */
  export type Match$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    where?: MatchParticipantWhereInput
    orderBy?: MatchParticipantOrderByWithRelationInput | MatchParticipantOrderByWithRelationInput[]
    cursor?: MatchParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchParticipantScalarFieldEnum | MatchParticipantScalarFieldEnum[]
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model MatchParticipant
   */

  export type AggregateMatchParticipant = {
    _count: MatchParticipantCountAggregateOutputType | null
    _avg: MatchParticipantAvgAggregateOutputType | null
    _sum: MatchParticipantSumAggregateOutputType | null
    _min: MatchParticipantMinAggregateOutputType | null
    _max: MatchParticipantMaxAggregateOutputType | null
  }

  export type MatchParticipantAvgAggregateOutputType = {
    teamNumber: number | null
  }

  export type MatchParticipantSumAggregateOutputType = {
    teamNumber: number | null
  }

  export type MatchParticipantMinAggregateOutputType = {
    matchId: string | null
    playerId: string | null
    teamNumber: number | null
  }

  export type MatchParticipantMaxAggregateOutputType = {
    matchId: string | null
    playerId: string | null
    teamNumber: number | null
  }

  export type MatchParticipantCountAggregateOutputType = {
    matchId: number
    playerId: number
    teamNumber: number
    _all: number
  }


  export type MatchParticipantAvgAggregateInputType = {
    teamNumber?: true
  }

  export type MatchParticipantSumAggregateInputType = {
    teamNumber?: true
  }

  export type MatchParticipantMinAggregateInputType = {
    matchId?: true
    playerId?: true
    teamNumber?: true
  }

  export type MatchParticipantMaxAggregateInputType = {
    matchId?: true
    playerId?: true
    teamNumber?: true
  }

  export type MatchParticipantCountAggregateInputType = {
    matchId?: true
    playerId?: true
    teamNumber?: true
    _all?: true
  }

  export type MatchParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchParticipant to aggregate.
     */
    where?: MatchParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipants to fetch.
     */
    orderBy?: MatchParticipantOrderByWithRelationInput | MatchParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MatchParticipants
    **/
    _count?: true | MatchParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchParticipantMaxAggregateInputType
  }

  export type GetMatchParticipantAggregateType<T extends MatchParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateMatchParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatchParticipant[P]>
      : GetScalarType<T[P], AggregateMatchParticipant[P]>
  }




  export type MatchParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchParticipantWhereInput
    orderBy?: MatchParticipantOrderByWithAggregationInput | MatchParticipantOrderByWithAggregationInput[]
    by: MatchParticipantScalarFieldEnum[] | MatchParticipantScalarFieldEnum
    having?: MatchParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchParticipantCountAggregateInputType | true
    _avg?: MatchParticipantAvgAggregateInputType
    _sum?: MatchParticipantSumAggregateInputType
    _min?: MatchParticipantMinAggregateInputType
    _max?: MatchParticipantMaxAggregateInputType
  }

  export type MatchParticipantGroupByOutputType = {
    matchId: string
    playerId: string
    teamNumber: number
    _count: MatchParticipantCountAggregateOutputType | null
    _avg: MatchParticipantAvgAggregateOutputType | null
    _sum: MatchParticipantSumAggregateOutputType | null
    _min: MatchParticipantMinAggregateOutputType | null
    _max: MatchParticipantMaxAggregateOutputType | null
  }

  type GetMatchParticipantGroupByPayload<T extends MatchParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], MatchParticipantGroupByOutputType[P]>
        }
      >
    >


  export type MatchParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    matchId?: boolean
    playerId?: boolean
    teamNumber?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchParticipant"]>

  export type MatchParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    matchId?: boolean
    playerId?: boolean
    teamNumber?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchParticipant"]>

  export type MatchParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    matchId?: boolean
    playerId?: boolean
    teamNumber?: boolean
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["matchParticipant"]>

  export type MatchParticipantSelectScalar = {
    matchId?: boolean
    playerId?: boolean
    teamNumber?: boolean
  }

  export type MatchParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"matchId" | "playerId" | "teamNumber", ExtArgs["result"]["matchParticipant"]>
  export type MatchParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type MatchParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type MatchParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    match?: boolean | MatchDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $MatchParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MatchParticipant"
    objects: {
      match: Prisma.$MatchPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      matchId: string
      playerId: string
      teamNumber: number
    }, ExtArgs["result"]["matchParticipant"]>
    composites: {}
  }

  type MatchParticipantGetPayload<S extends boolean | null | undefined | MatchParticipantDefaultArgs> = $Result.GetResult<Prisma.$MatchParticipantPayload, S>

  type MatchParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchParticipantCountAggregateInputType | true
    }

  export interface MatchParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MatchParticipant'], meta: { name: 'MatchParticipant' } }
    /**
     * Find zero or one MatchParticipant that matches the filter.
     * @param {MatchParticipantFindUniqueArgs} args - Arguments to find a MatchParticipant
     * @example
     * // Get one MatchParticipant
     * const matchParticipant = await prisma.matchParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchParticipantFindUniqueArgs>(args: SelectSubset<T, MatchParticipantFindUniqueArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MatchParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchParticipantFindUniqueOrThrowArgs} args - Arguments to find a MatchParticipant
     * @example
     * // Get one MatchParticipant
     * const matchParticipant = await prisma.matchParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantFindFirstArgs} args - Arguments to find a MatchParticipant
     * @example
     * // Get one MatchParticipant
     * const matchParticipant = await prisma.matchParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchParticipantFindFirstArgs>(args?: SelectSubset<T, MatchParticipantFindFirstArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MatchParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantFindFirstOrThrowArgs} args - Arguments to find a MatchParticipant
     * @example
     * // Get one MatchParticipant
     * const matchParticipant = await prisma.matchParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MatchParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MatchParticipants
     * const matchParticipants = await prisma.matchParticipant.findMany()
     * 
     * // Get first 10 MatchParticipants
     * const matchParticipants = await prisma.matchParticipant.findMany({ take: 10 })
     * 
     * // Only select the `matchId`
     * const matchParticipantWithMatchIdOnly = await prisma.matchParticipant.findMany({ select: { matchId: true } })
     * 
     */
    findMany<T extends MatchParticipantFindManyArgs>(args?: SelectSubset<T, MatchParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MatchParticipant.
     * @param {MatchParticipantCreateArgs} args - Arguments to create a MatchParticipant.
     * @example
     * // Create one MatchParticipant
     * const MatchParticipant = await prisma.matchParticipant.create({
     *   data: {
     *     // ... data to create a MatchParticipant
     *   }
     * })
     * 
     */
    create<T extends MatchParticipantCreateArgs>(args: SelectSubset<T, MatchParticipantCreateArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MatchParticipants.
     * @param {MatchParticipantCreateManyArgs} args - Arguments to create many MatchParticipants.
     * @example
     * // Create many MatchParticipants
     * const matchParticipant = await prisma.matchParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchParticipantCreateManyArgs>(args?: SelectSubset<T, MatchParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MatchParticipants and returns the data saved in the database.
     * @param {MatchParticipantCreateManyAndReturnArgs} args - Arguments to create many MatchParticipants.
     * @example
     * // Create many MatchParticipants
     * const matchParticipant = await prisma.matchParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MatchParticipants and only return the `matchId`
     * const matchParticipantWithMatchIdOnly = await prisma.matchParticipant.createManyAndReturn({
     *   select: { matchId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MatchParticipant.
     * @param {MatchParticipantDeleteArgs} args - Arguments to delete one MatchParticipant.
     * @example
     * // Delete one MatchParticipant
     * const MatchParticipant = await prisma.matchParticipant.delete({
     *   where: {
     *     // ... filter to delete one MatchParticipant
     *   }
     * })
     * 
     */
    delete<T extends MatchParticipantDeleteArgs>(args: SelectSubset<T, MatchParticipantDeleteArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MatchParticipant.
     * @param {MatchParticipantUpdateArgs} args - Arguments to update one MatchParticipant.
     * @example
     * // Update one MatchParticipant
     * const matchParticipant = await prisma.matchParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchParticipantUpdateArgs>(args: SelectSubset<T, MatchParticipantUpdateArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MatchParticipants.
     * @param {MatchParticipantDeleteManyArgs} args - Arguments to filter MatchParticipants to delete.
     * @example
     * // Delete a few MatchParticipants
     * const { count } = await prisma.matchParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchParticipantDeleteManyArgs>(args?: SelectSubset<T, MatchParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MatchParticipants
     * const matchParticipant = await prisma.matchParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchParticipantUpdateManyArgs>(args: SelectSubset<T, MatchParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MatchParticipants and returns the data updated in the database.
     * @param {MatchParticipantUpdateManyAndReturnArgs} args - Arguments to update many MatchParticipants.
     * @example
     * // Update many MatchParticipants
     * const matchParticipant = await prisma.matchParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MatchParticipants and only return the `matchId`
     * const matchParticipantWithMatchIdOnly = await prisma.matchParticipant.updateManyAndReturn({
     *   select: { matchId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MatchParticipant.
     * @param {MatchParticipantUpsertArgs} args - Arguments to update or create a MatchParticipant.
     * @example
     * // Update or create a MatchParticipant
     * const matchParticipant = await prisma.matchParticipant.upsert({
     *   create: {
     *     // ... data to create a MatchParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MatchParticipant we want to update
     *   }
     * })
     */
    upsert<T extends MatchParticipantUpsertArgs>(args: SelectSubset<T, MatchParticipantUpsertArgs<ExtArgs>>): Prisma__MatchParticipantClient<$Result.GetResult<Prisma.$MatchParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MatchParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantCountArgs} args - Arguments to filter MatchParticipants to count.
     * @example
     * // Count the number of MatchParticipants
     * const count = await prisma.matchParticipant.count({
     *   where: {
     *     // ... the filter for the MatchParticipants we want to count
     *   }
     * })
    **/
    count<T extends MatchParticipantCountArgs>(
      args?: Subset<T, MatchParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MatchParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchParticipantAggregateArgs>(args: Subset<T, MatchParticipantAggregateArgs>): Prisma.PrismaPromise<GetMatchParticipantAggregateType<T>>

    /**
     * Group by MatchParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchParticipantGroupByArgs['orderBy'] }
        : { orderBy?: MatchParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MatchParticipant model
   */
  readonly fields: MatchParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MatchParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MatchParticipant model
   */
  interface MatchParticipantFieldRefs {
    readonly matchId: FieldRef<"MatchParticipant", 'String'>
    readonly playerId: FieldRef<"MatchParticipant", 'String'>
    readonly teamNumber: FieldRef<"MatchParticipant", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MatchParticipant findUnique
   */
  export type MatchParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipant to fetch.
     */
    where: MatchParticipantWhereUniqueInput
  }

  /**
   * MatchParticipant findUniqueOrThrow
   */
  export type MatchParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipant to fetch.
     */
    where: MatchParticipantWhereUniqueInput
  }

  /**
   * MatchParticipant findFirst
   */
  export type MatchParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipant to fetch.
     */
    where?: MatchParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipants to fetch.
     */
    orderBy?: MatchParticipantOrderByWithRelationInput | MatchParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchParticipants.
     */
    cursor?: MatchParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchParticipants.
     */
    distinct?: MatchParticipantScalarFieldEnum | MatchParticipantScalarFieldEnum[]
  }

  /**
   * MatchParticipant findFirstOrThrow
   */
  export type MatchParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipant to fetch.
     */
    where?: MatchParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipants to fetch.
     */
    orderBy?: MatchParticipantOrderByWithRelationInput | MatchParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MatchParticipants.
     */
    cursor?: MatchParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MatchParticipants.
     */
    distinct?: MatchParticipantScalarFieldEnum | MatchParticipantScalarFieldEnum[]
  }

  /**
   * MatchParticipant findMany
   */
  export type MatchParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * Filter, which MatchParticipants to fetch.
     */
    where?: MatchParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MatchParticipants to fetch.
     */
    orderBy?: MatchParticipantOrderByWithRelationInput | MatchParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MatchParticipants.
     */
    cursor?: MatchParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MatchParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MatchParticipants.
     */
    skip?: number
    distinct?: MatchParticipantScalarFieldEnum | MatchParticipantScalarFieldEnum[]
  }

  /**
   * MatchParticipant create
   */
  export type MatchParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a MatchParticipant.
     */
    data: XOR<MatchParticipantCreateInput, MatchParticipantUncheckedCreateInput>
  }

  /**
   * MatchParticipant createMany
   */
  export type MatchParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MatchParticipants.
     */
    data: MatchParticipantCreateManyInput | MatchParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MatchParticipant createManyAndReturn
   */
  export type MatchParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many MatchParticipants.
     */
    data: MatchParticipantCreateManyInput | MatchParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchParticipant update
   */
  export type MatchParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a MatchParticipant.
     */
    data: XOR<MatchParticipantUpdateInput, MatchParticipantUncheckedUpdateInput>
    /**
     * Choose, which MatchParticipant to update.
     */
    where: MatchParticipantWhereUniqueInput
  }

  /**
   * MatchParticipant updateMany
   */
  export type MatchParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MatchParticipants.
     */
    data: XOR<MatchParticipantUpdateManyMutationInput, MatchParticipantUncheckedUpdateManyInput>
    /**
     * Filter which MatchParticipants to update
     */
    where?: MatchParticipantWhereInput
    /**
     * Limit how many MatchParticipants to update.
     */
    limit?: number
  }

  /**
   * MatchParticipant updateManyAndReturn
   */
  export type MatchParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * The data used to update MatchParticipants.
     */
    data: XOR<MatchParticipantUpdateManyMutationInput, MatchParticipantUncheckedUpdateManyInput>
    /**
     * Filter which MatchParticipants to update
     */
    where?: MatchParticipantWhereInput
    /**
     * Limit how many MatchParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MatchParticipant upsert
   */
  export type MatchParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the MatchParticipant to update in case it exists.
     */
    where: MatchParticipantWhereUniqueInput
    /**
     * In case the MatchParticipant found by the `where` argument doesn't exist, create a new MatchParticipant with this data.
     */
    create: XOR<MatchParticipantCreateInput, MatchParticipantUncheckedCreateInput>
    /**
     * In case the MatchParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchParticipantUpdateInput, MatchParticipantUncheckedUpdateInput>
  }

  /**
   * MatchParticipant delete
   */
  export type MatchParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
    /**
     * Filter which MatchParticipant to delete.
     */
    where: MatchParticipantWhereUniqueInput
  }

  /**
   * MatchParticipant deleteMany
   */
  export type MatchParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MatchParticipants to delete
     */
    where?: MatchParticipantWhereInput
    /**
     * Limit how many MatchParticipants to delete.
     */
    limit?: number
  }

  /**
   * MatchParticipant without action
   */
  export type MatchParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchParticipant
     */
    select?: MatchParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MatchParticipant
     */
    omit?: MatchParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    playerId: string | null
    amount: Decimal | null
    method: string | null
    note: string | null
    createdAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    playerId: string | null
    amount: Decimal | null
    method: string | null
    note: string | null
    createdAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    sessionId: number
    playerId: number
    amount: number
    method: number
    note: number
    createdAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    sessionId?: true
    playerId?: true
    amount?: true
    method?: true
    note?: true
    createdAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    sessionId?: true
    playerId?: true
    amount?: true
    method?: true
    note?: true
    createdAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    sessionId?: true
    playerId?: true
    amount?: true
    method?: true
    note?: true
    createdAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    sessionId: string
    playerId: string
    amount: Decimal
    method: string
    note: string | null
    createdAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    amount?: boolean
    method?: boolean
    note?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    amount?: boolean
    method?: boolean
    note?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    amount?: boolean
    method?: boolean
    note?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    sessionId?: boolean
    playerId?: boolean
    amount?: boolean
    method?: boolean
    note?: boolean
    createdAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "playerId" | "amount" | "method" | "note" | "createdAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      playerId: string
      amount: Prisma.Decimal
      method: string
      note: string | null
      createdAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly sessionId: FieldRef<"Payment", 'String'>
    readonly playerId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly note: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model ShareLink
   */

  export type AggregateShareLink = {
    _count: ShareLinkCountAggregateOutputType | null
    _min: ShareLinkMinAggregateOutputType | null
    _max: ShareLinkMaxAggregateOutputType | null
  }

  export type ShareLinkMinAggregateOutputType = {
    id: string | null
    token: string | null
    sessionId: string | null
    playerId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ShareLinkMaxAggregateOutputType = {
    id: string | null
    token: string | null
    sessionId: string | null
    playerId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type ShareLinkCountAggregateOutputType = {
    id: number
    token: number
    sessionId: number
    playerId: number
    revokedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type ShareLinkMinAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    playerId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ShareLinkMaxAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    playerId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type ShareLinkCountAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    playerId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type ShareLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareLink to aggregate.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShareLinks
    **/
    _count?: true | ShareLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShareLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShareLinkMaxAggregateInputType
  }

  export type GetShareLinkAggregateType<T extends ShareLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateShareLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShareLink[P]>
      : GetScalarType<T[P], AggregateShareLink[P]>
  }




  export type ShareLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShareLinkWhereInput
    orderBy?: ShareLinkOrderByWithAggregationInput | ShareLinkOrderByWithAggregationInput[]
    by: ShareLinkScalarFieldEnum[] | ShareLinkScalarFieldEnum
    having?: ShareLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShareLinkCountAggregateInputType | true
    _min?: ShareLinkMinAggregateInputType
    _max?: ShareLinkMaxAggregateInputType
  }

  export type ShareLinkGroupByOutputType = {
    id: string
    token: string
    sessionId: string
    playerId: string
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    _count: ShareLinkCountAggregateOutputType | null
    _min: ShareLinkMinAggregateOutputType | null
    _max: ShareLinkMaxAggregateOutputType | null
  }

  type GetShareLinkGroupByPayload<T extends ShareLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShareLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShareLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
            : GetScalarType<T[P], ShareLinkGroupByOutputType[P]>
        }
      >
    >


  export type ShareLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    playerId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    playerId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    playerId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shareLink"]>

  export type ShareLinkSelectScalar = {
    id?: boolean
    token?: boolean
    sessionId?: boolean
    playerId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type ShareLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "sessionId" | "playerId" | "revokedAt" | "expiresAt" | "createdAt", ExtArgs["result"]["shareLink"]>
  export type ShareLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type ShareLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }
  export type ShareLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    player?: boolean | PlayerDefaultArgs<ExtArgs>
  }

  export type $ShareLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShareLink"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      player: Prisma.$PlayerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      sessionId: string
      playerId: string
      revokedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["shareLink"]>
    composites: {}
  }

  type ShareLinkGetPayload<S extends boolean | null | undefined | ShareLinkDefaultArgs> = $Result.GetResult<Prisma.$ShareLinkPayload, S>

  type ShareLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShareLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShareLinkCountAggregateInputType | true
    }

  export interface ShareLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShareLink'], meta: { name: 'ShareLink' } }
    /**
     * Find zero or one ShareLink that matches the filter.
     * @param {ShareLinkFindUniqueArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShareLinkFindUniqueArgs>(args: SelectSubset<T, ShareLinkFindUniqueArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ShareLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShareLinkFindUniqueOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShareLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, ShareLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShareLinkFindFirstArgs>(args?: SelectSubset<T, ShareLinkFindFirstArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ShareLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindFirstOrThrowArgs} args - Arguments to find a ShareLink
     * @example
     * // Get one ShareLink
     * const shareLink = await prisma.shareLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShareLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, ShareLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ShareLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShareLinks
     * const shareLinks = await prisma.shareLink.findMany()
     * 
     * // Get first 10 ShareLinks
     * const shareLinks = await prisma.shareLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShareLinkFindManyArgs>(args?: SelectSubset<T, ShareLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ShareLink.
     * @param {ShareLinkCreateArgs} args - Arguments to create a ShareLink.
     * @example
     * // Create one ShareLink
     * const ShareLink = await prisma.shareLink.create({
     *   data: {
     *     // ... data to create a ShareLink
     *   }
     * })
     * 
     */
    create<T extends ShareLinkCreateArgs>(args: SelectSubset<T, ShareLinkCreateArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ShareLinks.
     * @param {ShareLinkCreateManyArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShareLinkCreateManyArgs>(args?: SelectSubset<T, ShareLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShareLinks and returns the data saved in the database.
     * @param {ShareLinkCreateManyAndReturnArgs} args - Arguments to create many ShareLinks.
     * @example
     * // Create many ShareLinks
     * const shareLink = await prisma.shareLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShareLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, ShareLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ShareLink.
     * @param {ShareLinkDeleteArgs} args - Arguments to delete one ShareLink.
     * @example
     * // Delete one ShareLink
     * const ShareLink = await prisma.shareLink.delete({
     *   where: {
     *     // ... filter to delete one ShareLink
     *   }
     * })
     * 
     */
    delete<T extends ShareLinkDeleteArgs>(args: SelectSubset<T, ShareLinkDeleteArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ShareLink.
     * @param {ShareLinkUpdateArgs} args - Arguments to update one ShareLink.
     * @example
     * // Update one ShareLink
     * const shareLink = await prisma.shareLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShareLinkUpdateArgs>(args: SelectSubset<T, ShareLinkUpdateArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ShareLinks.
     * @param {ShareLinkDeleteManyArgs} args - Arguments to filter ShareLinks to delete.
     * @example
     * // Delete a few ShareLinks
     * const { count } = await prisma.shareLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShareLinkDeleteManyArgs>(args?: SelectSubset<T, ShareLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShareLinkUpdateManyArgs>(args: SelectSubset<T, ShareLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShareLinks and returns the data updated in the database.
     * @param {ShareLinkUpdateManyAndReturnArgs} args - Arguments to update many ShareLinks.
     * @example
     * // Update many ShareLinks
     * const shareLink = await prisma.shareLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ShareLinks and only return the `id`
     * const shareLinkWithIdOnly = await prisma.shareLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShareLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, ShareLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ShareLink.
     * @param {ShareLinkUpsertArgs} args - Arguments to update or create a ShareLink.
     * @example
     * // Update or create a ShareLink
     * const shareLink = await prisma.shareLink.upsert({
     *   create: {
     *     // ... data to create a ShareLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShareLink we want to update
     *   }
     * })
     */
    upsert<T extends ShareLinkUpsertArgs>(args: SelectSubset<T, ShareLinkUpsertArgs<ExtArgs>>): Prisma__ShareLinkClient<$Result.GetResult<Prisma.$ShareLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkCountArgs} args - Arguments to filter ShareLinks to count.
     * @example
     * // Count the number of ShareLinks
     * const count = await prisma.shareLink.count({
     *   where: {
     *     // ... the filter for the ShareLinks we want to count
     *   }
     * })
    **/
    count<T extends ShareLinkCountArgs>(
      args?: Subset<T, ShareLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShareLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShareLinkAggregateArgs>(args: Subset<T, ShareLinkAggregateArgs>): Prisma.PrismaPromise<GetShareLinkAggregateType<T>>

    /**
     * Group by ShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShareLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShareLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShareLinkGroupByArgs['orderBy'] }
        : { orderBy?: ShareLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShareLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShareLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShareLink model
   */
  readonly fields: ShareLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShareLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShareLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    player<T extends PlayerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlayerDefaultArgs<ExtArgs>>): Prisma__PlayerClient<$Result.GetResult<Prisma.$PlayerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShareLink model
   */
  interface ShareLinkFieldRefs {
    readonly id: FieldRef<"ShareLink", 'String'>
    readonly token: FieldRef<"ShareLink", 'String'>
    readonly sessionId: FieldRef<"ShareLink", 'String'>
    readonly playerId: FieldRef<"ShareLink", 'String'>
    readonly revokedAt: FieldRef<"ShareLink", 'DateTime'>
    readonly expiresAt: FieldRef<"ShareLink", 'DateTime'>
    readonly createdAt: FieldRef<"ShareLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShareLink findUnique
   */
  export type ShareLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink findUniqueOrThrow
   */
  export type ShareLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink findFirst
   */
  export type ShareLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink findFirstOrThrow
   */
  export type ShareLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLink to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShareLinks.
     */
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink findMany
   */
  export type ShareLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which ShareLinks to fetch.
     */
    where?: ShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShareLinks to fetch.
     */
    orderBy?: ShareLinkOrderByWithRelationInput | ShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShareLinks.
     */
    cursor?: ShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShareLinks.
     */
    skip?: number
    distinct?: ShareLinkScalarFieldEnum | ShareLinkScalarFieldEnum[]
  }

  /**
   * ShareLink create
   */
  export type ShareLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a ShareLink.
     */
    data: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>
  }

  /**
   * ShareLink createMany
   */
  export type ShareLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShareLink createManyAndReturn
   */
  export type ShareLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * The data used to create many ShareLinks.
     */
    data: ShareLinkCreateManyInput | ShareLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareLink update
   */
  export type ShareLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a ShareLink.
     */
    data: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>
    /**
     * Choose, which ShareLink to update.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink updateMany
   */
  export type ShareLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number
  }

  /**
   * ShareLink updateManyAndReturn
   */
  export type ShareLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * The data used to update ShareLinks.
     */
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which ShareLinks to update
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShareLink upsert
   */
  export type ShareLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the ShareLink to update in case it exists.
     */
    where: ShareLinkWhereUniqueInput
    /**
     * In case the ShareLink found by the `where` argument doesn't exist, create a new ShareLink with this data.
     */
    create: XOR<ShareLinkCreateInput, ShareLinkUncheckedCreateInput>
    /**
     * In case the ShareLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShareLinkUpdateInput, ShareLinkUncheckedUpdateInput>
  }

  /**
   * ShareLink delete
   */
  export type ShareLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
    /**
     * Filter which ShareLink to delete.
     */
    where: ShareLinkWhereUniqueInput
  }

  /**
   * ShareLink deleteMany
   */
  export type ShareLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShareLinks to delete
     */
    where?: ShareLinkWhereInput
    /**
     * Limit how many ShareLinks to delete.
     */
    limit?: number
  }

  /**
   * ShareLink without action
   */
  export type ShareLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShareLink
     */
    select?: ShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ShareLink
     */
    omit?: ShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShareLinkInclude<ExtArgs> | null
  }


  /**
   * Model SessionShareLink
   */

  export type AggregateSessionShareLink = {
    _count: SessionShareLinkCountAggregateOutputType | null
    _min: SessionShareLinkMinAggregateOutputType | null
    _max: SessionShareLinkMaxAggregateOutputType | null
  }

  export type SessionShareLinkMinAggregateOutputType = {
    id: string | null
    token: string | null
    sessionId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionShareLinkMaxAggregateOutputType = {
    id: string | null
    token: string | null
    sessionId: string | null
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date | null
  }

  export type SessionShareLinkCountAggregateOutputType = {
    id: number
    token: number
    sessionId: number
    revokedAt: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type SessionShareLinkMinAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionShareLinkMaxAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
  }

  export type SessionShareLinkCountAggregateInputType = {
    id?: true
    token?: true
    sessionId?: true
    revokedAt?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type SessionShareLinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionShareLink to aggregate.
     */
    where?: SessionShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionShareLinks to fetch.
     */
    orderBy?: SessionShareLinkOrderByWithRelationInput | SessionShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionShareLinks
    **/
    _count?: true | SessionShareLinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionShareLinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionShareLinkMaxAggregateInputType
  }

  export type GetSessionShareLinkAggregateType<T extends SessionShareLinkAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionShareLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionShareLink[P]>
      : GetScalarType<T[P], AggregateSessionShareLink[P]>
  }




  export type SessionShareLinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionShareLinkWhereInput
    orderBy?: SessionShareLinkOrderByWithAggregationInput | SessionShareLinkOrderByWithAggregationInput[]
    by: SessionShareLinkScalarFieldEnum[] | SessionShareLinkScalarFieldEnum
    having?: SessionShareLinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionShareLinkCountAggregateInputType | true
    _min?: SessionShareLinkMinAggregateInputType
    _max?: SessionShareLinkMaxAggregateInputType
  }

  export type SessionShareLinkGroupByOutputType = {
    id: string
    token: string
    sessionId: string
    revokedAt: Date | null
    expiresAt: Date | null
    createdAt: Date
    _count: SessionShareLinkCountAggregateOutputType | null
    _min: SessionShareLinkMinAggregateOutputType | null
    _max: SessionShareLinkMaxAggregateOutputType | null
  }

  type GetSessionShareLinkGroupByPayload<T extends SessionShareLinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionShareLinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionShareLinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionShareLinkGroupByOutputType[P]>
            : GetScalarType<T[P], SessionShareLinkGroupByOutputType[P]>
        }
      >
    >


  export type SessionShareLinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionShareLink"]>

  export type SessionShareLinkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionShareLink"]>

  export type SessionShareLinkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionShareLink"]>

  export type SessionShareLinkSelectScalar = {
    id?: boolean
    token?: boolean
    sessionId?: boolean
    revokedAt?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type SessionShareLinkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "sessionId" | "revokedAt" | "expiresAt" | "createdAt", ExtArgs["result"]["sessionShareLink"]>
  export type SessionShareLinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type SessionShareLinkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }
  export type SessionShareLinkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
  }

  export type $SessionShareLinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionShareLink"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      sessionId: string
      revokedAt: Date | null
      expiresAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["sessionShareLink"]>
    composites: {}
  }

  type SessionShareLinkGetPayload<S extends boolean | null | undefined | SessionShareLinkDefaultArgs> = $Result.GetResult<Prisma.$SessionShareLinkPayload, S>

  type SessionShareLinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionShareLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionShareLinkCountAggregateInputType | true
    }

  export interface SessionShareLinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionShareLink'], meta: { name: 'SessionShareLink' } }
    /**
     * Find zero or one SessionShareLink that matches the filter.
     * @param {SessionShareLinkFindUniqueArgs} args - Arguments to find a SessionShareLink
     * @example
     * // Get one SessionShareLink
     * const sessionShareLink = await prisma.sessionShareLink.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionShareLinkFindUniqueArgs>(args: SelectSubset<T, SessionShareLinkFindUniqueArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionShareLink that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionShareLinkFindUniqueOrThrowArgs} args - Arguments to find a SessionShareLink
     * @example
     * // Get one SessionShareLink
     * const sessionShareLink = await prisma.sessionShareLink.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionShareLinkFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionShareLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionShareLink that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkFindFirstArgs} args - Arguments to find a SessionShareLink
     * @example
     * // Get one SessionShareLink
     * const sessionShareLink = await prisma.sessionShareLink.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionShareLinkFindFirstArgs>(args?: SelectSubset<T, SessionShareLinkFindFirstArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionShareLink that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkFindFirstOrThrowArgs} args - Arguments to find a SessionShareLink
     * @example
     * // Get one SessionShareLink
     * const sessionShareLink = await prisma.sessionShareLink.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionShareLinkFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionShareLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionShareLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionShareLinks
     * const sessionShareLinks = await prisma.sessionShareLink.findMany()
     * 
     * // Get first 10 SessionShareLinks
     * const sessionShareLinks = await prisma.sessionShareLink.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionShareLinkWithIdOnly = await prisma.sessionShareLink.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionShareLinkFindManyArgs>(args?: SelectSubset<T, SessionShareLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionShareLink.
     * @param {SessionShareLinkCreateArgs} args - Arguments to create a SessionShareLink.
     * @example
     * // Create one SessionShareLink
     * const SessionShareLink = await prisma.sessionShareLink.create({
     *   data: {
     *     // ... data to create a SessionShareLink
     *   }
     * })
     * 
     */
    create<T extends SessionShareLinkCreateArgs>(args: SelectSubset<T, SessionShareLinkCreateArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionShareLinks.
     * @param {SessionShareLinkCreateManyArgs} args - Arguments to create many SessionShareLinks.
     * @example
     * // Create many SessionShareLinks
     * const sessionShareLink = await prisma.sessionShareLink.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionShareLinkCreateManyArgs>(args?: SelectSubset<T, SessionShareLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionShareLinks and returns the data saved in the database.
     * @param {SessionShareLinkCreateManyAndReturnArgs} args - Arguments to create many SessionShareLinks.
     * @example
     * // Create many SessionShareLinks
     * const sessionShareLink = await prisma.sessionShareLink.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionShareLinks and only return the `id`
     * const sessionShareLinkWithIdOnly = await prisma.sessionShareLink.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionShareLinkCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionShareLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionShareLink.
     * @param {SessionShareLinkDeleteArgs} args - Arguments to delete one SessionShareLink.
     * @example
     * // Delete one SessionShareLink
     * const SessionShareLink = await prisma.sessionShareLink.delete({
     *   where: {
     *     // ... filter to delete one SessionShareLink
     *   }
     * })
     * 
     */
    delete<T extends SessionShareLinkDeleteArgs>(args: SelectSubset<T, SessionShareLinkDeleteArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionShareLink.
     * @param {SessionShareLinkUpdateArgs} args - Arguments to update one SessionShareLink.
     * @example
     * // Update one SessionShareLink
     * const sessionShareLink = await prisma.sessionShareLink.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionShareLinkUpdateArgs>(args: SelectSubset<T, SessionShareLinkUpdateArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionShareLinks.
     * @param {SessionShareLinkDeleteManyArgs} args - Arguments to filter SessionShareLinks to delete.
     * @example
     * // Delete a few SessionShareLinks
     * const { count } = await prisma.sessionShareLink.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionShareLinkDeleteManyArgs>(args?: SelectSubset<T, SessionShareLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionShareLinks
     * const sessionShareLink = await prisma.sessionShareLink.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionShareLinkUpdateManyArgs>(args: SelectSubset<T, SessionShareLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionShareLinks and returns the data updated in the database.
     * @param {SessionShareLinkUpdateManyAndReturnArgs} args - Arguments to update many SessionShareLinks.
     * @example
     * // Update many SessionShareLinks
     * const sessionShareLink = await prisma.sessionShareLink.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionShareLinks and only return the `id`
     * const sessionShareLinkWithIdOnly = await prisma.sessionShareLink.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionShareLinkUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionShareLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionShareLink.
     * @param {SessionShareLinkUpsertArgs} args - Arguments to update or create a SessionShareLink.
     * @example
     * // Update or create a SessionShareLink
     * const sessionShareLink = await prisma.sessionShareLink.upsert({
     *   create: {
     *     // ... data to create a SessionShareLink
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionShareLink we want to update
     *   }
     * })
     */
    upsert<T extends SessionShareLinkUpsertArgs>(args: SelectSubset<T, SessionShareLinkUpsertArgs<ExtArgs>>): Prisma__SessionShareLinkClient<$Result.GetResult<Prisma.$SessionShareLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionShareLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkCountArgs} args - Arguments to filter SessionShareLinks to count.
     * @example
     * // Count the number of SessionShareLinks
     * const count = await prisma.sessionShareLink.count({
     *   where: {
     *     // ... the filter for the SessionShareLinks we want to count
     *   }
     * })
    **/
    count<T extends SessionShareLinkCountArgs>(
      args?: Subset<T, SessionShareLinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionShareLinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionShareLinkAggregateArgs>(args: Subset<T, SessionShareLinkAggregateArgs>): Prisma.PrismaPromise<GetSessionShareLinkAggregateType<T>>

    /**
     * Group by SessionShareLink.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionShareLinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionShareLinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionShareLinkGroupByArgs['orderBy'] }
        : { orderBy?: SessionShareLinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionShareLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionShareLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionShareLink model
   */
  readonly fields: SessionShareLinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionShareLink.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionShareLinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionShareLink model
   */
  interface SessionShareLinkFieldRefs {
    readonly id: FieldRef<"SessionShareLink", 'String'>
    readonly token: FieldRef<"SessionShareLink", 'String'>
    readonly sessionId: FieldRef<"SessionShareLink", 'String'>
    readonly revokedAt: FieldRef<"SessionShareLink", 'DateTime'>
    readonly expiresAt: FieldRef<"SessionShareLink", 'DateTime'>
    readonly createdAt: FieldRef<"SessionShareLink", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessionShareLink findUnique
   */
  export type SessionShareLinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionShareLink to fetch.
     */
    where: SessionShareLinkWhereUniqueInput
  }

  /**
   * SessionShareLink findUniqueOrThrow
   */
  export type SessionShareLinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionShareLink to fetch.
     */
    where: SessionShareLinkWhereUniqueInput
  }

  /**
   * SessionShareLink findFirst
   */
  export type SessionShareLinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionShareLink to fetch.
     */
    where?: SessionShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionShareLinks to fetch.
     */
    orderBy?: SessionShareLinkOrderByWithRelationInput | SessionShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionShareLinks.
     */
    cursor?: SessionShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionShareLinks.
     */
    distinct?: SessionShareLinkScalarFieldEnum | SessionShareLinkScalarFieldEnum[]
  }

  /**
   * SessionShareLink findFirstOrThrow
   */
  export type SessionShareLinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionShareLink to fetch.
     */
    where?: SessionShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionShareLinks to fetch.
     */
    orderBy?: SessionShareLinkOrderByWithRelationInput | SessionShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionShareLinks.
     */
    cursor?: SessionShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionShareLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionShareLinks.
     */
    distinct?: SessionShareLinkScalarFieldEnum | SessionShareLinkScalarFieldEnum[]
  }

  /**
   * SessionShareLink findMany
   */
  export type SessionShareLinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * Filter, which SessionShareLinks to fetch.
     */
    where?: SessionShareLinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionShareLinks to fetch.
     */
    orderBy?: SessionShareLinkOrderByWithRelationInput | SessionShareLinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionShareLinks.
     */
    cursor?: SessionShareLinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionShareLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionShareLinks.
     */
    skip?: number
    distinct?: SessionShareLinkScalarFieldEnum | SessionShareLinkScalarFieldEnum[]
  }

  /**
   * SessionShareLink create
   */
  export type SessionShareLinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionShareLink.
     */
    data: XOR<SessionShareLinkCreateInput, SessionShareLinkUncheckedCreateInput>
  }

  /**
   * SessionShareLink createMany
   */
  export type SessionShareLinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionShareLinks.
     */
    data: SessionShareLinkCreateManyInput | SessionShareLinkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessionShareLink createManyAndReturn
   */
  export type SessionShareLinkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * The data used to create many SessionShareLinks.
     */
    data: SessionShareLinkCreateManyInput | SessionShareLinkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionShareLink update
   */
  export type SessionShareLinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionShareLink.
     */
    data: XOR<SessionShareLinkUpdateInput, SessionShareLinkUncheckedUpdateInput>
    /**
     * Choose, which SessionShareLink to update.
     */
    where: SessionShareLinkWhereUniqueInput
  }

  /**
   * SessionShareLink updateMany
   */
  export type SessionShareLinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionShareLinks.
     */
    data: XOR<SessionShareLinkUpdateManyMutationInput, SessionShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which SessionShareLinks to update
     */
    where?: SessionShareLinkWhereInput
    /**
     * Limit how many SessionShareLinks to update.
     */
    limit?: number
  }

  /**
   * SessionShareLink updateManyAndReturn
   */
  export type SessionShareLinkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * The data used to update SessionShareLinks.
     */
    data: XOR<SessionShareLinkUpdateManyMutationInput, SessionShareLinkUncheckedUpdateManyInput>
    /**
     * Filter which SessionShareLinks to update
     */
    where?: SessionShareLinkWhereInput
    /**
     * Limit how many SessionShareLinks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionShareLink upsert
   */
  export type SessionShareLinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionShareLink to update in case it exists.
     */
    where: SessionShareLinkWhereUniqueInput
    /**
     * In case the SessionShareLink found by the `where` argument doesn't exist, create a new SessionShareLink with this data.
     */
    create: XOR<SessionShareLinkCreateInput, SessionShareLinkUncheckedCreateInput>
    /**
     * In case the SessionShareLink was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionShareLinkUpdateInput, SessionShareLinkUncheckedUpdateInput>
  }

  /**
   * SessionShareLink delete
   */
  export type SessionShareLinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
    /**
     * Filter which SessionShareLink to delete.
     */
    where: SessionShareLinkWhereUniqueInput
  }

  /**
   * SessionShareLink deleteMany
   */
  export type SessionShareLinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionShareLinks to delete
     */
    where?: SessionShareLinkWhereInput
    /**
     * Limit how many SessionShareLinks to delete.
     */
    limit?: number
  }

  /**
   * SessionShareLink without action
   */
  export type SessionShareLinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionShareLink
     */
    select?: SessionShareLinkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionShareLink
     */
    omit?: SessionShareLinkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionShareLinkInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    emailVerifiedAt: 'emailVerifiedAt',
    emailVerifyTokenHash: 'emailVerifyTokenHash',
    emailVerifyTokenExpiresAt: 'emailVerifyTokenExpiresAt',
    passwordResetTokenHash: 'passwordResetTokenHash',
    passwordResetTokenExpiresAt: 'passwordResetTokenExpiresAt',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    userId: 'userId',
    roleId: 'roleId'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    startsAt: 'startsAt',
    endsAt: 'endsAt',
    status: 'status',
    gameType: 'gameType',
    feeMode: 'feeMode',
    feeAmount: 'feeAmount',
    defaultBracketType: 'defaultBracketType',
    regularJoinLimit: 'regularJoinLimit',
    newJoinerLimit: 'newJoinerLimit',
    returnToQueue: 'returnToQueue',
    announcements: 'announcements',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    closedAt: 'closedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const BracketOverrideScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    matchId: 'matchId',
    bracketType: 'bracketType',
    matchFormat: 'matchFormat',
    winnerId: 'winnerId',
    scoreJson: 'scoreJson',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BracketOverrideScalarFieldEnum = (typeof BracketOverrideScalarFieldEnum)[keyof typeof BracketOverrideScalarFieldEnum]


  export const SessionInviteLinkScalarFieldEnum: {
    id: 'id',
    token: 'token',
    sessionId: 'sessionId',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionInviteLinkScalarFieldEnum = (typeof SessionInviteLinkScalarFieldEnum)[keyof typeof SessionInviteLinkScalarFieldEnum]


  export const CourtScalarFieldEnum: {
    id: 'id',
    name: 'name',
    notes: 'notes',
    active: 'active',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type CourtScalarFieldEnum = (typeof CourtScalarFieldEnum)[keyof typeof CourtScalarFieldEnum]


  export const CourtSessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    courtId: 'courtId',
    status: 'status',
    currentMatchId: 'currentMatchId',
    nextMatchId: 'nextMatchId',
    createdAt: 'createdAt'
  };

  export type CourtSessionScalarFieldEnum = (typeof CourtSessionScalarFieldEnum)[keyof typeof CourtSessionScalarFieldEnum]


  export const PlayerScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    nickname: 'nickname',
    skillLevel: 'skillLevel',
    contact: 'contact',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type PlayerScalarFieldEnum = (typeof PlayerScalarFieldEnum)[keyof typeof PlayerScalarFieldEnum]


  export const SessionPlayerScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    playerId: 'playerId',
    status: 'status',
    isNewPlayer: 'isNewPlayer',
    checkedInAt: 'checkedInAt',
    lastPlayedAt: 'lastPlayedAt',
    gamesPlayed: 'gamesPlayed',
    wins: 'wins',
    losses: 'losses',
    totalQueueSeconds: 'totalQueueSeconds'
  };

  export type SessionPlayerScalarFieldEnum = (typeof SessionPlayerScalarFieldEnum)[keyof typeof SessionPlayerScalarFieldEnum]


  export const QueueEntryScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    type: 'type',
    status: 'status',
    position: 'position',
    manualOrder: 'manualOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QueueEntryScalarFieldEnum = (typeof QueueEntryScalarFieldEnum)[keyof typeof QueueEntryScalarFieldEnum]


  export const QueueEntryPlayerScalarFieldEnum: {
    entryId: 'entryId',
    playerId: 'playerId'
  };

  export type QueueEntryPlayerScalarFieldEnum = (typeof QueueEntryPlayerScalarFieldEnum)[keyof typeof QueueEntryPlayerScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    courtSessionId: 'courtSessionId',
    status: 'status',
    matchType: 'matchType',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    scoreJson: 'scoreJson',
    winnerTeam: 'winnerTeam',
    createdAt: 'createdAt'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const MatchParticipantScalarFieldEnum: {
    matchId: 'matchId',
    playerId: 'playerId',
    teamNumber: 'teamNumber'
  };

  export type MatchParticipantScalarFieldEnum = (typeof MatchParticipantScalarFieldEnum)[keyof typeof MatchParticipantScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    playerId: 'playerId',
    amount: 'amount',
    method: 'method',
    note: 'note',
    createdAt: 'createdAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ShareLinkScalarFieldEnum: {
    id: 'id',
    token: 'token',
    sessionId: 'sessionId',
    playerId: 'playerId',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type ShareLinkScalarFieldEnum = (typeof ShareLinkScalarFieldEnum)[keyof typeof ShareLinkScalarFieldEnum]


  export const SessionShareLinkScalarFieldEnum: {
    id: 'id',
    token: 'token',
    sessionId: 'sessionId',
    revokedAt: 'revokedAt',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type SessionShareLinkScalarFieldEnum = (typeof SessionShareLinkScalarFieldEnum)[keyof typeof SessionShareLinkScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'RoleName'
   */
  export type EnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName'>
    


  /**
   * Reference to a field of type 'RoleName[]'
   */
  export type ListEnumRoleNameFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoleName[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SessionStatus'
   */
  export type EnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus'>
    


  /**
   * Reference to a field of type 'SessionStatus[]'
   */
  export type ListEnumSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SessionStatus[]'>
    


  /**
   * Reference to a field of type 'MatchType'
   */
  export type EnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType'>
    


  /**
   * Reference to a field of type 'MatchType[]'
   */
  export type ListEnumMatchTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchType[]'>
    


  /**
   * Reference to a field of type 'FeeMode'
   */
  export type EnumFeeModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeMode'>
    


  /**
   * Reference to a field of type 'FeeMode[]'
   */
  export type ListEnumFeeModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeMode[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'CourtStatus'
   */
  export type EnumCourtStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourtStatus'>
    


  /**
   * Reference to a field of type 'CourtStatus[]'
   */
  export type ListEnumCourtStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CourtStatus[]'>
    


  /**
   * Reference to a field of type 'PlayerStatus'
   */
  export type EnumPlayerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerStatus'>
    


  /**
   * Reference to a field of type 'PlayerStatus[]'
   */
  export type ListEnumPlayerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlayerStatus[]'>
    


  /**
   * Reference to a field of type 'QueueType'
   */
  export type EnumQueueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueType'>
    


  /**
   * Reference to a field of type 'QueueType[]'
   */
  export type ListEnumQueueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueType[]'>
    


  /**
   * Reference to a field of type 'QueueStatus'
   */
  export type EnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus'>
    


  /**
   * Reference to a field of type 'QueueStatus[]'
   */
  export type ListEnumQueueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueueStatus[]'>
    


  /**
   * Reference to a field of type 'MatchStatus'
   */
  export type EnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus'>
    


  /**
   * Reference to a field of type 'MatchStatus[]'
   */
  export type ListEnumMatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MatchStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: UuidFilter<"Role"> | string
    name?: EnumRoleNameFilter<"Role"> | $Enums.RoleName
    createdAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserRoleListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    users?: UserRoleOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: $Enums.RoleName
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    createdAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserRoleListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Role"> | string
    name?: EnumRoleNameWithAggregatesFilter<"Role"> | $Enums.RoleName
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: UuidFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifyTokenHash?: StringNullableFilter<"User"> | string | null
    emailVerifyTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetTokenHash?: StringNullableFilter<"User"> | string | null
    passwordResetTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    roles?: UserRoleListRelationFilter
    sessions?: SessionListRelationFilter
    courts?: CourtListRelationFilter
    players?: PlayerListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    emailVerifyTokenHash?: SortOrderInput | SortOrder
    emailVerifyTokenExpiresAt?: SortOrderInput | SortOrder
    passwordResetTokenHash?: SortOrderInput | SortOrder
    passwordResetTokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    courts?: CourtOrderByRelationAggregateInput
    players?: PlayerOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringNullableFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    emailVerifyTokenHash?: StringNullableFilter<"User"> | string | null
    emailVerifyTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    passwordResetTokenHash?: StringNullableFilter<"User"> | string | null
    passwordResetTokenExpiresAt?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    roles?: UserRoleListRelationFilter
    sessions?: SessionListRelationFilter
    courts?: CourtListRelationFilter
    players?: PlayerListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrderInput | SortOrder
    emailVerifiedAt?: SortOrderInput | SortOrder
    emailVerifyTokenHash?: SortOrderInput | SortOrder
    emailVerifyTokenExpiresAt?: SortOrderInput | SortOrder
    passwordResetTokenHash?: SortOrderInput | SortOrder
    passwordResetTokenExpiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerifiedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    emailVerifyTokenHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerifyTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    passwordResetTokenHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }

  export type UserRoleOrderByWithRelationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    user?: UserOrderByWithRelationInput
    role?: RoleOrderByWithRelationInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    userId_roleId?: UserRoleUserIdRoleIdCompoundUniqueInput
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
  }, "userId_roleId">

  export type UserRoleOrderByWithAggregationInput = {
    userId?: SortOrder
    roleId?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"UserRole"> | string
    roleId?: UuidWithAggregatesFilter<"UserRole"> | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: UuidFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
    startsAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    gameType?: EnumMatchTypeFilter<"Session"> | $Enums.MatchType
    feeMode?: EnumFeeModeFilter<"Session"> | $Enums.FeeMode
    feeAmount?: DecimalFilter<"Session"> | Decimal | DecimalJsLike | number | string
    defaultBracketType?: StringNullableFilter<"Session"> | string | null
    regularJoinLimit?: IntFilter<"Session"> | number
    newJoinerLimit?: IntFilter<"Session"> | number
    returnToQueue?: BoolFilter<"Session"> | boolean
    announcements?: StringNullableFilter<"Session"> | string | null
    createdBy?: UuidNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courtSessions?: CourtSessionListRelationFilter
    sessionPlayers?: SessionPlayerListRelationFilter
    queueEntries?: QueueEntryListRelationFilter
    matches?: MatchListRelationFilter
    payments?: PaymentListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
    sessionShareLinks?: SessionShareLinkListRelationFilter
    sessionInviteLinks?: SessionInviteLinkListRelationFilter
    bracketOverrides?: BracketOverrideListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    status?: SortOrder
    gameType?: SortOrder
    feeMode?: SortOrder
    feeAmount?: SortOrder
    defaultBracketType?: SortOrderInput | SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
    returnToQueue?: SortOrder
    announcements?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    courtSessions?: CourtSessionOrderByRelationAggregateInput
    sessionPlayers?: SessionPlayerOrderByRelationAggregateInput
    queueEntries?: QueueEntryOrderByRelationAggregateInput
    matches?: MatchOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    shareLinks?: ShareLinkOrderByRelationAggregateInput
    sessionShareLinks?: SessionShareLinkOrderByRelationAggregateInput
    sessionInviteLinks?: SessionInviteLinkOrderByRelationAggregateInput
    bracketOverrides?: BracketOverrideOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    name?: StringFilter<"Session"> | string
    startsAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    gameType?: EnumMatchTypeFilter<"Session"> | $Enums.MatchType
    feeMode?: EnumFeeModeFilter<"Session"> | $Enums.FeeMode
    feeAmount?: DecimalFilter<"Session"> | Decimal | DecimalJsLike | number | string
    defaultBracketType?: StringNullableFilter<"Session"> | string | null
    regularJoinLimit?: IntFilter<"Session"> | number
    newJoinerLimit?: IntFilter<"Session"> | number
    returnToQueue?: BoolFilter<"Session"> | boolean
    announcements?: StringNullableFilter<"Session"> | string | null
    createdBy?: UuidNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courtSessions?: CourtSessionListRelationFilter
    sessionPlayers?: SessionPlayerListRelationFilter
    queueEntries?: QueueEntryListRelationFilter
    matches?: MatchListRelationFilter
    payments?: PaymentListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
    sessionShareLinks?: SessionShareLinkListRelationFilter
    sessionInviteLinks?: SessionInviteLinkListRelationFilter
    bracketOverrides?: BracketOverrideListRelationFilter
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    startsAt?: SortOrderInput | SortOrder
    endsAt?: SortOrderInput | SortOrder
    status?: SortOrder
    gameType?: SortOrder
    feeMode?: SortOrder
    feeAmount?: SortOrder
    defaultBracketType?: SortOrderInput | SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
    returnToQueue?: SortOrder
    announcements?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrderInput | SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Session"> | string
    name?: StringWithAggregatesFilter<"Session"> | string
    startsAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    endsAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    status?: EnumSessionStatusWithAggregatesFilter<"Session"> | $Enums.SessionStatus
    gameType?: EnumMatchTypeWithAggregatesFilter<"Session"> | $Enums.MatchType
    feeMode?: EnumFeeModeWithAggregatesFilter<"Session"> | $Enums.FeeMode
    feeAmount?: DecimalWithAggregatesFilter<"Session"> | Decimal | DecimalJsLike | number | string
    defaultBracketType?: StringNullableWithAggregatesFilter<"Session"> | string | null
    regularJoinLimit?: IntWithAggregatesFilter<"Session"> | number
    newJoinerLimit?: IntWithAggregatesFilter<"Session"> | number
    returnToQueue?: BoolWithAggregatesFilter<"Session"> | boolean
    announcements?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type BracketOverrideWhereInput = {
    AND?: BracketOverrideWhereInput | BracketOverrideWhereInput[]
    OR?: BracketOverrideWhereInput[]
    NOT?: BracketOverrideWhereInput | BracketOverrideWhereInput[]
    id?: UuidFilter<"BracketOverride"> | string
    sessionId?: UuidFilter<"BracketOverride"> | string
    matchId?: StringFilter<"BracketOverride"> | string
    bracketType?: StringFilter<"BracketOverride"> | string
    matchFormat?: StringFilter<"BracketOverride"> | string
    winnerId?: StringNullableFilter<"BracketOverride"> | string | null
    scoreJson?: JsonNullableFilter<"BracketOverride">
    createdAt?: DateTimeFilter<"BracketOverride"> | Date | string
    updatedAt?: DateTimeFilter<"BracketOverride"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }

  export type BracketOverrideOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    matchId?: SortOrder
    bracketType?: SortOrder
    matchFormat?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    scoreJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type BracketOverrideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_matchId_bracketType_matchFormat?: BracketOverrideSessionIdMatchIdBracketTypeMatchFormatCompoundUniqueInput
    AND?: BracketOverrideWhereInput | BracketOverrideWhereInput[]
    OR?: BracketOverrideWhereInput[]
    NOT?: BracketOverrideWhereInput | BracketOverrideWhereInput[]
    sessionId?: UuidFilter<"BracketOverride"> | string
    matchId?: StringFilter<"BracketOverride"> | string
    bracketType?: StringFilter<"BracketOverride"> | string
    matchFormat?: StringFilter<"BracketOverride"> | string
    winnerId?: StringNullableFilter<"BracketOverride"> | string | null
    scoreJson?: JsonNullableFilter<"BracketOverride">
    createdAt?: DateTimeFilter<"BracketOverride"> | Date | string
    updatedAt?: DateTimeFilter<"BracketOverride"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }, "id" | "sessionId_matchId_bracketType_matchFormat">

  export type BracketOverrideOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    matchId?: SortOrder
    bracketType?: SortOrder
    matchFormat?: SortOrder
    winnerId?: SortOrderInput | SortOrder
    scoreJson?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BracketOverrideCountOrderByAggregateInput
    _max?: BracketOverrideMaxOrderByAggregateInput
    _min?: BracketOverrideMinOrderByAggregateInput
  }

  export type BracketOverrideScalarWhereWithAggregatesInput = {
    AND?: BracketOverrideScalarWhereWithAggregatesInput | BracketOverrideScalarWhereWithAggregatesInput[]
    OR?: BracketOverrideScalarWhereWithAggregatesInput[]
    NOT?: BracketOverrideScalarWhereWithAggregatesInput | BracketOverrideScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BracketOverride"> | string
    sessionId?: UuidWithAggregatesFilter<"BracketOverride"> | string
    matchId?: StringWithAggregatesFilter<"BracketOverride"> | string
    bracketType?: StringWithAggregatesFilter<"BracketOverride"> | string
    matchFormat?: StringWithAggregatesFilter<"BracketOverride"> | string
    winnerId?: StringNullableWithAggregatesFilter<"BracketOverride"> | string | null
    scoreJson?: JsonNullableWithAggregatesFilter<"BracketOverride">
    createdAt?: DateTimeWithAggregatesFilter<"BracketOverride"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BracketOverride"> | Date | string
  }

  export type SessionInviteLinkWhereInput = {
    AND?: SessionInviteLinkWhereInput | SessionInviteLinkWhereInput[]
    OR?: SessionInviteLinkWhereInput[]
    NOT?: SessionInviteLinkWhereInput | SessionInviteLinkWhereInput[]
    id?: UuidFilter<"SessionInviteLink"> | string
    token?: StringFilter<"SessionInviteLink"> | string
    sessionId?: UuidFilter<"SessionInviteLink"> | string
    revokedAt?: DateTimeNullableFilter<"SessionInviteLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SessionInviteLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SessionInviteLink"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }

  export type SessionInviteLinkOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type SessionInviteLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionInviteLinkWhereInput | SessionInviteLinkWhereInput[]
    OR?: SessionInviteLinkWhereInput[]
    NOT?: SessionInviteLinkWhereInput | SessionInviteLinkWhereInput[]
    sessionId?: UuidFilter<"SessionInviteLink"> | string
    revokedAt?: DateTimeNullableFilter<"SessionInviteLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SessionInviteLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SessionInviteLink"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }, "id" | "token">

  export type SessionInviteLinkOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionInviteLinkCountOrderByAggregateInput
    _max?: SessionInviteLinkMaxOrderByAggregateInput
    _min?: SessionInviteLinkMinOrderByAggregateInput
  }

  export type SessionInviteLinkScalarWhereWithAggregatesInput = {
    AND?: SessionInviteLinkScalarWhereWithAggregatesInput | SessionInviteLinkScalarWhereWithAggregatesInput[]
    OR?: SessionInviteLinkScalarWhereWithAggregatesInput[]
    NOT?: SessionInviteLinkScalarWhereWithAggregatesInput | SessionInviteLinkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SessionInviteLink"> | string
    token?: StringWithAggregatesFilter<"SessionInviteLink"> | string
    sessionId?: UuidWithAggregatesFilter<"SessionInviteLink"> | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"SessionInviteLink"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SessionInviteLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionInviteLink"> | Date | string
  }

  export type CourtWhereInput = {
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    id?: UuidFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    notes?: StringNullableFilter<"Court"> | string | null
    active?: BoolFilter<"Court"> | boolean
    createdBy?: UuidNullableFilter<"Court"> | string | null
    createdAt?: DateTimeFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Court"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courtSessions?: CourtSessionListRelationFilter
  }

  export type CourtOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrderInput | SortOrder
    active?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    courtSessions?: CourtSessionOrderByRelationAggregateInput
  }

  export type CourtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    name?: StringFilter<"Court"> | string
    notes?: StringNullableFilter<"Court"> | string | null
    active?: BoolFilter<"Court"> | boolean
    createdBy?: UuidNullableFilter<"Court"> | string | null
    createdAt?: DateTimeFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Court"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    courtSessions?: CourtSessionListRelationFilter
  }, "id">

  export type CourtOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrderInput | SortOrder
    active?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CourtCountOrderByAggregateInput
    _max?: CourtMaxOrderByAggregateInput
    _min?: CourtMinOrderByAggregateInput
  }

  export type CourtScalarWhereWithAggregatesInput = {
    AND?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    OR?: CourtScalarWhereWithAggregatesInput[]
    NOT?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Court"> | string
    name?: StringWithAggregatesFilter<"Court"> | string
    notes?: StringNullableWithAggregatesFilter<"Court"> | string | null
    active?: BoolWithAggregatesFilter<"Court"> | boolean
    createdBy?: UuidNullableWithAggregatesFilter<"Court"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Court"> | Date | string | null
  }

  export type CourtSessionWhereInput = {
    AND?: CourtSessionWhereInput | CourtSessionWhereInput[]
    OR?: CourtSessionWhereInput[]
    NOT?: CourtSessionWhereInput | CourtSessionWhereInput[]
    id?: UuidFilter<"CourtSession"> | string
    sessionId?: UuidFilter<"CourtSession"> | string
    courtId?: UuidFilter<"CourtSession"> | string
    status?: EnumCourtStatusFilter<"CourtSession"> | $Enums.CourtStatus
    currentMatchId?: UuidNullableFilter<"CourtSession"> | string | null
    nextMatchId?: UuidNullableFilter<"CourtSession"> | string | null
    createdAt?: DateTimeFilter<"CourtSession"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    court?: XOR<CourtScalarRelationFilter, CourtWhereInput>
  }

  export type CourtSessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    currentMatchId?: SortOrderInput | SortOrder
    nextMatchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    court?: CourtOrderByWithRelationInput
  }

  export type CourtSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_courtId?: CourtSessionSessionIdCourtIdCompoundUniqueInput
    AND?: CourtSessionWhereInput | CourtSessionWhereInput[]
    OR?: CourtSessionWhereInput[]
    NOT?: CourtSessionWhereInput | CourtSessionWhereInput[]
    sessionId?: UuidFilter<"CourtSession"> | string
    courtId?: UuidFilter<"CourtSession"> | string
    status?: EnumCourtStatusFilter<"CourtSession"> | $Enums.CourtStatus
    currentMatchId?: UuidNullableFilter<"CourtSession"> | string | null
    nextMatchId?: UuidNullableFilter<"CourtSession"> | string | null
    createdAt?: DateTimeFilter<"CourtSession"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    court?: XOR<CourtScalarRelationFilter, CourtWhereInput>
  }, "id" | "sessionId_courtId">

  export type CourtSessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    currentMatchId?: SortOrderInput | SortOrder
    nextMatchId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourtSessionCountOrderByAggregateInput
    _max?: CourtSessionMaxOrderByAggregateInput
    _min?: CourtSessionMinOrderByAggregateInput
  }

  export type CourtSessionScalarWhereWithAggregatesInput = {
    AND?: CourtSessionScalarWhereWithAggregatesInput | CourtSessionScalarWhereWithAggregatesInput[]
    OR?: CourtSessionScalarWhereWithAggregatesInput[]
    NOT?: CourtSessionScalarWhereWithAggregatesInput | CourtSessionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CourtSession"> | string
    sessionId?: UuidWithAggregatesFilter<"CourtSession"> | string
    courtId?: UuidWithAggregatesFilter<"CourtSession"> | string
    status?: EnumCourtStatusWithAggregatesFilter<"CourtSession"> | $Enums.CourtStatus
    currentMatchId?: UuidNullableWithAggregatesFilter<"CourtSession"> | string | null
    nextMatchId?: UuidNullableWithAggregatesFilter<"CourtSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CourtSession"> | Date | string
  }

  export type PlayerWhereInput = {
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    id?: UuidFilter<"Player"> | string
    fullName?: StringFilter<"Player"> | string
    nickname?: StringNullableFilter<"Player"> | string | null
    skillLevel?: StringNullableFilter<"Player"> | string | null
    contact?: StringNullableFilter<"Player"> | string | null
    createdBy?: UuidNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Player"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sessionPlayers?: SessionPlayerListRelationFilter
    queueEntryPlayers?: QueueEntryPlayerListRelationFilter
    matchParticipants?: MatchParticipantListRelationFilter
    payments?: PaymentListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
  }

  export type PlayerOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    nickname?: SortOrderInput | SortOrder
    skillLevel?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    creator?: UserOrderByWithRelationInput
    sessionPlayers?: SessionPlayerOrderByRelationAggregateInput
    queueEntryPlayers?: QueueEntryPlayerOrderByRelationAggregateInput
    matchParticipants?: MatchParticipantOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    shareLinks?: ShareLinkOrderByRelationAggregateInput
  }

  export type PlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlayerWhereInput | PlayerWhereInput[]
    OR?: PlayerWhereInput[]
    NOT?: PlayerWhereInput | PlayerWhereInput[]
    fullName?: StringFilter<"Player"> | string
    nickname?: StringNullableFilter<"Player"> | string | null
    skillLevel?: StringNullableFilter<"Player"> | string | null
    contact?: StringNullableFilter<"Player"> | string | null
    createdBy?: UuidNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Player"> | Date | string | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sessionPlayers?: SessionPlayerListRelationFilter
    queueEntryPlayers?: QueueEntryPlayerListRelationFilter
    matchParticipants?: MatchParticipantListRelationFilter
    payments?: PaymentListRelationFilter
    shareLinks?: ShareLinkListRelationFilter
  }, "id">

  export type PlayerOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    nickname?: SortOrderInput | SortOrder
    skillLevel?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PlayerCountOrderByAggregateInput
    _max?: PlayerMaxOrderByAggregateInput
    _min?: PlayerMinOrderByAggregateInput
  }

  export type PlayerScalarWhereWithAggregatesInput = {
    AND?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    OR?: PlayerScalarWhereWithAggregatesInput[]
    NOT?: PlayerScalarWhereWithAggregatesInput | PlayerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Player"> | string
    fullName?: StringWithAggregatesFilter<"Player"> | string
    nickname?: StringNullableWithAggregatesFilter<"Player"> | string | null
    skillLevel?: StringNullableWithAggregatesFilter<"Player"> | string | null
    contact?: StringNullableWithAggregatesFilter<"Player"> | string | null
    createdBy?: UuidNullableWithAggregatesFilter<"Player"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Player"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Player"> | Date | string | null
  }

  export type SessionPlayerWhereInput = {
    AND?: SessionPlayerWhereInput | SessionPlayerWhereInput[]
    OR?: SessionPlayerWhereInput[]
    NOT?: SessionPlayerWhereInput | SessionPlayerWhereInput[]
    id?: UuidFilter<"SessionPlayer"> | string
    sessionId?: UuidFilter<"SessionPlayer"> | string
    playerId?: UuidFilter<"SessionPlayer"> | string
    status?: EnumPlayerStatusFilter<"SessionPlayer"> | $Enums.PlayerStatus
    isNewPlayer?: BoolFilter<"SessionPlayer"> | boolean
    checkedInAt?: DateTimeFilter<"SessionPlayer"> | Date | string
    lastPlayedAt?: DateTimeNullableFilter<"SessionPlayer"> | Date | string | null
    gamesPlayed?: IntFilter<"SessionPlayer"> | number
    wins?: IntFilter<"SessionPlayer"> | number
    losses?: IntFilter<"SessionPlayer"> | number
    totalQueueSeconds?: IntFilter<"SessionPlayer"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type SessionPlayerOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    status?: SortOrder
    isNewPlayer?: SortOrder
    checkedInAt?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
    session?: SessionOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type SessionPlayerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionId_playerId?: SessionPlayerSessionIdPlayerIdCompoundUniqueInput
    AND?: SessionPlayerWhereInput | SessionPlayerWhereInput[]
    OR?: SessionPlayerWhereInput[]
    NOT?: SessionPlayerWhereInput | SessionPlayerWhereInput[]
    sessionId?: UuidFilter<"SessionPlayer"> | string
    playerId?: UuidFilter<"SessionPlayer"> | string
    status?: EnumPlayerStatusFilter<"SessionPlayer"> | $Enums.PlayerStatus
    isNewPlayer?: BoolFilter<"SessionPlayer"> | boolean
    checkedInAt?: DateTimeFilter<"SessionPlayer"> | Date | string
    lastPlayedAt?: DateTimeNullableFilter<"SessionPlayer"> | Date | string | null
    gamesPlayed?: IntFilter<"SessionPlayer"> | number
    wins?: IntFilter<"SessionPlayer"> | number
    losses?: IntFilter<"SessionPlayer"> | number
    totalQueueSeconds?: IntFilter<"SessionPlayer"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "sessionId_playerId">

  export type SessionPlayerOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    status?: SortOrder
    isNewPlayer?: SortOrder
    checkedInAt?: SortOrder
    lastPlayedAt?: SortOrderInput | SortOrder
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
    _count?: SessionPlayerCountOrderByAggregateInput
    _avg?: SessionPlayerAvgOrderByAggregateInput
    _max?: SessionPlayerMaxOrderByAggregateInput
    _min?: SessionPlayerMinOrderByAggregateInput
    _sum?: SessionPlayerSumOrderByAggregateInput
  }

  export type SessionPlayerScalarWhereWithAggregatesInput = {
    AND?: SessionPlayerScalarWhereWithAggregatesInput | SessionPlayerScalarWhereWithAggregatesInput[]
    OR?: SessionPlayerScalarWhereWithAggregatesInput[]
    NOT?: SessionPlayerScalarWhereWithAggregatesInput | SessionPlayerScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SessionPlayer"> | string
    sessionId?: UuidWithAggregatesFilter<"SessionPlayer"> | string
    playerId?: UuidWithAggregatesFilter<"SessionPlayer"> | string
    status?: EnumPlayerStatusWithAggregatesFilter<"SessionPlayer"> | $Enums.PlayerStatus
    isNewPlayer?: BoolWithAggregatesFilter<"SessionPlayer"> | boolean
    checkedInAt?: DateTimeWithAggregatesFilter<"SessionPlayer"> | Date | string
    lastPlayedAt?: DateTimeNullableWithAggregatesFilter<"SessionPlayer"> | Date | string | null
    gamesPlayed?: IntWithAggregatesFilter<"SessionPlayer"> | number
    wins?: IntWithAggregatesFilter<"SessionPlayer"> | number
    losses?: IntWithAggregatesFilter<"SessionPlayer"> | number
    totalQueueSeconds?: IntWithAggregatesFilter<"SessionPlayer"> | number
  }

  export type QueueEntryWhereInput = {
    AND?: QueueEntryWhereInput | QueueEntryWhereInput[]
    OR?: QueueEntryWhereInput[]
    NOT?: QueueEntryWhereInput | QueueEntryWhereInput[]
    id?: UuidFilter<"QueueEntry"> | string
    sessionId?: UuidFilter<"QueueEntry"> | string
    type?: EnumQueueTypeFilter<"QueueEntry"> | $Enums.QueueType
    status?: EnumQueueStatusFilter<"QueueEntry"> | $Enums.QueueStatus
    position?: IntFilter<"QueueEntry"> | number
    manualOrder?: BoolFilter<"QueueEntry"> | boolean
    createdAt?: DateTimeFilter<"QueueEntry"> | Date | string
    updatedAt?: DateTimeFilter<"QueueEntry"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    players?: QueueEntryPlayerListRelationFilter
  }

  export type QueueEntryOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    position?: SortOrder
    manualOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    players?: QueueEntryPlayerOrderByRelationAggregateInput
  }

  export type QueueEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QueueEntryWhereInput | QueueEntryWhereInput[]
    OR?: QueueEntryWhereInput[]
    NOT?: QueueEntryWhereInput | QueueEntryWhereInput[]
    sessionId?: UuidFilter<"QueueEntry"> | string
    type?: EnumQueueTypeFilter<"QueueEntry"> | $Enums.QueueType
    status?: EnumQueueStatusFilter<"QueueEntry"> | $Enums.QueueStatus
    position?: IntFilter<"QueueEntry"> | number
    manualOrder?: BoolFilter<"QueueEntry"> | boolean
    createdAt?: DateTimeFilter<"QueueEntry"> | Date | string
    updatedAt?: DateTimeFilter<"QueueEntry"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    players?: QueueEntryPlayerListRelationFilter
  }, "id">

  export type QueueEntryOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    position?: SortOrder
    manualOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QueueEntryCountOrderByAggregateInput
    _avg?: QueueEntryAvgOrderByAggregateInput
    _max?: QueueEntryMaxOrderByAggregateInput
    _min?: QueueEntryMinOrderByAggregateInput
    _sum?: QueueEntrySumOrderByAggregateInput
  }

  export type QueueEntryScalarWhereWithAggregatesInput = {
    AND?: QueueEntryScalarWhereWithAggregatesInput | QueueEntryScalarWhereWithAggregatesInput[]
    OR?: QueueEntryScalarWhereWithAggregatesInput[]
    NOT?: QueueEntryScalarWhereWithAggregatesInput | QueueEntryScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"QueueEntry"> | string
    sessionId?: UuidWithAggregatesFilter<"QueueEntry"> | string
    type?: EnumQueueTypeWithAggregatesFilter<"QueueEntry"> | $Enums.QueueType
    status?: EnumQueueStatusWithAggregatesFilter<"QueueEntry"> | $Enums.QueueStatus
    position?: IntWithAggregatesFilter<"QueueEntry"> | number
    manualOrder?: BoolWithAggregatesFilter<"QueueEntry"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QueueEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QueueEntry"> | Date | string
  }

  export type QueueEntryPlayerWhereInput = {
    AND?: QueueEntryPlayerWhereInput | QueueEntryPlayerWhereInput[]
    OR?: QueueEntryPlayerWhereInput[]
    NOT?: QueueEntryPlayerWhereInput | QueueEntryPlayerWhereInput[]
    entryId?: UuidFilter<"QueueEntryPlayer"> | string
    playerId?: UuidFilter<"QueueEntryPlayer"> | string
    entry?: XOR<QueueEntryScalarRelationFilter, QueueEntryWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type QueueEntryPlayerOrderByWithRelationInput = {
    entryId?: SortOrder
    playerId?: SortOrder
    entry?: QueueEntryOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type QueueEntryPlayerWhereUniqueInput = Prisma.AtLeast<{
    entryId_playerId?: QueueEntryPlayerEntryIdPlayerIdCompoundUniqueInput
    AND?: QueueEntryPlayerWhereInput | QueueEntryPlayerWhereInput[]
    OR?: QueueEntryPlayerWhereInput[]
    NOT?: QueueEntryPlayerWhereInput | QueueEntryPlayerWhereInput[]
    entryId?: UuidFilter<"QueueEntryPlayer"> | string
    playerId?: UuidFilter<"QueueEntryPlayer"> | string
    entry?: XOR<QueueEntryScalarRelationFilter, QueueEntryWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "entryId_playerId">

  export type QueueEntryPlayerOrderByWithAggregationInput = {
    entryId?: SortOrder
    playerId?: SortOrder
    _count?: QueueEntryPlayerCountOrderByAggregateInput
    _max?: QueueEntryPlayerMaxOrderByAggregateInput
    _min?: QueueEntryPlayerMinOrderByAggregateInput
  }

  export type QueueEntryPlayerScalarWhereWithAggregatesInput = {
    AND?: QueueEntryPlayerScalarWhereWithAggregatesInput | QueueEntryPlayerScalarWhereWithAggregatesInput[]
    OR?: QueueEntryPlayerScalarWhereWithAggregatesInput[]
    NOT?: QueueEntryPlayerScalarWhereWithAggregatesInput | QueueEntryPlayerScalarWhereWithAggregatesInput[]
    entryId?: UuidWithAggregatesFilter<"QueueEntryPlayer"> | string
    playerId?: UuidWithAggregatesFilter<"QueueEntryPlayer"> | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    id?: UuidFilter<"Match"> | string
    sessionId?: UuidFilter<"Match"> | string
    courtSessionId?: UuidNullableFilter<"Match"> | string | null
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    matchType?: EnumMatchTypeFilter<"Match"> | $Enums.MatchType
    startedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    scoreJson?: JsonNullableFilter<"Match">
    winnerTeam?: IntNullableFilter<"Match"> | number | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    participants?: MatchParticipantListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtSessionId?: SortOrderInput | SortOrder
    status?: SortOrder
    matchType?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    scoreJson?: SortOrderInput | SortOrder
    winnerTeam?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    participants?: MatchParticipantOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    sessionId?: UuidFilter<"Match"> | string
    courtSessionId?: UuidNullableFilter<"Match"> | string | null
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    matchType?: EnumMatchTypeFilter<"Match"> | $Enums.MatchType
    startedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    scoreJson?: JsonNullableFilter<"Match">
    winnerTeam?: IntNullableFilter<"Match"> | number | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    participants?: MatchParticipantListRelationFilter
  }, "id">

  export type MatchOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtSessionId?: SortOrderInput | SortOrder
    status?: SortOrder
    matchType?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    scoreJson?: SortOrderInput | SortOrder
    winnerTeam?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Match"> | string
    sessionId?: UuidWithAggregatesFilter<"Match"> | string
    courtSessionId?: UuidNullableWithAggregatesFilter<"Match"> | string | null
    status?: EnumMatchStatusWithAggregatesFilter<"Match"> | $Enums.MatchStatus
    matchType?: EnumMatchTypeWithAggregatesFilter<"Match"> | $Enums.MatchType
    startedAt?: DateTimeNullableWithAggregatesFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Match"> | Date | string | null
    scoreJson?: JsonNullableWithAggregatesFilter<"Match">
    winnerTeam?: IntNullableWithAggregatesFilter<"Match"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Match"> | Date | string
  }

  export type MatchParticipantWhereInput = {
    AND?: MatchParticipantWhereInput | MatchParticipantWhereInput[]
    OR?: MatchParticipantWhereInput[]
    NOT?: MatchParticipantWhereInput | MatchParticipantWhereInput[]
    matchId?: UuidFilter<"MatchParticipant"> | string
    playerId?: UuidFilter<"MatchParticipant"> | string
    teamNumber?: IntFilter<"MatchParticipant"> | number
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type MatchParticipantOrderByWithRelationInput = {
    matchId?: SortOrder
    playerId?: SortOrder
    teamNumber?: SortOrder
    match?: MatchOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type MatchParticipantWhereUniqueInput = Prisma.AtLeast<{
    matchId_playerId?: MatchParticipantMatchIdPlayerIdCompoundUniqueInput
    AND?: MatchParticipantWhereInput | MatchParticipantWhereInput[]
    OR?: MatchParticipantWhereInput[]
    NOT?: MatchParticipantWhereInput | MatchParticipantWhereInput[]
    matchId?: UuidFilter<"MatchParticipant"> | string
    playerId?: UuidFilter<"MatchParticipant"> | string
    teamNumber?: IntFilter<"MatchParticipant"> | number
    match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "matchId_playerId">

  export type MatchParticipantOrderByWithAggregationInput = {
    matchId?: SortOrder
    playerId?: SortOrder
    teamNumber?: SortOrder
    _count?: MatchParticipantCountOrderByAggregateInput
    _avg?: MatchParticipantAvgOrderByAggregateInput
    _max?: MatchParticipantMaxOrderByAggregateInput
    _min?: MatchParticipantMinOrderByAggregateInput
    _sum?: MatchParticipantSumOrderByAggregateInput
  }

  export type MatchParticipantScalarWhereWithAggregatesInput = {
    AND?: MatchParticipantScalarWhereWithAggregatesInput | MatchParticipantScalarWhereWithAggregatesInput[]
    OR?: MatchParticipantScalarWhereWithAggregatesInput[]
    NOT?: MatchParticipantScalarWhereWithAggregatesInput | MatchParticipantScalarWhereWithAggregatesInput[]
    matchId?: UuidWithAggregatesFilter<"MatchParticipant"> | string
    playerId?: UuidWithAggregatesFilter<"MatchParticipant"> | string
    teamNumber?: IntWithAggregatesFilter<"MatchParticipant"> | number
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: UuidFilter<"Payment"> | string
    sessionId?: UuidFilter<"Payment"> | string
    playerId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    note?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    sessionId?: UuidFilter<"Payment"> | string
    playerId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    note?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Payment"> | string
    sessionId?: UuidWithAggregatesFilter<"Payment"> | string
    playerId?: UuidWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    note?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ShareLinkWhereInput = {
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[]
    OR?: ShareLinkWhereInput[]
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[]
    id?: UuidFilter<"ShareLink"> | string
    token?: StringFilter<"ShareLink"> | string
    sessionId?: UuidFilter<"ShareLink"> | string
    playerId?: UuidFilter<"ShareLink"> | string
    revokedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }

  export type ShareLinkOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
    player?: PlayerOrderByWithRelationInput
  }

  export type ShareLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: ShareLinkWhereInput | ShareLinkWhereInput[]
    OR?: ShareLinkWhereInput[]
    NOT?: ShareLinkWhereInput | ShareLinkWhereInput[]
    sessionId?: UuidFilter<"ShareLink"> | string
    playerId?: UuidFilter<"ShareLink"> | string
    revokedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    player?: XOR<PlayerScalarRelationFilter, PlayerWhereInput>
  }, "id" | "token">

  export type ShareLinkOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ShareLinkCountOrderByAggregateInput
    _max?: ShareLinkMaxOrderByAggregateInput
    _min?: ShareLinkMinOrderByAggregateInput
  }

  export type ShareLinkScalarWhereWithAggregatesInput = {
    AND?: ShareLinkScalarWhereWithAggregatesInput | ShareLinkScalarWhereWithAggregatesInput[]
    OR?: ShareLinkScalarWhereWithAggregatesInput[]
    NOT?: ShareLinkScalarWhereWithAggregatesInput | ShareLinkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ShareLink"> | string
    token?: StringWithAggregatesFilter<"ShareLink"> | string
    sessionId?: UuidWithAggregatesFilter<"ShareLink"> | string
    playerId?: UuidWithAggregatesFilter<"ShareLink"> | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShareLink"> | Date | string
  }

  export type SessionShareLinkWhereInput = {
    AND?: SessionShareLinkWhereInput | SessionShareLinkWhereInput[]
    OR?: SessionShareLinkWhereInput[]
    NOT?: SessionShareLinkWhereInput | SessionShareLinkWhereInput[]
    id?: UuidFilter<"SessionShareLink"> | string
    token?: StringFilter<"SessionShareLink"> | string
    sessionId?: UuidFilter<"SessionShareLink"> | string
    revokedAt?: DateTimeNullableFilter<"SessionShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SessionShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SessionShareLink"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }

  export type SessionShareLinkOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    session?: SessionOrderByWithRelationInput
  }

  export type SessionShareLinkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionShareLinkWhereInput | SessionShareLinkWhereInput[]
    OR?: SessionShareLinkWhereInput[]
    NOT?: SessionShareLinkWhereInput | SessionShareLinkWhereInput[]
    sessionId?: UuidFilter<"SessionShareLink"> | string
    revokedAt?: DateTimeNullableFilter<"SessionShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SessionShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SessionShareLink"> | Date | string
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
  }, "id" | "token">

  export type SessionShareLinkOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SessionShareLinkCountOrderByAggregateInput
    _max?: SessionShareLinkMaxOrderByAggregateInput
    _min?: SessionShareLinkMinOrderByAggregateInput
  }

  export type SessionShareLinkScalarWhereWithAggregatesInput = {
    AND?: SessionShareLinkScalarWhereWithAggregatesInput | SessionShareLinkScalarWhereWithAggregatesInput[]
    OR?: SessionShareLinkScalarWhereWithAggregatesInput[]
    NOT?: SessionShareLinkScalarWhereWithAggregatesInput | SessionShareLinkScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SessionShareLink"> | string
    token?: StringWithAggregatesFilter<"SessionShareLink"> | string
    sessionId?: UuidWithAggregatesFilter<"SessionShareLink"> | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"SessionShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"SessionShareLink"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SessionShareLink"> | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: $Enums.RoleName
    createdAt?: Date | string
    users?: UserRoleCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: $Enums.RoleName
    createdAt?: Date | string
    users?: UserRoleUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserRoleUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: $Enums.RoleName
    createdAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutCreatorInput
    courts?: CourtCreateNestedManyWithoutCreatorInput
    players?: PlayerCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCreatorInput
    courts?: CourtUncheckedCreateNestedManyWithoutCreatorInput
    players?: PlayerUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutCreatorNestedInput
    courts?: CourtUpdateManyWithoutCreatorNestedInput
    players?: PlayerUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCreatorNestedInput
    courts?: CourtUncheckedUpdateManyWithoutCreatorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserRoleCreateInput = {
    user: UserCreateNestedOneWithoutRolesInput
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyInput = {
    userId: string
    roleId: string
  }

  export type UserRoleUpdateManyMutationInput = {

  }

  export type UserRoleUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BracketOverrideCreateInput = {
    id?: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId?: string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutBracketOverridesInput
  }

  export type BracketOverrideUncheckedCreateInput = {
    id?: string
    sessionId: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId?: string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BracketOverrideUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutBracketOverridesNestedInput
  }

  export type BracketOverrideUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BracketOverrideCreateManyInput = {
    id?: string
    sessionId: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId?: string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BracketOverrideUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BracketOverrideUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionInviteLinkCreateInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutSessionInviteLinksInput
  }

  export type SessionInviteLinkUncheckedCreateInput = {
    id?: string
    token: string
    sessionId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionInviteLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutSessionInviteLinksNestedInput
  }

  export type SessionInviteLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionInviteLinkCreateManyInput = {
    id?: string
    token: string
    sessionId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionInviteLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionInviteLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtCreateInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutCourtsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutCourtsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type CourtCreateManyInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CourtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourtSessionCreateInput = {
    id?: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutCourtSessionsInput
    court: CourtCreateNestedOneWithoutCourtSessionsInput
  }

  export type CourtSessionUncheckedCreateInput = {
    id?: string
    sessionId: string
    courtId: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
  }

  export type CourtSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutCourtSessionsNestedInput
    court?: CourtUpdateOneRequiredWithoutCourtSessionsNestedInput
  }

  export type CourtSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    courtId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtSessionCreateManyInput = {
    id?: string
    sessionId: string
    courtId: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
  }

  export type CourtSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    courtId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerCreateInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutPlayersInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantCreateNestedManyWithoutPlayerInput
    payments?: PaymentCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutPlayersNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerCreateManyInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionPlayerCreateInput = {
    id?: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
    session: SessionCreateNestedOneWithoutSessionPlayersInput
    player: PlayerCreateNestedOneWithoutSessionPlayersInput
  }

  export type SessionPlayerUncheckedCreateInput = {
    id?: string
    sessionId: string
    playerId: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
  }

  export type SessionPlayerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
    session?: SessionUpdateOneRequiredWithoutSessionPlayersNestedInput
    player?: PlayerUpdateOneRequiredWithoutSessionPlayersNestedInput
  }

  export type SessionPlayerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type SessionPlayerCreateManyInput = {
    id?: string
    sessionId: string
    playerId: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
  }

  export type SessionPlayerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type SessionPlayerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type QueueEntryCreateInput = {
    id?: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutQueueEntriesInput
    players?: QueueEntryPlayerCreateNestedManyWithoutEntryInput
  }

  export type QueueEntryUncheckedCreateInput = {
    id?: string
    sessionId: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: QueueEntryPlayerUncheckedCreateNestedManyWithoutEntryInput
  }

  export type QueueEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutQueueEntriesNestedInput
    players?: QueueEntryPlayerUpdateManyWithoutEntryNestedInput
  }

  export type QueueEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: QueueEntryPlayerUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type QueueEntryCreateManyInput = {
    id?: string
    sessionId: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueueEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryPlayerCreateInput = {
    entry: QueueEntryCreateNestedOneWithoutPlayersInput
    player: PlayerCreateNestedOneWithoutQueueEntryPlayersInput
  }

  export type QueueEntryPlayerUncheckedCreateInput = {
    entryId: string
    playerId: string
  }

  export type QueueEntryPlayerUpdateInput = {
    entry?: QueueEntryUpdateOneRequiredWithoutPlayersNestedInput
    player?: PlayerUpdateOneRequiredWithoutQueueEntryPlayersNestedInput
  }

  export type QueueEntryPlayerUncheckedUpdateInput = {
    entryId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type QueueEntryPlayerCreateManyInput = {
    entryId: string
    playerId: string
  }

  export type QueueEntryPlayerUpdateManyMutationInput = {

  }

  export type QueueEntryPlayerUncheckedUpdateManyInput = {
    entryId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type MatchCreateInput = {
    id?: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutMatchesInput
    participants?: MatchParticipantCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    id?: string
    sessionId: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
    participants?: MatchParticipantUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutMatchesNestedInput
    participants?: MatchParticipantUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MatchParticipantUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    id?: string
    sessionId: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
  }

  export type MatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchParticipantCreateInput = {
    teamNumber: number
    match: MatchCreateNestedOneWithoutParticipantsInput
    player: PlayerCreateNestedOneWithoutMatchParticipantsInput
  }

  export type MatchParticipantUncheckedCreateInput = {
    matchId: string
    playerId: string
    teamNumber: number
  }

  export type MatchParticipantUpdateInput = {
    teamNumber?: IntFieldUpdateOperationsInput | number
    match?: MatchUpdateOneRequiredWithoutParticipantsNestedInput
    player?: PlayerUpdateOneRequiredWithoutMatchParticipantsNestedInput
  }

  export type MatchParticipantUncheckedUpdateInput = {
    matchId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    teamNumber?: IntFieldUpdateOperationsInput | number
  }

  export type MatchParticipantCreateManyInput = {
    matchId: string
    playerId: string
    teamNumber: number
  }

  export type MatchParticipantUpdateManyMutationInput = {
    teamNumber?: IntFieldUpdateOperationsInput | number
  }

  export type MatchParticipantUncheckedUpdateManyInput = {
    matchId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    teamNumber?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutPaymentsInput
    player: PlayerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    sessionId: string
    playerId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutPaymentsNestedInput
    player?: PlayerUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    sessionId: string
    playerId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkCreateInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutShareLinksInput
    player: PlayerCreateNestedOneWithoutShareLinksInput
  }

  export type ShareLinkUncheckedCreateInput = {
    id?: string
    token: string
    sessionId: string
    playerId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ShareLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutShareLinksNestedInput
    player?: PlayerUpdateOneRequiredWithoutShareLinksNestedInput
  }

  export type ShareLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkCreateManyInput = {
    id?: string
    token: string
    sessionId: string
    playerId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ShareLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionShareLinkCreateInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutSessionShareLinksInput
  }

  export type SessionShareLinkUncheckedCreateInput = {
    id?: string
    token: string
    sessionId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionShareLinkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutSessionShareLinksNestedInput
  }

  export type SessionShareLinkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionShareLinkCreateManyInput = {
    id?: string
    token: string
    sessionId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionShareLinkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionShareLinkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type EnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type CourtListRelationFilter = {
    every?: CourtWhereInput
    some?: CourtWhereInput
    none?: CourtWhereInput
  }

  export type PlayerListRelationFilter = {
    every?: PlayerWhereInput
    some?: PlayerWhereInput
    none?: PlayerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    emailVerifiedAt?: SortOrder
    emailVerifyTokenHash?: SortOrder
    emailVerifyTokenExpiresAt?: SortOrder
    passwordResetTokenHash?: SortOrder
    passwordResetTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    emailVerifiedAt?: SortOrder
    emailVerifyTokenHash?: SortOrder
    emailVerifyTokenExpiresAt?: SortOrder
    passwordResetTokenHash?: SortOrder
    passwordResetTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    emailVerifiedAt?: SortOrder
    emailVerifyTokenHash?: SortOrder
    emailVerifyTokenExpiresAt?: SortOrder
    passwordResetTokenHash?: SortOrder
    passwordResetTokenExpiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type UserRoleUserIdRoleIdCompoundUniqueInput = {
    userId: string
    roleId: string
  }

  export type UserRoleCountOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    userId?: SortOrder
    roleId?: SortOrder
  }

  export type EnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type EnumMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeFilter<$PrismaModel> | $Enums.MatchType
  }

  export type EnumFeeModeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeMode | EnumFeeModeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeModeFilter<$PrismaModel> | $Enums.FeeMode
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CourtSessionListRelationFilter = {
    every?: CourtSessionWhereInput
    some?: CourtSessionWhereInput
    none?: CourtSessionWhereInput
  }

  export type SessionPlayerListRelationFilter = {
    every?: SessionPlayerWhereInput
    some?: SessionPlayerWhereInput
    none?: SessionPlayerWhereInput
  }

  export type QueueEntryListRelationFilter = {
    every?: QueueEntryWhereInput
    some?: QueueEntryWhereInput
    none?: QueueEntryWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ShareLinkListRelationFilter = {
    every?: ShareLinkWhereInput
    some?: ShareLinkWhereInput
    none?: ShareLinkWhereInput
  }

  export type SessionShareLinkListRelationFilter = {
    every?: SessionShareLinkWhereInput
    some?: SessionShareLinkWhereInput
    none?: SessionShareLinkWhereInput
  }

  export type SessionInviteLinkListRelationFilter = {
    every?: SessionInviteLinkWhereInput
    some?: SessionInviteLinkWhereInput
    none?: SessionInviteLinkWhereInput
  }

  export type BracketOverrideListRelationFilter = {
    every?: BracketOverrideWhereInput
    some?: BracketOverrideWhereInput
    none?: BracketOverrideWhereInput
  }

  export type CourtSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QueueEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShareLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionShareLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionInviteLinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BracketOverrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    status?: SortOrder
    gameType?: SortOrder
    feeMode?: SortOrder
    feeAmount?: SortOrder
    defaultBracketType?: SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
    returnToQueue?: SortOrder
    announcements?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    feeAmount?: SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    status?: SortOrder
    gameType?: SortOrder
    feeMode?: SortOrder
    feeAmount?: SortOrder
    defaultBracketType?: SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
    returnToQueue?: SortOrder
    announcements?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    startsAt?: SortOrder
    endsAt?: SortOrder
    status?: SortOrder
    gameType?: SortOrder
    feeMode?: SortOrder
    feeAmount?: SortOrder
    defaultBracketType?: SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
    returnToQueue?: SortOrder
    announcements?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    closedAt?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    feeAmount?: SortOrder
    regularJoinLimit?: SortOrder
    newJoinerLimit?: SortOrder
  }

  export type EnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type EnumMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchTypeFilter<$PrismaModel>
  }

  export type EnumFeeModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeMode | EnumFeeModeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeModeWithAggregatesFilter<$PrismaModel> | $Enums.FeeMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeModeFilter<$PrismaModel>
    _max?: NestedEnumFeeModeFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SessionScalarRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type BracketOverrideSessionIdMatchIdBracketTypeMatchFormatCompoundUniqueInput = {
    sessionId: string
    matchId: string
    bracketType: string
    matchFormat: string
  }

  export type BracketOverrideCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    matchId?: SortOrder
    bracketType?: SortOrder
    matchFormat?: SortOrder
    winnerId?: SortOrder
    scoreJson?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BracketOverrideMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    matchId?: SortOrder
    bracketType?: SortOrder
    matchFormat?: SortOrder
    winnerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BracketOverrideMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    matchId?: SortOrder
    bracketType?: SortOrder
    matchFormat?: SortOrder
    winnerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type SessionInviteLinkCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionInviteLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionInviteLinkMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type CourtCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    active?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourtMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    active?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CourtMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    notes?: SortOrder
    active?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumCourtStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtStatus | EnumCourtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtStatusFilter<$PrismaModel> | $Enums.CourtStatus
  }

  export type CourtScalarRelationFilter = {
    is?: CourtWhereInput
    isNot?: CourtWhereInput
  }

  export type CourtSessionSessionIdCourtIdCompoundUniqueInput = {
    sessionId: string
    courtId: string
  }

  export type CourtSessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    currentMatchId?: SortOrder
    nextMatchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CourtSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    currentMatchId?: SortOrder
    nextMatchId?: SortOrder
    createdAt?: SortOrder
  }

  export type CourtSessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    currentMatchId?: SortOrder
    nextMatchId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCourtStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtStatus | EnumCourtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourtStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourtStatusFilter<$PrismaModel>
    _max?: NestedEnumCourtStatusFilter<$PrismaModel>
  }

  export type QueueEntryPlayerListRelationFilter = {
    every?: QueueEntryPlayerWhereInput
    some?: QueueEntryPlayerWhereInput
    none?: QueueEntryPlayerWhereInput
  }

  export type MatchParticipantListRelationFilter = {
    every?: MatchParticipantWhereInput
    some?: MatchParticipantWhereInput
    none?: MatchParticipantWhereInput
  }

  export type QueueEntryPlayerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlayerCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    nickname?: SortOrder
    skillLevel?: SortOrder
    contact?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    nickname?: SortOrder
    skillLevel?: SortOrder
    contact?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PlayerMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    nickname?: SortOrder
    skillLevel?: SortOrder
    contact?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumPlayerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusFilter<$PrismaModel> | $Enums.PlayerStatus
  }

  export type PlayerScalarRelationFilter = {
    is?: PlayerWhereInput
    isNot?: PlayerWhereInput
  }

  export type SessionPlayerSessionIdPlayerIdCompoundUniqueInput = {
    sessionId: string
    playerId: string
  }

  export type SessionPlayerCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    status?: SortOrder
    isNewPlayer?: SortOrder
    checkedInAt?: SortOrder
    lastPlayedAt?: SortOrder
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
  }

  export type SessionPlayerAvgOrderByAggregateInput = {
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
  }

  export type SessionPlayerMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    status?: SortOrder
    isNewPlayer?: SortOrder
    checkedInAt?: SortOrder
    lastPlayedAt?: SortOrder
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
  }

  export type SessionPlayerMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    status?: SortOrder
    isNewPlayer?: SortOrder
    checkedInAt?: SortOrder
    lastPlayedAt?: SortOrder
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
  }

  export type SessionPlayerSumOrderByAggregateInput = {
    gamesPlayed?: SortOrder
    wins?: SortOrder
    losses?: SortOrder
    totalQueueSeconds?: SortOrder
  }

  export type EnumPlayerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlayerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerStatusFilter<$PrismaModel>
    _max?: NestedEnumPlayerStatusFilter<$PrismaModel>
  }

  export type EnumQueueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeFilter<$PrismaModel> | $Enums.QueueType
  }

  export type EnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type QueueEntryCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    position?: SortOrder
    manualOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueEntryAvgOrderByAggregateInput = {
    position?: SortOrder
  }

  export type QueueEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    position?: SortOrder
    manualOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueEntryMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    position?: SortOrder
    manualOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QueueEntrySumOrderByAggregateInput = {
    position?: SortOrder
  }

  export type EnumQueueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeWithAggregatesFilter<$PrismaModel> | $Enums.QueueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueTypeFilter<$PrismaModel>
    _max?: NestedEnumQueueTypeFilter<$PrismaModel>
  }

  export type EnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type QueueEntryScalarRelationFilter = {
    is?: QueueEntryWhereInput
    isNot?: QueueEntryWhereInput
  }

  export type QueueEntryPlayerEntryIdPlayerIdCompoundUniqueInput = {
    entryId: string
    playerId: string
  }

  export type QueueEntryPlayerCountOrderByAggregateInput = {
    entryId?: SortOrder
    playerId?: SortOrder
  }

  export type QueueEntryPlayerMaxOrderByAggregateInput = {
    entryId?: SortOrder
    playerId?: SortOrder
  }

  export type QueueEntryPlayerMinOrderByAggregateInput = {
    entryId?: SortOrder
    playerId?: SortOrder
  }

  export type EnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MatchCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtSessionId?: SortOrder
    status?: SortOrder
    matchType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    scoreJson?: SortOrder
    winnerTeam?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    winnerTeam?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtSessionId?: SortOrder
    status?: SortOrder
    matchType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    winnerTeam?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    courtSessionId?: SortOrder
    status?: SortOrder
    matchType?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    winnerTeam?: SortOrder
    createdAt?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    winnerTeam?: SortOrder
  }

  export type EnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MatchScalarRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type MatchParticipantMatchIdPlayerIdCompoundUniqueInput = {
    matchId: string
    playerId: string
  }

  export type MatchParticipantCountOrderByAggregateInput = {
    matchId?: SortOrder
    playerId?: SortOrder
    teamNumber?: SortOrder
  }

  export type MatchParticipantAvgOrderByAggregateInput = {
    teamNumber?: SortOrder
  }

  export type MatchParticipantMaxOrderByAggregateInput = {
    matchId?: SortOrder
    playerId?: SortOrder
    teamNumber?: SortOrder
  }

  export type MatchParticipantMinOrderByAggregateInput = {
    matchId?: SortOrder
    playerId?: SortOrder
    teamNumber?: SortOrder
  }

  export type MatchParticipantSumOrderByAggregateInput = {
    teamNumber?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    amount?: SortOrder
    method?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ShareLinkCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ShareLinkMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    playerId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionShareLinkCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionShareLinkMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type SessionShareLinkMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    sessionId?: SortOrder
    revokedAt?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type UserRoleCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleNameFieldUpdateOperationsInput = {
    set?: $Enums.RoleName
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserRoleUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput> | UserRoleCreateWithoutRoleInput[] | UserRoleUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutRoleInput | UserRoleCreateOrConnectWithoutRoleInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutRoleInput | UserRoleUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserRoleCreateManyRoleInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutRoleInput | UserRoleUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutRoleInput | UserRoleUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SessionCreateWithoutCreatorInput, SessionUncheckedCreateWithoutCreatorInput> | SessionCreateWithoutCreatorInput[] | SessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCreatorInput | SessionCreateOrConnectWithoutCreatorInput[]
    createMany?: SessionCreateManyCreatorInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CourtCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourtCreateWithoutCreatorInput, CourtUncheckedCreateWithoutCreatorInput> | CourtCreateWithoutCreatorInput[] | CourtUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutCreatorInput | CourtCreateOrConnectWithoutCreatorInput[]
    createMany?: CourtCreateManyCreatorInputEnvelope
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type PlayerCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PlayerCreateWithoutCreatorInput, PlayerUncheckedCreateWithoutCreatorInput> | PlayerCreateWithoutCreatorInput[] | PlayerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCreatorInput | PlayerCreateOrConnectWithoutCreatorInput[]
    createMany?: PlayerCreateManyCreatorInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<SessionCreateWithoutCreatorInput, SessionUncheckedCreateWithoutCreatorInput> | SessionCreateWithoutCreatorInput[] | SessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCreatorInput | SessionCreateOrConnectWithoutCreatorInput[]
    createMany?: SessionCreateManyCreatorInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CourtUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<CourtCreateWithoutCreatorInput, CourtUncheckedCreateWithoutCreatorInput> | CourtCreateWithoutCreatorInput[] | CourtUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutCreatorInput | CourtCreateOrConnectWithoutCreatorInput[]
    createMany?: CourtCreateManyCreatorInputEnvelope
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type PlayerUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PlayerCreateWithoutCreatorInput, PlayerUncheckedCreateWithoutCreatorInput> | PlayerCreateWithoutCreatorInput[] | PlayerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCreatorInput | PlayerCreateOrConnectWithoutCreatorInput[]
    createMany?: PlayerCreateManyCreatorInputEnvelope
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserRoleUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SessionCreateWithoutCreatorInput, SessionUncheckedCreateWithoutCreatorInput> | SessionCreateWithoutCreatorInput[] | SessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCreatorInput | SessionCreateOrConnectWithoutCreatorInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCreatorInput | SessionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SessionCreateManyCreatorInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCreatorInput | SessionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCreatorInput | SessionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CourtUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourtCreateWithoutCreatorInput, CourtUncheckedCreateWithoutCreatorInput> | CourtCreateWithoutCreatorInput[] | CourtUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutCreatorInput | CourtCreateOrConnectWithoutCreatorInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutCreatorInput | CourtUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourtCreateManyCreatorInputEnvelope
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutCreatorInput | CourtUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutCreatorInput | CourtUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type PlayerUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PlayerCreateWithoutCreatorInput, PlayerUncheckedCreateWithoutCreatorInput> | PlayerCreateWithoutCreatorInput[] | PlayerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCreatorInput | PlayerCreateOrConnectWithoutCreatorInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutCreatorInput | PlayerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PlayerCreateManyCreatorInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutCreatorInput | PlayerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutCreatorInput | PlayerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput> | UserRoleCreateWithoutUserInput[] | UserRoleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUserInput | UserRoleCreateOrConnectWithoutUserInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUserInput | UserRoleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserRoleCreateManyUserInputEnvelope
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUserInput | UserRoleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUserInput | UserRoleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<SessionCreateWithoutCreatorInput, SessionUncheckedCreateWithoutCreatorInput> | SessionCreateWithoutCreatorInput[] | SessionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutCreatorInput | SessionCreateOrConnectWithoutCreatorInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutCreatorInput | SessionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: SessionCreateManyCreatorInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutCreatorInput | SessionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutCreatorInput | SessionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CourtUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<CourtCreateWithoutCreatorInput, CourtUncheckedCreateWithoutCreatorInput> | CourtCreateWithoutCreatorInput[] | CourtUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutCreatorInput | CourtCreateOrConnectWithoutCreatorInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutCreatorInput | CourtUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: CourtCreateManyCreatorInputEnvelope
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutCreatorInput | CourtUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutCreatorInput | CourtUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type PlayerUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PlayerCreateWithoutCreatorInput, PlayerUncheckedCreateWithoutCreatorInput> | PlayerCreateWithoutCreatorInput[] | PlayerUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PlayerCreateOrConnectWithoutCreatorInput | PlayerCreateOrConnectWithoutCreatorInput[]
    upsert?: PlayerUpsertWithWhereUniqueWithoutCreatorInput | PlayerUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PlayerCreateManyCreatorInputEnvelope
    set?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    disconnect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    delete?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    connect?: PlayerWhereUniqueInput | PlayerWhereUniqueInput[]
    update?: PlayerUpdateWithWhereUniqueWithoutCreatorInput | PlayerUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PlayerUpdateManyWithWhereWithoutCreatorInput | PlayerUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    connect?: UserWhereUniqueInput
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput
    upsert?: UserUpsertWithoutRolesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRolesInput, UserUpdateWithoutRolesInput>, UserUncheckedUpdateWithoutRolesInput>
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type CourtSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<CourtSessionCreateWithoutSessionInput, CourtSessionUncheckedCreateWithoutSessionInput> | CourtSessionCreateWithoutSessionInput[] | CourtSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutSessionInput | CourtSessionCreateOrConnectWithoutSessionInput[]
    createMany?: CourtSessionCreateManySessionInputEnvelope
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
  }

  export type SessionPlayerCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionPlayerCreateWithoutSessionInput, SessionPlayerUncheckedCreateWithoutSessionInput> | SessionPlayerCreateWithoutSessionInput[] | SessionPlayerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutSessionInput | SessionPlayerCreateOrConnectWithoutSessionInput[]
    createMany?: SessionPlayerCreateManySessionInputEnvelope
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
  }

  export type QueueEntryCreateNestedManyWithoutSessionInput = {
    create?: XOR<QueueEntryCreateWithoutSessionInput, QueueEntryUncheckedCreateWithoutSessionInput> | QueueEntryCreateWithoutSessionInput[] | QueueEntryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutSessionInput | QueueEntryCreateOrConnectWithoutSessionInput[]
    createMany?: QueueEntryCreateManySessionInputEnvelope
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutSessionInput = {
    create?: XOR<MatchCreateWithoutSessionInput, MatchUncheckedCreateWithoutSessionInput> | MatchCreateWithoutSessionInput[] | MatchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSessionInput | MatchCreateOrConnectWithoutSessionInput[]
    createMany?: MatchCreateManySessionInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutSessionInput = {
    create?: XOR<PaymentCreateWithoutSessionInput, PaymentUncheckedCreateWithoutSessionInput> | PaymentCreateWithoutSessionInput[] | PaymentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSessionInput | PaymentCreateOrConnectWithoutSessionInput[]
    createMany?: PaymentCreateManySessionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ShareLinkCreateNestedManyWithoutSessionInput = {
    create?: XOR<ShareLinkCreateWithoutSessionInput, ShareLinkUncheckedCreateWithoutSessionInput> | ShareLinkCreateWithoutSessionInput[] | ShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutSessionInput | ShareLinkCreateOrConnectWithoutSessionInput[]
    createMany?: ShareLinkCreateManySessionInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type SessionShareLinkCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionShareLinkCreateWithoutSessionInput, SessionShareLinkUncheckedCreateWithoutSessionInput> | SessionShareLinkCreateWithoutSessionInput[] | SessionShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionShareLinkCreateOrConnectWithoutSessionInput | SessionShareLinkCreateOrConnectWithoutSessionInput[]
    createMany?: SessionShareLinkCreateManySessionInputEnvelope
    connect?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
  }

  export type SessionInviteLinkCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionInviteLinkCreateWithoutSessionInput, SessionInviteLinkUncheckedCreateWithoutSessionInput> | SessionInviteLinkCreateWithoutSessionInput[] | SessionInviteLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionInviteLinkCreateOrConnectWithoutSessionInput | SessionInviteLinkCreateOrConnectWithoutSessionInput[]
    createMany?: SessionInviteLinkCreateManySessionInputEnvelope
    connect?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
  }

  export type BracketOverrideCreateNestedManyWithoutSessionInput = {
    create?: XOR<BracketOverrideCreateWithoutSessionInput, BracketOverrideUncheckedCreateWithoutSessionInput> | BracketOverrideCreateWithoutSessionInput[] | BracketOverrideUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BracketOverrideCreateOrConnectWithoutSessionInput | BracketOverrideCreateOrConnectWithoutSessionInput[]
    createMany?: BracketOverrideCreateManySessionInputEnvelope
    connect?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
  }

  export type CourtSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<CourtSessionCreateWithoutSessionInput, CourtSessionUncheckedCreateWithoutSessionInput> | CourtSessionCreateWithoutSessionInput[] | CourtSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutSessionInput | CourtSessionCreateOrConnectWithoutSessionInput[]
    createMany?: CourtSessionCreateManySessionInputEnvelope
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
  }

  export type SessionPlayerUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionPlayerCreateWithoutSessionInput, SessionPlayerUncheckedCreateWithoutSessionInput> | SessionPlayerCreateWithoutSessionInput[] | SessionPlayerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutSessionInput | SessionPlayerCreateOrConnectWithoutSessionInput[]
    createMany?: SessionPlayerCreateManySessionInputEnvelope
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
  }

  export type QueueEntryUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<QueueEntryCreateWithoutSessionInput, QueueEntryUncheckedCreateWithoutSessionInput> | QueueEntryCreateWithoutSessionInput[] | QueueEntryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutSessionInput | QueueEntryCreateOrConnectWithoutSessionInput[]
    createMany?: QueueEntryCreateManySessionInputEnvelope
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<MatchCreateWithoutSessionInput, MatchUncheckedCreateWithoutSessionInput> | MatchCreateWithoutSessionInput[] | MatchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSessionInput | MatchCreateOrConnectWithoutSessionInput[]
    createMany?: MatchCreateManySessionInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<PaymentCreateWithoutSessionInput, PaymentUncheckedCreateWithoutSessionInput> | PaymentCreateWithoutSessionInput[] | PaymentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSessionInput | PaymentCreateOrConnectWithoutSessionInput[]
    createMany?: PaymentCreateManySessionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ShareLinkUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<ShareLinkCreateWithoutSessionInput, ShareLinkUncheckedCreateWithoutSessionInput> | ShareLinkCreateWithoutSessionInput[] | ShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutSessionInput | ShareLinkCreateOrConnectWithoutSessionInput[]
    createMany?: ShareLinkCreateManySessionInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionShareLinkCreateWithoutSessionInput, SessionShareLinkUncheckedCreateWithoutSessionInput> | SessionShareLinkCreateWithoutSessionInput[] | SessionShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionShareLinkCreateOrConnectWithoutSessionInput | SessionShareLinkCreateOrConnectWithoutSessionInput[]
    createMany?: SessionShareLinkCreateManySessionInputEnvelope
    connect?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
  }

  export type SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionInviteLinkCreateWithoutSessionInput, SessionInviteLinkUncheckedCreateWithoutSessionInput> | SessionInviteLinkCreateWithoutSessionInput[] | SessionInviteLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionInviteLinkCreateOrConnectWithoutSessionInput | SessionInviteLinkCreateOrConnectWithoutSessionInput[]
    createMany?: SessionInviteLinkCreateManySessionInputEnvelope
    connect?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
  }

  export type BracketOverrideUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<BracketOverrideCreateWithoutSessionInput, BracketOverrideUncheckedCreateWithoutSessionInput> | BracketOverrideCreateWithoutSessionInput[] | BracketOverrideUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BracketOverrideCreateOrConnectWithoutSessionInput | BracketOverrideCreateOrConnectWithoutSessionInput[]
    createMany?: BracketOverrideCreateManySessionInputEnvelope
    connect?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
  }

  export type EnumSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SessionStatus
  }

  export type EnumMatchTypeFieldUpdateOperationsInput = {
    set?: $Enums.MatchType
  }

  export type EnumFeeModeFieldUpdateOperationsInput = {
    set?: $Enums.FeeMode
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type CourtSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CourtSessionCreateWithoutSessionInput, CourtSessionUncheckedCreateWithoutSessionInput> | CourtSessionCreateWithoutSessionInput[] | CourtSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutSessionInput | CourtSessionCreateOrConnectWithoutSessionInput[]
    upsert?: CourtSessionUpsertWithWhereUniqueWithoutSessionInput | CourtSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CourtSessionCreateManySessionInputEnvelope
    set?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    disconnect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    delete?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    update?: CourtSessionUpdateWithWhereUniqueWithoutSessionInput | CourtSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CourtSessionUpdateManyWithWhereWithoutSessionInput | CourtSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CourtSessionScalarWhereInput | CourtSessionScalarWhereInput[]
  }

  export type SessionPlayerUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionPlayerCreateWithoutSessionInput, SessionPlayerUncheckedCreateWithoutSessionInput> | SessionPlayerCreateWithoutSessionInput[] | SessionPlayerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutSessionInput | SessionPlayerCreateOrConnectWithoutSessionInput[]
    upsert?: SessionPlayerUpsertWithWhereUniqueWithoutSessionInput | SessionPlayerUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionPlayerCreateManySessionInputEnvelope
    set?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    disconnect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    delete?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    update?: SessionPlayerUpdateWithWhereUniqueWithoutSessionInput | SessionPlayerUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionPlayerUpdateManyWithWhereWithoutSessionInput | SessionPlayerUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionPlayerScalarWhereInput | SessionPlayerScalarWhereInput[]
  }

  export type QueueEntryUpdateManyWithoutSessionNestedInput = {
    create?: XOR<QueueEntryCreateWithoutSessionInput, QueueEntryUncheckedCreateWithoutSessionInput> | QueueEntryCreateWithoutSessionInput[] | QueueEntryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutSessionInput | QueueEntryCreateOrConnectWithoutSessionInput[]
    upsert?: QueueEntryUpsertWithWhereUniqueWithoutSessionInput | QueueEntryUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: QueueEntryCreateManySessionInputEnvelope
    set?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    disconnect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    delete?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    update?: QueueEntryUpdateWithWhereUniqueWithoutSessionInput | QueueEntryUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: QueueEntryUpdateManyWithWhereWithoutSessionInput | QueueEntryUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MatchCreateWithoutSessionInput, MatchUncheckedCreateWithoutSessionInput> | MatchCreateWithoutSessionInput[] | MatchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSessionInput | MatchCreateOrConnectWithoutSessionInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutSessionInput | MatchUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MatchCreateManySessionInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutSessionInput | MatchUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutSessionInput | MatchUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutSessionNestedInput = {
    create?: XOR<PaymentCreateWithoutSessionInput, PaymentUncheckedCreateWithoutSessionInput> | PaymentCreateWithoutSessionInput[] | PaymentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSessionInput | PaymentCreateOrConnectWithoutSessionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSessionInput | PaymentUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: PaymentCreateManySessionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSessionInput | PaymentUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSessionInput | PaymentUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ShareLinkUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ShareLinkCreateWithoutSessionInput, ShareLinkUncheckedCreateWithoutSessionInput> | ShareLinkCreateWithoutSessionInput[] | ShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutSessionInput | ShareLinkCreateOrConnectWithoutSessionInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutSessionInput | ShareLinkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ShareLinkCreateManySessionInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutSessionInput | ShareLinkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutSessionInput | ShareLinkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type SessionShareLinkUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionShareLinkCreateWithoutSessionInput, SessionShareLinkUncheckedCreateWithoutSessionInput> | SessionShareLinkCreateWithoutSessionInput[] | SessionShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionShareLinkCreateOrConnectWithoutSessionInput | SessionShareLinkCreateOrConnectWithoutSessionInput[]
    upsert?: SessionShareLinkUpsertWithWhereUniqueWithoutSessionInput | SessionShareLinkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionShareLinkCreateManySessionInputEnvelope
    set?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    disconnect?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    delete?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    connect?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    update?: SessionShareLinkUpdateWithWhereUniqueWithoutSessionInput | SessionShareLinkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionShareLinkUpdateManyWithWhereWithoutSessionInput | SessionShareLinkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionShareLinkScalarWhereInput | SessionShareLinkScalarWhereInput[]
  }

  export type SessionInviteLinkUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionInviteLinkCreateWithoutSessionInput, SessionInviteLinkUncheckedCreateWithoutSessionInput> | SessionInviteLinkCreateWithoutSessionInput[] | SessionInviteLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionInviteLinkCreateOrConnectWithoutSessionInput | SessionInviteLinkCreateOrConnectWithoutSessionInput[]
    upsert?: SessionInviteLinkUpsertWithWhereUniqueWithoutSessionInput | SessionInviteLinkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionInviteLinkCreateManySessionInputEnvelope
    set?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    disconnect?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    delete?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    connect?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    update?: SessionInviteLinkUpdateWithWhereUniqueWithoutSessionInput | SessionInviteLinkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionInviteLinkUpdateManyWithWhereWithoutSessionInput | SessionInviteLinkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionInviteLinkScalarWhereInput | SessionInviteLinkScalarWhereInput[]
  }

  export type BracketOverrideUpdateManyWithoutSessionNestedInput = {
    create?: XOR<BracketOverrideCreateWithoutSessionInput, BracketOverrideUncheckedCreateWithoutSessionInput> | BracketOverrideCreateWithoutSessionInput[] | BracketOverrideUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BracketOverrideCreateOrConnectWithoutSessionInput | BracketOverrideCreateOrConnectWithoutSessionInput[]
    upsert?: BracketOverrideUpsertWithWhereUniqueWithoutSessionInput | BracketOverrideUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: BracketOverrideCreateManySessionInputEnvelope
    set?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    disconnect?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    delete?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    connect?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    update?: BracketOverrideUpdateWithWhereUniqueWithoutSessionInput | BracketOverrideUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: BracketOverrideUpdateManyWithWhereWithoutSessionInput | BracketOverrideUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: BracketOverrideScalarWhereInput | BracketOverrideScalarWhereInput[]
  }

  export type CourtSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<CourtSessionCreateWithoutSessionInput, CourtSessionUncheckedCreateWithoutSessionInput> | CourtSessionCreateWithoutSessionInput[] | CourtSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutSessionInput | CourtSessionCreateOrConnectWithoutSessionInput[]
    upsert?: CourtSessionUpsertWithWhereUniqueWithoutSessionInput | CourtSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: CourtSessionCreateManySessionInputEnvelope
    set?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    disconnect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    delete?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    update?: CourtSessionUpdateWithWhereUniqueWithoutSessionInput | CourtSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: CourtSessionUpdateManyWithWhereWithoutSessionInput | CourtSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: CourtSessionScalarWhereInput | CourtSessionScalarWhereInput[]
  }

  export type SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionPlayerCreateWithoutSessionInput, SessionPlayerUncheckedCreateWithoutSessionInput> | SessionPlayerCreateWithoutSessionInput[] | SessionPlayerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutSessionInput | SessionPlayerCreateOrConnectWithoutSessionInput[]
    upsert?: SessionPlayerUpsertWithWhereUniqueWithoutSessionInput | SessionPlayerUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionPlayerCreateManySessionInputEnvelope
    set?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    disconnect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    delete?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    update?: SessionPlayerUpdateWithWhereUniqueWithoutSessionInput | SessionPlayerUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionPlayerUpdateManyWithWhereWithoutSessionInput | SessionPlayerUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionPlayerScalarWhereInput | SessionPlayerScalarWhereInput[]
  }

  export type QueueEntryUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<QueueEntryCreateWithoutSessionInput, QueueEntryUncheckedCreateWithoutSessionInput> | QueueEntryCreateWithoutSessionInput[] | QueueEntryUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: QueueEntryCreateOrConnectWithoutSessionInput | QueueEntryCreateOrConnectWithoutSessionInput[]
    upsert?: QueueEntryUpsertWithWhereUniqueWithoutSessionInput | QueueEntryUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: QueueEntryCreateManySessionInputEnvelope
    set?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    disconnect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    delete?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    connect?: QueueEntryWhereUniqueInput | QueueEntryWhereUniqueInput[]
    update?: QueueEntryUpdateWithWhereUniqueWithoutSessionInput | QueueEntryUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: QueueEntryUpdateManyWithWhereWithoutSessionInput | QueueEntryUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MatchCreateWithoutSessionInput, MatchUncheckedCreateWithoutSessionInput> | MatchCreateWithoutSessionInput[] | MatchUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutSessionInput | MatchCreateOrConnectWithoutSessionInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutSessionInput | MatchUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MatchCreateManySessionInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutSessionInput | MatchUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutSessionInput | MatchUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<PaymentCreateWithoutSessionInput, PaymentUncheckedCreateWithoutSessionInput> | PaymentCreateWithoutSessionInput[] | PaymentUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSessionInput | PaymentCreateOrConnectWithoutSessionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSessionInput | PaymentUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: PaymentCreateManySessionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSessionInput | PaymentUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSessionInput | PaymentUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ShareLinkUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<ShareLinkCreateWithoutSessionInput, ShareLinkUncheckedCreateWithoutSessionInput> | ShareLinkCreateWithoutSessionInput[] | ShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutSessionInput | ShareLinkCreateOrConnectWithoutSessionInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutSessionInput | ShareLinkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: ShareLinkCreateManySessionInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutSessionInput | ShareLinkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutSessionInput | ShareLinkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionShareLinkCreateWithoutSessionInput, SessionShareLinkUncheckedCreateWithoutSessionInput> | SessionShareLinkCreateWithoutSessionInput[] | SessionShareLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionShareLinkCreateOrConnectWithoutSessionInput | SessionShareLinkCreateOrConnectWithoutSessionInput[]
    upsert?: SessionShareLinkUpsertWithWhereUniqueWithoutSessionInput | SessionShareLinkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionShareLinkCreateManySessionInputEnvelope
    set?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    disconnect?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    delete?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    connect?: SessionShareLinkWhereUniqueInput | SessionShareLinkWhereUniqueInput[]
    update?: SessionShareLinkUpdateWithWhereUniqueWithoutSessionInput | SessionShareLinkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionShareLinkUpdateManyWithWhereWithoutSessionInput | SessionShareLinkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionShareLinkScalarWhereInput | SessionShareLinkScalarWhereInput[]
  }

  export type SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionInviteLinkCreateWithoutSessionInput, SessionInviteLinkUncheckedCreateWithoutSessionInput> | SessionInviteLinkCreateWithoutSessionInput[] | SessionInviteLinkUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionInviteLinkCreateOrConnectWithoutSessionInput | SessionInviteLinkCreateOrConnectWithoutSessionInput[]
    upsert?: SessionInviteLinkUpsertWithWhereUniqueWithoutSessionInput | SessionInviteLinkUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionInviteLinkCreateManySessionInputEnvelope
    set?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    disconnect?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    delete?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    connect?: SessionInviteLinkWhereUniqueInput | SessionInviteLinkWhereUniqueInput[]
    update?: SessionInviteLinkUpdateWithWhereUniqueWithoutSessionInput | SessionInviteLinkUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionInviteLinkUpdateManyWithWhereWithoutSessionInput | SessionInviteLinkUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionInviteLinkScalarWhereInput | SessionInviteLinkScalarWhereInput[]
  }

  export type BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<BracketOverrideCreateWithoutSessionInput, BracketOverrideUncheckedCreateWithoutSessionInput> | BracketOverrideCreateWithoutSessionInput[] | BracketOverrideUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: BracketOverrideCreateOrConnectWithoutSessionInput | BracketOverrideCreateOrConnectWithoutSessionInput[]
    upsert?: BracketOverrideUpsertWithWhereUniqueWithoutSessionInput | BracketOverrideUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: BracketOverrideCreateManySessionInputEnvelope
    set?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    disconnect?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    delete?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    connect?: BracketOverrideWhereUniqueInput | BracketOverrideWhereUniqueInput[]
    update?: BracketOverrideUpdateWithWhereUniqueWithoutSessionInput | BracketOverrideUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: BracketOverrideUpdateManyWithWhereWithoutSessionInput | BracketOverrideUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: BracketOverrideScalarWhereInput | BracketOverrideScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutBracketOverridesInput = {
    create?: XOR<SessionCreateWithoutBracketOverridesInput, SessionUncheckedCreateWithoutBracketOverridesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutBracketOverridesInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutBracketOverridesNestedInput = {
    create?: XOR<SessionCreateWithoutBracketOverridesInput, SessionUncheckedCreateWithoutBracketOverridesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutBracketOverridesInput
    upsert?: SessionUpsertWithoutBracketOverridesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutBracketOverridesInput, SessionUpdateWithoutBracketOverridesInput>, SessionUncheckedUpdateWithoutBracketOverridesInput>
  }

  export type SessionCreateNestedOneWithoutSessionInviteLinksInput = {
    create?: XOR<SessionCreateWithoutSessionInviteLinksInput, SessionUncheckedCreateWithoutSessionInviteLinksInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionInviteLinksInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionInviteLinksNestedInput = {
    create?: XOR<SessionCreateWithoutSessionInviteLinksInput, SessionUncheckedCreateWithoutSessionInviteLinksInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionInviteLinksInput
    upsert?: SessionUpsertWithoutSessionInviteLinksInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionInviteLinksInput, SessionUpdateWithoutSessionInviteLinksInput>, SessionUncheckedUpdateWithoutSessionInviteLinksInput>
  }

  export type UserCreateNestedOneWithoutCourtsInput = {
    create?: XOR<UserCreateWithoutCourtsInput, UserUncheckedCreateWithoutCourtsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourtsInput
    connect?: UserWhereUniqueInput
  }

  export type CourtSessionCreateNestedManyWithoutCourtInput = {
    create?: XOR<CourtSessionCreateWithoutCourtInput, CourtSessionUncheckedCreateWithoutCourtInput> | CourtSessionCreateWithoutCourtInput[] | CourtSessionUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutCourtInput | CourtSessionCreateOrConnectWithoutCourtInput[]
    createMany?: CourtSessionCreateManyCourtInputEnvelope
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
  }

  export type CourtSessionUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<CourtSessionCreateWithoutCourtInput, CourtSessionUncheckedCreateWithoutCourtInput> | CourtSessionCreateWithoutCourtInput[] | CourtSessionUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutCourtInput | CourtSessionCreateOrConnectWithoutCourtInput[]
    createMany?: CourtSessionCreateManyCourtInputEnvelope
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCourtsNestedInput = {
    create?: XOR<UserCreateWithoutCourtsInput, UserUncheckedCreateWithoutCourtsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCourtsInput
    upsert?: UserUpsertWithoutCourtsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCourtsInput, UserUpdateWithoutCourtsInput>, UserUncheckedUpdateWithoutCourtsInput>
  }

  export type CourtSessionUpdateManyWithoutCourtNestedInput = {
    create?: XOR<CourtSessionCreateWithoutCourtInput, CourtSessionUncheckedCreateWithoutCourtInput> | CourtSessionCreateWithoutCourtInput[] | CourtSessionUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutCourtInput | CourtSessionCreateOrConnectWithoutCourtInput[]
    upsert?: CourtSessionUpsertWithWhereUniqueWithoutCourtInput | CourtSessionUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: CourtSessionCreateManyCourtInputEnvelope
    set?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    disconnect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    delete?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    update?: CourtSessionUpdateWithWhereUniqueWithoutCourtInput | CourtSessionUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: CourtSessionUpdateManyWithWhereWithoutCourtInput | CourtSessionUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: CourtSessionScalarWhereInput | CourtSessionScalarWhereInput[]
  }

  export type CourtSessionUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<CourtSessionCreateWithoutCourtInput, CourtSessionUncheckedCreateWithoutCourtInput> | CourtSessionCreateWithoutCourtInput[] | CourtSessionUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: CourtSessionCreateOrConnectWithoutCourtInput | CourtSessionCreateOrConnectWithoutCourtInput[]
    upsert?: CourtSessionUpsertWithWhereUniqueWithoutCourtInput | CourtSessionUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: CourtSessionCreateManyCourtInputEnvelope
    set?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    disconnect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    delete?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    connect?: CourtSessionWhereUniqueInput | CourtSessionWhereUniqueInput[]
    update?: CourtSessionUpdateWithWhereUniqueWithoutCourtInput | CourtSessionUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: CourtSessionUpdateManyWithWhereWithoutCourtInput | CourtSessionUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: CourtSessionScalarWhereInput | CourtSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutCourtSessionsInput = {
    create?: XOR<SessionCreateWithoutCourtSessionsInput, SessionUncheckedCreateWithoutCourtSessionsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutCourtSessionsInput
    connect?: SessionWhereUniqueInput
  }

  export type CourtCreateNestedOneWithoutCourtSessionsInput = {
    create?: XOR<CourtCreateWithoutCourtSessionsInput, CourtUncheckedCreateWithoutCourtSessionsInput>
    connectOrCreate?: CourtCreateOrConnectWithoutCourtSessionsInput
    connect?: CourtWhereUniqueInput
  }

  export type EnumCourtStatusFieldUpdateOperationsInput = {
    set?: $Enums.CourtStatus
  }

  export type SessionUpdateOneRequiredWithoutCourtSessionsNestedInput = {
    create?: XOR<SessionCreateWithoutCourtSessionsInput, SessionUncheckedCreateWithoutCourtSessionsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutCourtSessionsInput
    upsert?: SessionUpsertWithoutCourtSessionsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutCourtSessionsInput, SessionUpdateWithoutCourtSessionsInput>, SessionUncheckedUpdateWithoutCourtSessionsInput>
  }

  export type CourtUpdateOneRequiredWithoutCourtSessionsNestedInput = {
    create?: XOR<CourtCreateWithoutCourtSessionsInput, CourtUncheckedCreateWithoutCourtSessionsInput>
    connectOrCreate?: CourtCreateOrConnectWithoutCourtSessionsInput
    upsert?: CourtUpsertWithoutCourtSessionsInput
    connect?: CourtWhereUniqueInput
    update?: XOR<XOR<CourtUpdateToOneWithWhereWithoutCourtSessionsInput, CourtUpdateWithoutCourtSessionsInput>, CourtUncheckedUpdateWithoutCourtSessionsInput>
  }

  export type UserCreateNestedOneWithoutPlayersInput = {
    create?: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayersInput
    connect?: UserWhereUniqueInput
  }

  export type SessionPlayerCreateNestedManyWithoutPlayerInput = {
    create?: XOR<SessionPlayerCreateWithoutPlayerInput, SessionPlayerUncheckedCreateWithoutPlayerInput> | SessionPlayerCreateWithoutPlayerInput[] | SessionPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutPlayerInput | SessionPlayerCreateOrConnectWithoutPlayerInput[]
    createMany?: SessionPlayerCreateManyPlayerInputEnvelope
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
  }

  export type QueueEntryPlayerCreateNestedManyWithoutPlayerInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutPlayerInput, QueueEntryPlayerUncheckedCreateWithoutPlayerInput> | QueueEntryPlayerCreateWithoutPlayerInput[] | QueueEntryPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutPlayerInput | QueueEntryPlayerCreateOrConnectWithoutPlayerInput[]
    createMany?: QueueEntryPlayerCreateManyPlayerInputEnvelope
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
  }

  export type MatchParticipantCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MatchParticipantCreateWithoutPlayerInput, MatchParticipantUncheckedCreateWithoutPlayerInput> | MatchParticipantCreateWithoutPlayerInput[] | MatchParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutPlayerInput | MatchParticipantCreateOrConnectWithoutPlayerInput[]
    createMany?: MatchParticipantCreateManyPlayerInputEnvelope
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PaymentCreateWithoutPlayerInput, PaymentUncheckedCreateWithoutPlayerInput> | PaymentCreateWithoutPlayerInput[] | PaymentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlayerInput | PaymentCreateOrConnectWithoutPlayerInput[]
    createMany?: PaymentCreateManyPlayerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ShareLinkCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ShareLinkCreateWithoutPlayerInput, ShareLinkUncheckedCreateWithoutPlayerInput> | ShareLinkCreateWithoutPlayerInput[] | ShareLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutPlayerInput | ShareLinkCreateOrConnectWithoutPlayerInput[]
    createMany?: ShareLinkCreateManyPlayerInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<SessionPlayerCreateWithoutPlayerInput, SessionPlayerUncheckedCreateWithoutPlayerInput> | SessionPlayerCreateWithoutPlayerInput[] | SessionPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutPlayerInput | SessionPlayerCreateOrConnectWithoutPlayerInput[]
    createMany?: SessionPlayerCreateManyPlayerInputEnvelope
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
  }

  export type QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutPlayerInput, QueueEntryPlayerUncheckedCreateWithoutPlayerInput> | QueueEntryPlayerCreateWithoutPlayerInput[] | QueueEntryPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutPlayerInput | QueueEntryPlayerCreateOrConnectWithoutPlayerInput[]
    createMany?: QueueEntryPlayerCreateManyPlayerInputEnvelope
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
  }

  export type MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<MatchParticipantCreateWithoutPlayerInput, MatchParticipantUncheckedCreateWithoutPlayerInput> | MatchParticipantCreateWithoutPlayerInput[] | MatchParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutPlayerInput | MatchParticipantCreateOrConnectWithoutPlayerInput[]
    createMany?: MatchParticipantCreateManyPlayerInputEnvelope
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<PaymentCreateWithoutPlayerInput, PaymentUncheckedCreateWithoutPlayerInput> | PaymentCreateWithoutPlayerInput[] | PaymentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlayerInput | PaymentCreateOrConnectWithoutPlayerInput[]
    createMany?: PaymentCreateManyPlayerInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ShareLinkUncheckedCreateNestedManyWithoutPlayerInput = {
    create?: XOR<ShareLinkCreateWithoutPlayerInput, ShareLinkUncheckedCreateWithoutPlayerInput> | ShareLinkCreateWithoutPlayerInput[] | ShareLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutPlayerInput | ShareLinkCreateOrConnectWithoutPlayerInput[]
    createMany?: ShareLinkCreateManyPlayerInputEnvelope
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutPlayersNestedInput = {
    create?: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlayersInput
    upsert?: UserUpsertWithoutPlayersInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlayersInput, UserUpdateWithoutPlayersInput>, UserUncheckedUpdateWithoutPlayersInput>
  }

  export type SessionPlayerUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<SessionPlayerCreateWithoutPlayerInput, SessionPlayerUncheckedCreateWithoutPlayerInput> | SessionPlayerCreateWithoutPlayerInput[] | SessionPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutPlayerInput | SessionPlayerCreateOrConnectWithoutPlayerInput[]
    upsert?: SessionPlayerUpsertWithWhereUniqueWithoutPlayerInput | SessionPlayerUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: SessionPlayerCreateManyPlayerInputEnvelope
    set?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    disconnect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    delete?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    update?: SessionPlayerUpdateWithWhereUniqueWithoutPlayerInput | SessionPlayerUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: SessionPlayerUpdateManyWithWhereWithoutPlayerInput | SessionPlayerUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: SessionPlayerScalarWhereInput | SessionPlayerScalarWhereInput[]
  }

  export type QueueEntryPlayerUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutPlayerInput, QueueEntryPlayerUncheckedCreateWithoutPlayerInput> | QueueEntryPlayerCreateWithoutPlayerInput[] | QueueEntryPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutPlayerInput | QueueEntryPlayerCreateOrConnectWithoutPlayerInput[]
    upsert?: QueueEntryPlayerUpsertWithWhereUniqueWithoutPlayerInput | QueueEntryPlayerUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: QueueEntryPlayerCreateManyPlayerInputEnvelope
    set?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    disconnect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    delete?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    update?: QueueEntryPlayerUpdateWithWhereUniqueWithoutPlayerInput | QueueEntryPlayerUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: QueueEntryPlayerUpdateManyWithWhereWithoutPlayerInput | QueueEntryPlayerUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: QueueEntryPlayerScalarWhereInput | QueueEntryPlayerScalarWhereInput[]
  }

  export type MatchParticipantUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MatchParticipantCreateWithoutPlayerInput, MatchParticipantUncheckedCreateWithoutPlayerInput> | MatchParticipantCreateWithoutPlayerInput[] | MatchParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutPlayerInput | MatchParticipantCreateOrConnectWithoutPlayerInput[]
    upsert?: MatchParticipantUpsertWithWhereUniqueWithoutPlayerInput | MatchParticipantUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MatchParticipantCreateManyPlayerInputEnvelope
    set?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    disconnect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    delete?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    update?: MatchParticipantUpdateWithWhereUniqueWithoutPlayerInput | MatchParticipantUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MatchParticipantUpdateManyWithWhereWithoutPlayerInput | MatchParticipantUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MatchParticipantScalarWhereInput | MatchParticipantScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PaymentCreateWithoutPlayerInput, PaymentUncheckedCreateWithoutPlayerInput> | PaymentCreateWithoutPlayerInput[] | PaymentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlayerInput | PaymentCreateOrConnectWithoutPlayerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPlayerInput | PaymentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PaymentCreateManyPlayerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPlayerInput | PaymentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPlayerInput | PaymentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ShareLinkUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ShareLinkCreateWithoutPlayerInput, ShareLinkUncheckedCreateWithoutPlayerInput> | ShareLinkCreateWithoutPlayerInput[] | ShareLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutPlayerInput | ShareLinkCreateOrConnectWithoutPlayerInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutPlayerInput | ShareLinkUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ShareLinkCreateManyPlayerInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutPlayerInput | ShareLinkUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutPlayerInput | ShareLinkUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<SessionPlayerCreateWithoutPlayerInput, SessionPlayerUncheckedCreateWithoutPlayerInput> | SessionPlayerCreateWithoutPlayerInput[] | SessionPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: SessionPlayerCreateOrConnectWithoutPlayerInput | SessionPlayerCreateOrConnectWithoutPlayerInput[]
    upsert?: SessionPlayerUpsertWithWhereUniqueWithoutPlayerInput | SessionPlayerUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: SessionPlayerCreateManyPlayerInputEnvelope
    set?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    disconnect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    delete?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    connect?: SessionPlayerWhereUniqueInput | SessionPlayerWhereUniqueInput[]
    update?: SessionPlayerUpdateWithWhereUniqueWithoutPlayerInput | SessionPlayerUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: SessionPlayerUpdateManyWithWhereWithoutPlayerInput | SessionPlayerUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: SessionPlayerScalarWhereInput | SessionPlayerScalarWhereInput[]
  }

  export type QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutPlayerInput, QueueEntryPlayerUncheckedCreateWithoutPlayerInput> | QueueEntryPlayerCreateWithoutPlayerInput[] | QueueEntryPlayerUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutPlayerInput | QueueEntryPlayerCreateOrConnectWithoutPlayerInput[]
    upsert?: QueueEntryPlayerUpsertWithWhereUniqueWithoutPlayerInput | QueueEntryPlayerUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: QueueEntryPlayerCreateManyPlayerInputEnvelope
    set?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    disconnect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    delete?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    update?: QueueEntryPlayerUpdateWithWhereUniqueWithoutPlayerInput | QueueEntryPlayerUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: QueueEntryPlayerUpdateManyWithWhereWithoutPlayerInput | QueueEntryPlayerUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: QueueEntryPlayerScalarWhereInput | QueueEntryPlayerScalarWhereInput[]
  }

  export type MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<MatchParticipantCreateWithoutPlayerInput, MatchParticipantUncheckedCreateWithoutPlayerInput> | MatchParticipantCreateWithoutPlayerInput[] | MatchParticipantUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutPlayerInput | MatchParticipantCreateOrConnectWithoutPlayerInput[]
    upsert?: MatchParticipantUpsertWithWhereUniqueWithoutPlayerInput | MatchParticipantUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: MatchParticipantCreateManyPlayerInputEnvelope
    set?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    disconnect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    delete?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    update?: MatchParticipantUpdateWithWhereUniqueWithoutPlayerInput | MatchParticipantUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: MatchParticipantUpdateManyWithWhereWithoutPlayerInput | MatchParticipantUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: MatchParticipantScalarWhereInput | MatchParticipantScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<PaymentCreateWithoutPlayerInput, PaymentUncheckedCreateWithoutPlayerInput> | PaymentCreateWithoutPlayerInput[] | PaymentUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPlayerInput | PaymentCreateOrConnectWithoutPlayerInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPlayerInput | PaymentUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: PaymentCreateManyPlayerInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPlayerInput | PaymentUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPlayerInput | PaymentUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput = {
    create?: XOR<ShareLinkCreateWithoutPlayerInput, ShareLinkUncheckedCreateWithoutPlayerInput> | ShareLinkCreateWithoutPlayerInput[] | ShareLinkUncheckedCreateWithoutPlayerInput[]
    connectOrCreate?: ShareLinkCreateOrConnectWithoutPlayerInput | ShareLinkCreateOrConnectWithoutPlayerInput[]
    upsert?: ShareLinkUpsertWithWhereUniqueWithoutPlayerInput | ShareLinkUpsertWithWhereUniqueWithoutPlayerInput[]
    createMany?: ShareLinkCreateManyPlayerInputEnvelope
    set?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    disconnect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    delete?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    connect?: ShareLinkWhereUniqueInput | ShareLinkWhereUniqueInput[]
    update?: ShareLinkUpdateWithWhereUniqueWithoutPlayerInput | ShareLinkUpdateWithWhereUniqueWithoutPlayerInput[]
    updateMany?: ShareLinkUpdateManyWithWhereWithoutPlayerInput | ShareLinkUpdateManyWithWhereWithoutPlayerInput[]
    deleteMany?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionPlayersInput = {
    create?: XOR<SessionCreateWithoutSessionPlayersInput, SessionUncheckedCreateWithoutSessionPlayersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionPlayersInput
    connect?: SessionWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutSessionPlayersInput = {
    create?: XOR<PlayerCreateWithoutSessionPlayersInput, PlayerUncheckedCreateWithoutSessionPlayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSessionPlayersInput
    connect?: PlayerWhereUniqueInput
  }

  export type EnumPlayerStatusFieldUpdateOperationsInput = {
    set?: $Enums.PlayerStatus
  }

  export type SessionUpdateOneRequiredWithoutSessionPlayersNestedInput = {
    create?: XOR<SessionCreateWithoutSessionPlayersInput, SessionUncheckedCreateWithoutSessionPlayersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionPlayersInput
    upsert?: SessionUpsertWithoutSessionPlayersInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionPlayersInput, SessionUpdateWithoutSessionPlayersInput>, SessionUncheckedUpdateWithoutSessionPlayersInput>
  }

  export type PlayerUpdateOneRequiredWithoutSessionPlayersNestedInput = {
    create?: XOR<PlayerCreateWithoutSessionPlayersInput, PlayerUncheckedCreateWithoutSessionPlayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutSessionPlayersInput
    upsert?: PlayerUpsertWithoutSessionPlayersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutSessionPlayersInput, PlayerUpdateWithoutSessionPlayersInput>, PlayerUncheckedUpdateWithoutSessionPlayersInput>
  }

  export type SessionCreateNestedOneWithoutQueueEntriesInput = {
    create?: XOR<SessionCreateWithoutQueueEntriesInput, SessionUncheckedCreateWithoutQueueEntriesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutQueueEntriesInput
    connect?: SessionWhereUniqueInput
  }

  export type QueueEntryPlayerCreateNestedManyWithoutEntryInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutEntryInput, QueueEntryPlayerUncheckedCreateWithoutEntryInput> | QueueEntryPlayerCreateWithoutEntryInput[] | QueueEntryPlayerUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutEntryInput | QueueEntryPlayerCreateOrConnectWithoutEntryInput[]
    createMany?: QueueEntryPlayerCreateManyEntryInputEnvelope
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
  }

  export type QueueEntryPlayerUncheckedCreateNestedManyWithoutEntryInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutEntryInput, QueueEntryPlayerUncheckedCreateWithoutEntryInput> | QueueEntryPlayerCreateWithoutEntryInput[] | QueueEntryPlayerUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutEntryInput | QueueEntryPlayerCreateOrConnectWithoutEntryInput[]
    createMany?: QueueEntryPlayerCreateManyEntryInputEnvelope
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
  }

  export type EnumQueueTypeFieldUpdateOperationsInput = {
    set?: $Enums.QueueType
  }

  export type EnumQueueStatusFieldUpdateOperationsInput = {
    set?: $Enums.QueueStatus
  }

  export type SessionUpdateOneRequiredWithoutQueueEntriesNestedInput = {
    create?: XOR<SessionCreateWithoutQueueEntriesInput, SessionUncheckedCreateWithoutQueueEntriesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutQueueEntriesInput
    upsert?: SessionUpsertWithoutQueueEntriesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutQueueEntriesInput, SessionUpdateWithoutQueueEntriesInput>, SessionUncheckedUpdateWithoutQueueEntriesInput>
  }

  export type QueueEntryPlayerUpdateManyWithoutEntryNestedInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutEntryInput, QueueEntryPlayerUncheckedCreateWithoutEntryInput> | QueueEntryPlayerCreateWithoutEntryInput[] | QueueEntryPlayerUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutEntryInput | QueueEntryPlayerCreateOrConnectWithoutEntryInput[]
    upsert?: QueueEntryPlayerUpsertWithWhereUniqueWithoutEntryInput | QueueEntryPlayerUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: QueueEntryPlayerCreateManyEntryInputEnvelope
    set?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    disconnect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    delete?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    update?: QueueEntryPlayerUpdateWithWhereUniqueWithoutEntryInput | QueueEntryPlayerUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: QueueEntryPlayerUpdateManyWithWhereWithoutEntryInput | QueueEntryPlayerUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: QueueEntryPlayerScalarWhereInput | QueueEntryPlayerScalarWhereInput[]
  }

  export type QueueEntryPlayerUncheckedUpdateManyWithoutEntryNestedInput = {
    create?: XOR<QueueEntryPlayerCreateWithoutEntryInput, QueueEntryPlayerUncheckedCreateWithoutEntryInput> | QueueEntryPlayerCreateWithoutEntryInput[] | QueueEntryPlayerUncheckedCreateWithoutEntryInput[]
    connectOrCreate?: QueueEntryPlayerCreateOrConnectWithoutEntryInput | QueueEntryPlayerCreateOrConnectWithoutEntryInput[]
    upsert?: QueueEntryPlayerUpsertWithWhereUniqueWithoutEntryInput | QueueEntryPlayerUpsertWithWhereUniqueWithoutEntryInput[]
    createMany?: QueueEntryPlayerCreateManyEntryInputEnvelope
    set?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    disconnect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    delete?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    connect?: QueueEntryPlayerWhereUniqueInput | QueueEntryPlayerWhereUniqueInput[]
    update?: QueueEntryPlayerUpdateWithWhereUniqueWithoutEntryInput | QueueEntryPlayerUpdateWithWhereUniqueWithoutEntryInput[]
    updateMany?: QueueEntryPlayerUpdateManyWithWhereWithoutEntryInput | QueueEntryPlayerUpdateManyWithWhereWithoutEntryInput[]
    deleteMany?: QueueEntryPlayerScalarWhereInput | QueueEntryPlayerScalarWhereInput[]
  }

  export type QueueEntryCreateNestedOneWithoutPlayersInput = {
    create?: XOR<QueueEntryCreateWithoutPlayersInput, QueueEntryUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: QueueEntryCreateOrConnectWithoutPlayersInput
    connect?: QueueEntryWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutQueueEntryPlayersInput = {
    create?: XOR<PlayerCreateWithoutQueueEntryPlayersInput, PlayerUncheckedCreateWithoutQueueEntryPlayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutQueueEntryPlayersInput
    connect?: PlayerWhereUniqueInput
  }

  export type QueueEntryUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<QueueEntryCreateWithoutPlayersInput, QueueEntryUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: QueueEntryCreateOrConnectWithoutPlayersInput
    upsert?: QueueEntryUpsertWithoutPlayersInput
    connect?: QueueEntryWhereUniqueInput
    update?: XOR<XOR<QueueEntryUpdateToOneWithWhereWithoutPlayersInput, QueueEntryUpdateWithoutPlayersInput>, QueueEntryUncheckedUpdateWithoutPlayersInput>
  }

  export type PlayerUpdateOneRequiredWithoutQueueEntryPlayersNestedInput = {
    create?: XOR<PlayerCreateWithoutQueueEntryPlayersInput, PlayerUncheckedCreateWithoutQueueEntryPlayersInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutQueueEntryPlayersInput
    upsert?: PlayerUpsertWithoutQueueEntryPlayersInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutQueueEntryPlayersInput, PlayerUpdateWithoutQueueEntryPlayersInput>, PlayerUncheckedUpdateWithoutQueueEntryPlayersInput>
  }

  export type SessionCreateNestedOneWithoutMatchesInput = {
    create?: XOR<SessionCreateWithoutMatchesInput, SessionUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutMatchesInput
    connect?: SessionWhereUniqueInput
  }

  export type MatchParticipantCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchParticipantCreateWithoutMatchInput, MatchParticipantUncheckedCreateWithoutMatchInput> | MatchParticipantCreateWithoutMatchInput[] | MatchParticipantUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutMatchInput | MatchParticipantCreateOrConnectWithoutMatchInput[]
    createMany?: MatchParticipantCreateManyMatchInputEnvelope
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
  }

  export type MatchParticipantUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<MatchParticipantCreateWithoutMatchInput, MatchParticipantUncheckedCreateWithoutMatchInput> | MatchParticipantCreateWithoutMatchInput[] | MatchParticipantUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutMatchInput | MatchParticipantCreateOrConnectWithoutMatchInput[]
    createMany?: MatchParticipantCreateManyMatchInputEnvelope
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
  }

  export type EnumMatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.MatchStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<SessionCreateWithoutMatchesInput, SessionUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutMatchesInput
    upsert?: SessionUpsertWithoutMatchesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutMatchesInput, SessionUpdateWithoutMatchesInput>, SessionUncheckedUpdateWithoutMatchesInput>
  }

  export type MatchParticipantUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchParticipantCreateWithoutMatchInput, MatchParticipantUncheckedCreateWithoutMatchInput> | MatchParticipantCreateWithoutMatchInput[] | MatchParticipantUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutMatchInput | MatchParticipantCreateOrConnectWithoutMatchInput[]
    upsert?: MatchParticipantUpsertWithWhereUniqueWithoutMatchInput | MatchParticipantUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchParticipantCreateManyMatchInputEnvelope
    set?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    disconnect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    delete?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    update?: MatchParticipantUpdateWithWhereUniqueWithoutMatchInput | MatchParticipantUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchParticipantUpdateManyWithWhereWithoutMatchInput | MatchParticipantUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchParticipantScalarWhereInput | MatchParticipantScalarWhereInput[]
  }

  export type MatchParticipantUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<MatchParticipantCreateWithoutMatchInput, MatchParticipantUncheckedCreateWithoutMatchInput> | MatchParticipantCreateWithoutMatchInput[] | MatchParticipantUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: MatchParticipantCreateOrConnectWithoutMatchInput | MatchParticipantCreateOrConnectWithoutMatchInput[]
    upsert?: MatchParticipantUpsertWithWhereUniqueWithoutMatchInput | MatchParticipantUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: MatchParticipantCreateManyMatchInputEnvelope
    set?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    disconnect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    delete?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    connect?: MatchParticipantWhereUniqueInput | MatchParticipantWhereUniqueInput[]
    update?: MatchParticipantUpdateWithWhereUniqueWithoutMatchInput | MatchParticipantUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: MatchParticipantUpdateManyWithWhereWithoutMatchInput | MatchParticipantUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: MatchParticipantScalarWhereInput | MatchParticipantScalarWhereInput[]
  }

  export type MatchCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutParticipantsInput
    connect?: MatchWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutMatchParticipantsInput = {
    create?: XOR<PlayerCreateWithoutMatchParticipantsInput, PlayerUncheckedCreateWithoutMatchParticipantsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMatchParticipantsInput
    connect?: PlayerWhereUniqueInput
  }

  export type MatchUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutParticipantsInput
    upsert?: MatchUpsertWithoutParticipantsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutParticipantsInput, MatchUpdateWithoutParticipantsInput>, MatchUncheckedUpdateWithoutParticipantsInput>
  }

  export type PlayerUpdateOneRequiredWithoutMatchParticipantsNestedInput = {
    create?: XOR<PlayerCreateWithoutMatchParticipantsInput, PlayerUncheckedCreateWithoutMatchParticipantsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutMatchParticipantsInput
    upsert?: PlayerUpsertWithoutMatchParticipantsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutMatchParticipantsInput, PlayerUpdateWithoutMatchParticipantsInput>, PlayerUncheckedUpdateWithoutMatchParticipantsInput>
  }

  export type SessionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SessionCreateWithoutPaymentsInput, SessionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutPaymentsInput
    connect?: SessionWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PlayerCreateWithoutPaymentsInput, PlayerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPaymentsInput
    connect?: PlayerWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SessionCreateWithoutPaymentsInput, SessionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutPaymentsInput
    upsert?: SessionUpsertWithoutPaymentsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutPaymentsInput, SessionUpdateWithoutPaymentsInput>, SessionUncheckedUpdateWithoutPaymentsInput>
  }

  export type PlayerUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PlayerCreateWithoutPaymentsInput, PlayerUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutPaymentsInput
    upsert?: PlayerUpsertWithoutPaymentsInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutPaymentsInput, PlayerUpdateWithoutPaymentsInput>, PlayerUncheckedUpdateWithoutPaymentsInput>
  }

  export type SessionCreateNestedOneWithoutShareLinksInput = {
    create?: XOR<SessionCreateWithoutShareLinksInput, SessionUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: SessionCreateOrConnectWithoutShareLinksInput
    connect?: SessionWhereUniqueInput
  }

  export type PlayerCreateNestedOneWithoutShareLinksInput = {
    create?: XOR<PlayerCreateWithoutShareLinksInput, PlayerUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutShareLinksInput
    connect?: PlayerWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutShareLinksNestedInput = {
    create?: XOR<SessionCreateWithoutShareLinksInput, SessionUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: SessionCreateOrConnectWithoutShareLinksInput
    upsert?: SessionUpsertWithoutShareLinksInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutShareLinksInput, SessionUpdateWithoutShareLinksInput>, SessionUncheckedUpdateWithoutShareLinksInput>
  }

  export type PlayerUpdateOneRequiredWithoutShareLinksNestedInput = {
    create?: XOR<PlayerCreateWithoutShareLinksInput, PlayerUncheckedCreateWithoutShareLinksInput>
    connectOrCreate?: PlayerCreateOrConnectWithoutShareLinksInput
    upsert?: PlayerUpsertWithoutShareLinksInput
    connect?: PlayerWhereUniqueInput
    update?: XOR<XOR<PlayerUpdateToOneWithWhereWithoutShareLinksInput, PlayerUpdateWithoutShareLinksInput>, PlayerUncheckedUpdateWithoutShareLinksInput>
  }

  export type SessionCreateNestedOneWithoutSessionShareLinksInput = {
    create?: XOR<SessionCreateWithoutSessionShareLinksInput, SessionUncheckedCreateWithoutSessionShareLinksInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionShareLinksInput
    connect?: SessionWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionShareLinksNestedInput = {
    create?: XOR<SessionCreateWithoutSessionShareLinksInput, SessionUncheckedCreateWithoutSessionShareLinksInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionShareLinksInput
    upsert?: SessionUpsertWithoutSessionShareLinksInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionShareLinksInput, SessionUpdateWithoutSessionShareLinksInput>, SessionUncheckedUpdateWithoutSessionShareLinksInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleNameFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameFilter<$PrismaModel> | $Enums.RoleName
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleNameWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoleName | EnumRoleNameFieldRefInput<$PrismaModel>
    in?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoleName[] | ListEnumRoleNameFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleNameWithAggregatesFilter<$PrismaModel> | $Enums.RoleName
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleNameFilter<$PrismaModel>
    _max?: NestedEnumRoleNameFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusFilter<$PrismaModel> | $Enums.SessionStatus
  }

  export type NestedEnumMatchTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeFilter<$PrismaModel> | $Enums.MatchType
  }

  export type NestedEnumFeeModeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeMode | EnumFeeModeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeModeFilter<$PrismaModel> | $Enums.FeeMode
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SessionStatus | EnumSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SessionStatus[] | ListEnumSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchType | EnumMatchTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchType[] | ListEnumMatchTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchTypeWithAggregatesFilter<$PrismaModel> | $Enums.MatchType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchTypeFilter<$PrismaModel>
    _max?: NestedEnumMatchTypeFilter<$PrismaModel>
  }

  export type NestedEnumFeeModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeMode | EnumFeeModeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeMode[] | ListEnumFeeModeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeModeWithAggregatesFilter<$PrismaModel> | $Enums.FeeMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeModeFilter<$PrismaModel>
    _max?: NestedEnumFeeModeFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumCourtStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtStatus | EnumCourtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtStatusFilter<$PrismaModel> | $Enums.CourtStatus
  }

  export type NestedEnumCourtStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CourtStatus | EnumCourtStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CourtStatus[] | ListEnumCourtStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCourtStatusWithAggregatesFilter<$PrismaModel> | $Enums.CourtStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCourtStatusFilter<$PrismaModel>
    _max?: NestedEnumCourtStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlayerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusFilter<$PrismaModel> | $Enums.PlayerStatus
  }

  export type NestedEnumPlayerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlayerStatus | EnumPlayerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlayerStatus[] | ListEnumPlayerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPlayerStatusWithAggregatesFilter<$PrismaModel> | $Enums.PlayerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlayerStatusFilter<$PrismaModel>
    _max?: NestedEnumPlayerStatusFilter<$PrismaModel>
  }

  export type NestedEnumQueueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeFilter<$PrismaModel> | $Enums.QueueType
  }

  export type NestedEnumQueueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusFilter<$PrismaModel> | $Enums.QueueStatus
  }

  export type NestedEnumQueueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueType | EnumQueueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueType[] | ListEnumQueueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueTypeWithAggregatesFilter<$PrismaModel> | $Enums.QueueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueTypeFilter<$PrismaModel>
    _max?: NestedEnumQueueTypeFilter<$PrismaModel>
  }

  export type NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QueueStatus | EnumQueueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QueueStatus[] | ListEnumQueueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQueueStatusWithAggregatesFilter<$PrismaModel> | $Enums.QueueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQueueStatusFilter<$PrismaModel>
    _max?: NestedEnumQueueStatusFilter<$PrismaModel>
  }

  export type NestedEnumMatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusFilter<$PrismaModel> | $Enums.MatchStatus
  }

  export type NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MatchStatus | EnumMatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MatchStatus[] | ListEnumMatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.MatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMatchStatusFilter<$PrismaModel>
    _max?: NestedEnumMatchStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserRoleCreateWithoutRoleInput = {
    user: UserCreateNestedOneWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutRoleInput = {
    userId: string
  }

  export type UserRoleCreateOrConnectWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleCreateManyRoleInputEnvelope = {
    data: UserRoleCreateManyRoleInput | UserRoleCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
    create: XOR<UserRoleCreateWithoutRoleInput, UserRoleUncheckedCreateWithoutRoleInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutRoleInput, UserRoleUncheckedUpdateWithoutRoleInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutRoleInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    userId?: UuidFilter<"UserRole"> | string
    roleId?: UuidFilter<"UserRole"> | string
  }

  export type UserRoleCreateWithoutUserInput = {
    role: RoleCreateNestedOneWithoutUsersInput
  }

  export type UserRoleUncheckedCreateWithoutUserInput = {
    roleId: string
  }

  export type UserRoleCreateOrConnectWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleCreateManyUserInputEnvelope = {
    data: UserRoleCreateManyUserInput | UserRoleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutCreatorInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutCreatorInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCreatorInput, SessionUncheckedCreateWithoutCreatorInput>
  }

  export type SessionCreateManyCreatorInputEnvelope = {
    data: SessionCreateManyCreatorInput | SessionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CourtCreateWithoutCreatorInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    courtSessions?: CourtSessionCreateNestedManyWithoutCourtInput
  }

  export type CourtUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutCourtInput
  }

  export type CourtCreateOrConnectWithoutCreatorInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutCreatorInput, CourtUncheckedCreateWithoutCreatorInput>
  }

  export type CourtCreateManyCreatorInputEnvelope = {
    data: CourtCreateManyCreatorInput | CourtCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type PlayerCreateWithoutCreatorInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantCreateNestedManyWithoutPlayerInput
    payments?: PaymentCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutCreatorInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutCreatorInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutCreatorInput, PlayerUncheckedCreateWithoutCreatorInput>
  }

  export type PlayerCreateManyCreatorInputEnvelope = {
    data: PlayerCreateManyCreatorInput | PlayerCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
    create: XOR<UserRoleCreateWithoutUserInput, UserRoleUncheckedCreateWithoutUserInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUserInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUserInput, UserRoleUncheckedUpdateWithoutUserInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUserInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutCreatorInput, SessionUncheckedUpdateWithoutCreatorInput>
    create: XOR<SessionCreateWithoutCreatorInput, SessionUncheckedCreateWithoutCreatorInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutCreatorInput, SessionUncheckedUpdateWithoutCreatorInput>
  }

  export type SessionUpdateManyWithWhereWithoutCreatorInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: UuidFilter<"Session"> | string
    name?: StringFilter<"Session"> | string
    startsAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    endsAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    status?: EnumSessionStatusFilter<"Session"> | $Enums.SessionStatus
    gameType?: EnumMatchTypeFilter<"Session"> | $Enums.MatchType
    feeMode?: EnumFeeModeFilter<"Session"> | $Enums.FeeMode
    feeAmount?: DecimalFilter<"Session"> | Decimal | DecimalJsLike | number | string
    defaultBracketType?: StringNullableFilter<"Session"> | string | null
    regularJoinLimit?: IntFilter<"Session"> | number
    newJoinerLimit?: IntFilter<"Session"> | number
    returnToQueue?: BoolFilter<"Session"> | boolean
    announcements?: StringNullableFilter<"Session"> | string | null
    createdBy?: UuidNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    closedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type CourtUpsertWithWhereUniqueWithoutCreatorInput = {
    where: CourtWhereUniqueInput
    update: XOR<CourtUpdateWithoutCreatorInput, CourtUncheckedUpdateWithoutCreatorInput>
    create: XOR<CourtCreateWithoutCreatorInput, CourtUncheckedCreateWithoutCreatorInput>
  }

  export type CourtUpdateWithWhereUniqueWithoutCreatorInput = {
    where: CourtWhereUniqueInput
    data: XOR<CourtUpdateWithoutCreatorInput, CourtUncheckedUpdateWithoutCreatorInput>
  }

  export type CourtUpdateManyWithWhereWithoutCreatorInput = {
    where: CourtScalarWhereInput
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyWithoutCreatorInput>
  }

  export type CourtScalarWhereInput = {
    AND?: CourtScalarWhereInput | CourtScalarWhereInput[]
    OR?: CourtScalarWhereInput[]
    NOT?: CourtScalarWhereInput | CourtScalarWhereInput[]
    id?: UuidFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    notes?: StringNullableFilter<"Court"> | string | null
    active?: BoolFilter<"Court"> | boolean
    createdBy?: UuidNullableFilter<"Court"> | string | null
    createdAt?: DateTimeFilter<"Court"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Court"> | Date | string | null
  }

  export type PlayerUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PlayerWhereUniqueInput
    update: XOR<PlayerUpdateWithoutCreatorInput, PlayerUncheckedUpdateWithoutCreatorInput>
    create: XOR<PlayerCreateWithoutCreatorInput, PlayerUncheckedCreateWithoutCreatorInput>
  }

  export type PlayerUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PlayerWhereUniqueInput
    data: XOR<PlayerUpdateWithoutCreatorInput, PlayerUncheckedUpdateWithoutCreatorInput>
  }

  export type PlayerUpdateManyWithWhereWithoutCreatorInput = {
    where: PlayerScalarWhereInput
    data: XOR<PlayerUpdateManyMutationInput, PlayerUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PlayerScalarWhereInput = {
    AND?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    OR?: PlayerScalarWhereInput[]
    NOT?: PlayerScalarWhereInput | PlayerScalarWhereInput[]
    id?: UuidFilter<"Player"> | string
    fullName?: StringFilter<"Player"> | string
    nickname?: StringNullableFilter<"Player"> | string | null
    skillLevel?: StringNullableFilter<"Player"> | string | null
    contact?: StringNullableFilter<"Player"> | string | null
    createdBy?: UuidNullableFilter<"Player"> | string | null
    createdAt?: DateTimeFilter<"Player"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Player"> | Date | string | null
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutCreatorInput
    courts?: CourtCreateNestedManyWithoutCreatorInput
    players?: PlayerCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutCreatorInput
    courts?: CourtUncheckedCreateNestedManyWithoutCreatorInput
    players?: PlayerUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: $Enums.RoleName
    createdAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: $Enums.RoleName
    createdAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutRolesInput = {
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRolesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutCreatorNestedInput
    courts?: CourtUpdateManyWithoutCreatorNestedInput
    players?: PlayerUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutCreatorNestedInput
    courts?: CourtUncheckedUpdateManyWithoutCreatorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: EnumRoleNameFieldUpdateOperationsInput | $Enums.RoleName
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    courts?: CourtCreateNestedManyWithoutCreatorInput
    players?: PlayerCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    courts?: CourtUncheckedCreateNestedManyWithoutCreatorInput
    players?: PlayerUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type CourtSessionCreateWithoutSessionInput = {
    id?: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
    court: CourtCreateNestedOneWithoutCourtSessionsInput
  }

  export type CourtSessionUncheckedCreateWithoutSessionInput = {
    id?: string
    courtId: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
  }

  export type CourtSessionCreateOrConnectWithoutSessionInput = {
    where: CourtSessionWhereUniqueInput
    create: XOR<CourtSessionCreateWithoutSessionInput, CourtSessionUncheckedCreateWithoutSessionInput>
  }

  export type CourtSessionCreateManySessionInputEnvelope = {
    data: CourtSessionCreateManySessionInput | CourtSessionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionPlayerCreateWithoutSessionInput = {
    id?: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
    player: PlayerCreateNestedOneWithoutSessionPlayersInput
  }

  export type SessionPlayerUncheckedCreateWithoutSessionInput = {
    id?: string
    playerId: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
  }

  export type SessionPlayerCreateOrConnectWithoutSessionInput = {
    where: SessionPlayerWhereUniqueInput
    create: XOR<SessionPlayerCreateWithoutSessionInput, SessionPlayerUncheckedCreateWithoutSessionInput>
  }

  export type SessionPlayerCreateManySessionInputEnvelope = {
    data: SessionPlayerCreateManySessionInput | SessionPlayerCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type QueueEntryCreateWithoutSessionInput = {
    id?: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: QueueEntryPlayerCreateNestedManyWithoutEntryInput
  }

  export type QueueEntryUncheckedCreateWithoutSessionInput = {
    id?: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    players?: QueueEntryPlayerUncheckedCreateNestedManyWithoutEntryInput
  }

  export type QueueEntryCreateOrConnectWithoutSessionInput = {
    where: QueueEntryWhereUniqueInput
    create: XOR<QueueEntryCreateWithoutSessionInput, QueueEntryUncheckedCreateWithoutSessionInput>
  }

  export type QueueEntryCreateManySessionInputEnvelope = {
    data: QueueEntryCreateManySessionInput | QueueEntryCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type MatchCreateWithoutSessionInput = {
    id?: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
    participants?: MatchParticipantCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutSessionInput = {
    id?: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
    participants?: MatchParticipantUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutSessionInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutSessionInput, MatchUncheckedCreateWithoutSessionInput>
  }

  export type MatchCreateManySessionInputEnvelope = {
    data: MatchCreateManySessionInput | MatchCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutSessionInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutSessionInput = {
    id?: string
    playerId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutSessionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSessionInput, PaymentUncheckedCreateWithoutSessionInput>
  }

  export type PaymentCreateManySessionInputEnvelope = {
    data: PaymentCreateManySessionInput | PaymentCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type ShareLinkCreateWithoutSessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    player: PlayerCreateNestedOneWithoutShareLinksInput
  }

  export type ShareLinkUncheckedCreateWithoutSessionInput = {
    id?: string
    token: string
    playerId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ShareLinkCreateOrConnectWithoutSessionInput = {
    where: ShareLinkWhereUniqueInput
    create: XOR<ShareLinkCreateWithoutSessionInput, ShareLinkUncheckedCreateWithoutSessionInput>
  }

  export type ShareLinkCreateManySessionInputEnvelope = {
    data: ShareLinkCreateManySessionInput | ShareLinkCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionShareLinkCreateWithoutSessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionShareLinkUncheckedCreateWithoutSessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionShareLinkCreateOrConnectWithoutSessionInput = {
    where: SessionShareLinkWhereUniqueInput
    create: XOR<SessionShareLinkCreateWithoutSessionInput, SessionShareLinkUncheckedCreateWithoutSessionInput>
  }

  export type SessionShareLinkCreateManySessionInputEnvelope = {
    data: SessionShareLinkCreateManySessionInput | SessionShareLinkCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type SessionInviteLinkCreateWithoutSessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionInviteLinkUncheckedCreateWithoutSessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionInviteLinkCreateOrConnectWithoutSessionInput = {
    where: SessionInviteLinkWhereUniqueInput
    create: XOR<SessionInviteLinkCreateWithoutSessionInput, SessionInviteLinkUncheckedCreateWithoutSessionInput>
  }

  export type SessionInviteLinkCreateManySessionInputEnvelope = {
    data: SessionInviteLinkCreateManySessionInput | SessionInviteLinkCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type BracketOverrideCreateWithoutSessionInput = {
    id?: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId?: string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BracketOverrideUncheckedCreateWithoutSessionInput = {
    id?: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId?: string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BracketOverrideCreateOrConnectWithoutSessionInput = {
    where: BracketOverrideWhereUniqueInput
    create: XOR<BracketOverrideCreateWithoutSessionInput, BracketOverrideUncheckedCreateWithoutSessionInput>
  }

  export type BracketOverrideCreateManySessionInputEnvelope = {
    data: BracketOverrideCreateManySessionInput | BracketOverrideCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    courts?: CourtUpdateManyWithoutCreatorNestedInput
    players?: PlayerUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    courts?: CourtUncheckedUpdateManyWithoutCreatorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CourtSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: CourtSessionWhereUniqueInput
    update: XOR<CourtSessionUpdateWithoutSessionInput, CourtSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<CourtSessionCreateWithoutSessionInput, CourtSessionUncheckedCreateWithoutSessionInput>
  }

  export type CourtSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: CourtSessionWhereUniqueInput
    data: XOR<CourtSessionUpdateWithoutSessionInput, CourtSessionUncheckedUpdateWithoutSessionInput>
  }

  export type CourtSessionUpdateManyWithWhereWithoutSessionInput = {
    where: CourtSessionScalarWhereInput
    data: XOR<CourtSessionUpdateManyMutationInput, CourtSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type CourtSessionScalarWhereInput = {
    AND?: CourtSessionScalarWhereInput | CourtSessionScalarWhereInput[]
    OR?: CourtSessionScalarWhereInput[]
    NOT?: CourtSessionScalarWhereInput | CourtSessionScalarWhereInput[]
    id?: UuidFilter<"CourtSession"> | string
    sessionId?: UuidFilter<"CourtSession"> | string
    courtId?: UuidFilter<"CourtSession"> | string
    status?: EnumCourtStatusFilter<"CourtSession"> | $Enums.CourtStatus
    currentMatchId?: UuidNullableFilter<"CourtSession"> | string | null
    nextMatchId?: UuidNullableFilter<"CourtSession"> | string | null
    createdAt?: DateTimeFilter<"CourtSession"> | Date | string
  }

  export type SessionPlayerUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionPlayerWhereUniqueInput
    update: XOR<SessionPlayerUpdateWithoutSessionInput, SessionPlayerUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionPlayerCreateWithoutSessionInput, SessionPlayerUncheckedCreateWithoutSessionInput>
  }

  export type SessionPlayerUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionPlayerWhereUniqueInput
    data: XOR<SessionPlayerUpdateWithoutSessionInput, SessionPlayerUncheckedUpdateWithoutSessionInput>
  }

  export type SessionPlayerUpdateManyWithWhereWithoutSessionInput = {
    where: SessionPlayerScalarWhereInput
    data: XOR<SessionPlayerUpdateManyMutationInput, SessionPlayerUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionPlayerScalarWhereInput = {
    AND?: SessionPlayerScalarWhereInput | SessionPlayerScalarWhereInput[]
    OR?: SessionPlayerScalarWhereInput[]
    NOT?: SessionPlayerScalarWhereInput | SessionPlayerScalarWhereInput[]
    id?: UuidFilter<"SessionPlayer"> | string
    sessionId?: UuidFilter<"SessionPlayer"> | string
    playerId?: UuidFilter<"SessionPlayer"> | string
    status?: EnumPlayerStatusFilter<"SessionPlayer"> | $Enums.PlayerStatus
    isNewPlayer?: BoolFilter<"SessionPlayer"> | boolean
    checkedInAt?: DateTimeFilter<"SessionPlayer"> | Date | string
    lastPlayedAt?: DateTimeNullableFilter<"SessionPlayer"> | Date | string | null
    gamesPlayed?: IntFilter<"SessionPlayer"> | number
    wins?: IntFilter<"SessionPlayer"> | number
    losses?: IntFilter<"SessionPlayer"> | number
    totalQueueSeconds?: IntFilter<"SessionPlayer"> | number
  }

  export type QueueEntryUpsertWithWhereUniqueWithoutSessionInput = {
    where: QueueEntryWhereUniqueInput
    update: XOR<QueueEntryUpdateWithoutSessionInput, QueueEntryUncheckedUpdateWithoutSessionInput>
    create: XOR<QueueEntryCreateWithoutSessionInput, QueueEntryUncheckedCreateWithoutSessionInput>
  }

  export type QueueEntryUpdateWithWhereUniqueWithoutSessionInput = {
    where: QueueEntryWhereUniqueInput
    data: XOR<QueueEntryUpdateWithoutSessionInput, QueueEntryUncheckedUpdateWithoutSessionInput>
  }

  export type QueueEntryUpdateManyWithWhereWithoutSessionInput = {
    where: QueueEntryScalarWhereInput
    data: XOR<QueueEntryUpdateManyMutationInput, QueueEntryUncheckedUpdateManyWithoutSessionInput>
  }

  export type QueueEntryScalarWhereInput = {
    AND?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
    OR?: QueueEntryScalarWhereInput[]
    NOT?: QueueEntryScalarWhereInput | QueueEntryScalarWhereInput[]
    id?: UuidFilter<"QueueEntry"> | string
    sessionId?: UuidFilter<"QueueEntry"> | string
    type?: EnumQueueTypeFilter<"QueueEntry"> | $Enums.QueueType
    status?: EnumQueueStatusFilter<"QueueEntry"> | $Enums.QueueStatus
    position?: IntFilter<"QueueEntry"> | number
    manualOrder?: BoolFilter<"QueueEntry"> | boolean
    createdAt?: DateTimeFilter<"QueueEntry"> | Date | string
    updatedAt?: DateTimeFilter<"QueueEntry"> | Date | string
  }

  export type MatchUpsertWithWhereUniqueWithoutSessionInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutSessionInput, MatchUncheckedUpdateWithoutSessionInput>
    create: XOR<MatchCreateWithoutSessionInput, MatchUncheckedCreateWithoutSessionInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutSessionInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutSessionInput, MatchUncheckedUpdateWithoutSessionInput>
  }

  export type MatchUpdateManyWithWhereWithoutSessionInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutSessionInput>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    id?: UuidFilter<"Match"> | string
    sessionId?: UuidFilter<"Match"> | string
    courtSessionId?: UuidNullableFilter<"Match"> | string | null
    status?: EnumMatchStatusFilter<"Match"> | $Enums.MatchStatus
    matchType?: EnumMatchTypeFilter<"Match"> | $Enums.MatchType
    startedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Match"> | Date | string | null
    scoreJson?: JsonNullableFilter<"Match">
    winnerTeam?: IntNullableFilter<"Match"> | number | null
    createdAt?: DateTimeFilter<"Match"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutSessionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSessionInput, PaymentUncheckedUpdateWithoutSessionInput>
    create: XOR<PaymentCreateWithoutSessionInput, PaymentUncheckedCreateWithoutSessionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSessionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSessionInput, PaymentUncheckedUpdateWithoutSessionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSessionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSessionInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: UuidFilter<"Payment"> | string
    sessionId?: UuidFilter<"Payment"> | string
    playerId?: UuidFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    method?: StringFilter<"Payment"> | string
    note?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ShareLinkUpsertWithWhereUniqueWithoutSessionInput = {
    where: ShareLinkWhereUniqueInput
    update: XOR<ShareLinkUpdateWithoutSessionInput, ShareLinkUncheckedUpdateWithoutSessionInput>
    create: XOR<ShareLinkCreateWithoutSessionInput, ShareLinkUncheckedCreateWithoutSessionInput>
  }

  export type ShareLinkUpdateWithWhereUniqueWithoutSessionInput = {
    where: ShareLinkWhereUniqueInput
    data: XOR<ShareLinkUpdateWithoutSessionInput, ShareLinkUncheckedUpdateWithoutSessionInput>
  }

  export type ShareLinkUpdateManyWithWhereWithoutSessionInput = {
    where: ShareLinkScalarWhereInput
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyWithoutSessionInput>
  }

  export type ShareLinkScalarWhereInput = {
    AND?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
    OR?: ShareLinkScalarWhereInput[]
    NOT?: ShareLinkScalarWhereInput | ShareLinkScalarWhereInput[]
    id?: UuidFilter<"ShareLink"> | string
    token?: StringFilter<"ShareLink"> | string
    sessionId?: UuidFilter<"ShareLink"> | string
    playerId?: UuidFilter<"ShareLink"> | string
    revokedAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"ShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"ShareLink"> | Date | string
  }

  export type SessionShareLinkUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionShareLinkWhereUniqueInput
    update: XOR<SessionShareLinkUpdateWithoutSessionInput, SessionShareLinkUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionShareLinkCreateWithoutSessionInput, SessionShareLinkUncheckedCreateWithoutSessionInput>
  }

  export type SessionShareLinkUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionShareLinkWhereUniqueInput
    data: XOR<SessionShareLinkUpdateWithoutSessionInput, SessionShareLinkUncheckedUpdateWithoutSessionInput>
  }

  export type SessionShareLinkUpdateManyWithWhereWithoutSessionInput = {
    where: SessionShareLinkScalarWhereInput
    data: XOR<SessionShareLinkUpdateManyMutationInput, SessionShareLinkUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionShareLinkScalarWhereInput = {
    AND?: SessionShareLinkScalarWhereInput | SessionShareLinkScalarWhereInput[]
    OR?: SessionShareLinkScalarWhereInput[]
    NOT?: SessionShareLinkScalarWhereInput | SessionShareLinkScalarWhereInput[]
    id?: UuidFilter<"SessionShareLink"> | string
    token?: StringFilter<"SessionShareLink"> | string
    sessionId?: UuidFilter<"SessionShareLink"> | string
    revokedAt?: DateTimeNullableFilter<"SessionShareLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SessionShareLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SessionShareLink"> | Date | string
  }

  export type SessionInviteLinkUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionInviteLinkWhereUniqueInput
    update: XOR<SessionInviteLinkUpdateWithoutSessionInput, SessionInviteLinkUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionInviteLinkCreateWithoutSessionInput, SessionInviteLinkUncheckedCreateWithoutSessionInput>
  }

  export type SessionInviteLinkUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionInviteLinkWhereUniqueInput
    data: XOR<SessionInviteLinkUpdateWithoutSessionInput, SessionInviteLinkUncheckedUpdateWithoutSessionInput>
  }

  export type SessionInviteLinkUpdateManyWithWhereWithoutSessionInput = {
    where: SessionInviteLinkScalarWhereInput
    data: XOR<SessionInviteLinkUpdateManyMutationInput, SessionInviteLinkUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionInviteLinkScalarWhereInput = {
    AND?: SessionInviteLinkScalarWhereInput | SessionInviteLinkScalarWhereInput[]
    OR?: SessionInviteLinkScalarWhereInput[]
    NOT?: SessionInviteLinkScalarWhereInput | SessionInviteLinkScalarWhereInput[]
    id?: UuidFilter<"SessionInviteLink"> | string
    token?: StringFilter<"SessionInviteLink"> | string
    sessionId?: UuidFilter<"SessionInviteLink"> | string
    revokedAt?: DateTimeNullableFilter<"SessionInviteLink"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"SessionInviteLink"> | Date | string | null
    createdAt?: DateTimeFilter<"SessionInviteLink"> | Date | string
  }

  export type BracketOverrideUpsertWithWhereUniqueWithoutSessionInput = {
    where: BracketOverrideWhereUniqueInput
    update: XOR<BracketOverrideUpdateWithoutSessionInput, BracketOverrideUncheckedUpdateWithoutSessionInput>
    create: XOR<BracketOverrideCreateWithoutSessionInput, BracketOverrideUncheckedCreateWithoutSessionInput>
  }

  export type BracketOverrideUpdateWithWhereUniqueWithoutSessionInput = {
    where: BracketOverrideWhereUniqueInput
    data: XOR<BracketOverrideUpdateWithoutSessionInput, BracketOverrideUncheckedUpdateWithoutSessionInput>
  }

  export type BracketOverrideUpdateManyWithWhereWithoutSessionInput = {
    where: BracketOverrideScalarWhereInput
    data: XOR<BracketOverrideUpdateManyMutationInput, BracketOverrideUncheckedUpdateManyWithoutSessionInput>
  }

  export type BracketOverrideScalarWhereInput = {
    AND?: BracketOverrideScalarWhereInput | BracketOverrideScalarWhereInput[]
    OR?: BracketOverrideScalarWhereInput[]
    NOT?: BracketOverrideScalarWhereInput | BracketOverrideScalarWhereInput[]
    id?: UuidFilter<"BracketOverride"> | string
    sessionId?: UuidFilter<"BracketOverride"> | string
    matchId?: StringFilter<"BracketOverride"> | string
    bracketType?: StringFilter<"BracketOverride"> | string
    matchFormat?: StringFilter<"BracketOverride"> | string
    winnerId?: StringNullableFilter<"BracketOverride"> | string | null
    scoreJson?: JsonNullableFilter<"BracketOverride">
    createdAt?: DateTimeFilter<"BracketOverride"> | Date | string
    updatedAt?: DateTimeFilter<"BracketOverride"> | Date | string
  }

  export type SessionCreateWithoutBracketOverridesInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutBracketOverridesInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutBracketOverridesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutBracketOverridesInput, SessionUncheckedCreateWithoutBracketOverridesInput>
  }

  export type SessionUpsertWithoutBracketOverridesInput = {
    update: XOR<SessionUpdateWithoutBracketOverridesInput, SessionUncheckedUpdateWithoutBracketOverridesInput>
    create: XOR<SessionCreateWithoutBracketOverridesInput, SessionUncheckedCreateWithoutBracketOverridesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutBracketOverridesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutBracketOverridesInput, SessionUncheckedUpdateWithoutBracketOverridesInput>
  }

  export type SessionUpdateWithoutBracketOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutBracketOverridesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateWithoutSessionInviteLinksInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionInviteLinksInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionInviteLinksInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionInviteLinksInput, SessionUncheckedCreateWithoutSessionInviteLinksInput>
  }

  export type SessionUpsertWithoutSessionInviteLinksInput = {
    update: XOR<SessionUpdateWithoutSessionInviteLinksInput, SessionUncheckedUpdateWithoutSessionInviteLinksInput>
    create: XOR<SessionCreateWithoutSessionInviteLinksInput, SessionUncheckedCreateWithoutSessionInviteLinksInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionInviteLinksInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionInviteLinksInput, SessionUncheckedUpdateWithoutSessionInviteLinksInput>
  }

  export type SessionUpdateWithoutSessionInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionInviteLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserCreateWithoutCourtsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutCreatorInput
    players?: PlayerCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutCourtsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCreatorInput
    players?: PlayerUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutCourtsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCourtsInput, UserUncheckedCreateWithoutCourtsInput>
  }

  export type CourtSessionCreateWithoutCourtInput = {
    id?: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutCourtSessionsInput
  }

  export type CourtSessionUncheckedCreateWithoutCourtInput = {
    id?: string
    sessionId: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
  }

  export type CourtSessionCreateOrConnectWithoutCourtInput = {
    where: CourtSessionWhereUniqueInput
    create: XOR<CourtSessionCreateWithoutCourtInput, CourtSessionUncheckedCreateWithoutCourtInput>
  }

  export type CourtSessionCreateManyCourtInputEnvelope = {
    data: CourtSessionCreateManyCourtInput | CourtSessionCreateManyCourtInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCourtsInput = {
    update: XOR<UserUpdateWithoutCourtsInput, UserUncheckedUpdateWithoutCourtsInput>
    create: XOR<UserCreateWithoutCourtsInput, UserUncheckedCreateWithoutCourtsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCourtsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCourtsInput, UserUncheckedUpdateWithoutCourtsInput>
  }

  export type UserUpdateWithoutCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutCreatorNestedInput
    players?: PlayerUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCreatorNestedInput
    players?: PlayerUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type CourtSessionUpsertWithWhereUniqueWithoutCourtInput = {
    where: CourtSessionWhereUniqueInput
    update: XOR<CourtSessionUpdateWithoutCourtInput, CourtSessionUncheckedUpdateWithoutCourtInput>
    create: XOR<CourtSessionCreateWithoutCourtInput, CourtSessionUncheckedCreateWithoutCourtInput>
  }

  export type CourtSessionUpdateWithWhereUniqueWithoutCourtInput = {
    where: CourtSessionWhereUniqueInput
    data: XOR<CourtSessionUpdateWithoutCourtInput, CourtSessionUncheckedUpdateWithoutCourtInput>
  }

  export type CourtSessionUpdateManyWithWhereWithoutCourtInput = {
    where: CourtSessionScalarWhereInput
    data: XOR<CourtSessionUpdateManyMutationInput, CourtSessionUncheckedUpdateManyWithoutCourtInput>
  }

  export type SessionCreateWithoutCourtSessionsInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutCourtSessionsInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutCourtSessionsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutCourtSessionsInput, SessionUncheckedCreateWithoutCourtSessionsInput>
  }

  export type CourtCreateWithoutCourtSessionsInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutCourtsInput
  }

  export type CourtUncheckedCreateWithoutCourtSessionsInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CourtCreateOrConnectWithoutCourtSessionsInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutCourtSessionsInput, CourtUncheckedCreateWithoutCourtSessionsInput>
  }

  export type SessionUpsertWithoutCourtSessionsInput = {
    update: XOR<SessionUpdateWithoutCourtSessionsInput, SessionUncheckedUpdateWithoutCourtSessionsInput>
    create: XOR<SessionCreateWithoutCourtSessionsInput, SessionUncheckedCreateWithoutCourtSessionsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutCourtSessionsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutCourtSessionsInput, SessionUncheckedUpdateWithoutCourtSessionsInput>
  }

  export type SessionUpdateWithoutCourtSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCourtSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type CourtUpsertWithoutCourtSessionsInput = {
    update: XOR<CourtUpdateWithoutCourtSessionsInput, CourtUncheckedUpdateWithoutCourtSessionsInput>
    create: XOR<CourtCreateWithoutCourtSessionsInput, CourtUncheckedCreateWithoutCourtSessionsInput>
    where?: CourtWhereInput
  }

  export type CourtUpdateToOneWithWhereWithoutCourtSessionsInput = {
    where?: CourtWhereInput
    data: XOR<CourtUpdateWithoutCourtSessionsInput, CourtUncheckedUpdateWithoutCourtSessionsInput>
  }

  export type CourtUpdateWithoutCourtSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutCourtsNestedInput
  }

  export type CourtUncheckedUpdateWithoutCourtSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutPlayersInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutCreatorInput
    courts?: CourtCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutPlayersInput = {
    id?: string
    email: string
    passwordHash: string
    fullName?: string | null
    emailVerifiedAt?: Date | string | null
    emailVerifyTokenHash?: string | null
    emailVerifyTokenExpiresAt?: Date | string | null
    passwordResetTokenHash?: string | null
    passwordResetTokenExpiresAt?: Date | string | null
    createdAt?: Date | string
    roles?: UserRoleUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutCreatorInput
    courts?: CourtUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutPlayersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
  }

  export type SessionPlayerCreateWithoutPlayerInput = {
    id?: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
    session: SessionCreateNestedOneWithoutSessionPlayersInput
  }

  export type SessionPlayerUncheckedCreateWithoutPlayerInput = {
    id?: string
    sessionId: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
  }

  export type SessionPlayerCreateOrConnectWithoutPlayerInput = {
    where: SessionPlayerWhereUniqueInput
    create: XOR<SessionPlayerCreateWithoutPlayerInput, SessionPlayerUncheckedCreateWithoutPlayerInput>
  }

  export type SessionPlayerCreateManyPlayerInputEnvelope = {
    data: SessionPlayerCreateManyPlayerInput | SessionPlayerCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type QueueEntryPlayerCreateWithoutPlayerInput = {
    entry: QueueEntryCreateNestedOneWithoutPlayersInput
  }

  export type QueueEntryPlayerUncheckedCreateWithoutPlayerInput = {
    entryId: string
  }

  export type QueueEntryPlayerCreateOrConnectWithoutPlayerInput = {
    where: QueueEntryPlayerWhereUniqueInput
    create: XOR<QueueEntryPlayerCreateWithoutPlayerInput, QueueEntryPlayerUncheckedCreateWithoutPlayerInput>
  }

  export type QueueEntryPlayerCreateManyPlayerInputEnvelope = {
    data: QueueEntryPlayerCreateManyPlayerInput | QueueEntryPlayerCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type MatchParticipantCreateWithoutPlayerInput = {
    teamNumber: number
    match: MatchCreateNestedOneWithoutParticipantsInput
  }

  export type MatchParticipantUncheckedCreateWithoutPlayerInput = {
    matchId: string
    teamNumber: number
  }

  export type MatchParticipantCreateOrConnectWithoutPlayerInput = {
    where: MatchParticipantWhereUniqueInput
    create: XOR<MatchParticipantCreateWithoutPlayerInput, MatchParticipantUncheckedCreateWithoutPlayerInput>
  }

  export type MatchParticipantCreateManyPlayerInputEnvelope = {
    data: MatchParticipantCreateManyPlayerInput | MatchParticipantCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutPlayerInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPlayerInput = {
    id?: string
    sessionId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPlayerInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPlayerInput, PaymentUncheckedCreateWithoutPlayerInput>
  }

  export type PaymentCreateManyPlayerInputEnvelope = {
    data: PaymentCreateManyPlayerInput | PaymentCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type ShareLinkCreateWithoutPlayerInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutShareLinksInput
  }

  export type ShareLinkUncheckedCreateWithoutPlayerInput = {
    id?: string
    token: string
    sessionId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type ShareLinkCreateOrConnectWithoutPlayerInput = {
    where: ShareLinkWhereUniqueInput
    create: XOR<ShareLinkCreateWithoutPlayerInput, ShareLinkUncheckedCreateWithoutPlayerInput>
  }

  export type ShareLinkCreateManyPlayerInputEnvelope = {
    data: ShareLinkCreateManyPlayerInput | ShareLinkCreateManyPlayerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPlayersInput = {
    update: XOR<UserUpdateWithoutPlayersInput, UserUncheckedUpdateWithoutPlayersInput>
    create: XOR<UserCreateWithoutPlayersInput, UserUncheckedCreateWithoutPlayersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlayersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlayersInput, UserUncheckedUpdateWithoutPlayersInput>
  }

  export type UserUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutCreatorNestedInput
    courts?: CourtUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    emailVerifyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerifyTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roles?: UserRoleUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutCreatorNestedInput
    courts?: CourtUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type SessionPlayerUpsertWithWhereUniqueWithoutPlayerInput = {
    where: SessionPlayerWhereUniqueInput
    update: XOR<SessionPlayerUpdateWithoutPlayerInput, SessionPlayerUncheckedUpdateWithoutPlayerInput>
    create: XOR<SessionPlayerCreateWithoutPlayerInput, SessionPlayerUncheckedCreateWithoutPlayerInput>
  }

  export type SessionPlayerUpdateWithWhereUniqueWithoutPlayerInput = {
    where: SessionPlayerWhereUniqueInput
    data: XOR<SessionPlayerUpdateWithoutPlayerInput, SessionPlayerUncheckedUpdateWithoutPlayerInput>
  }

  export type SessionPlayerUpdateManyWithWhereWithoutPlayerInput = {
    where: SessionPlayerScalarWhereInput
    data: XOR<SessionPlayerUpdateManyMutationInput, SessionPlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type QueueEntryPlayerUpsertWithWhereUniqueWithoutPlayerInput = {
    where: QueueEntryPlayerWhereUniqueInput
    update: XOR<QueueEntryPlayerUpdateWithoutPlayerInput, QueueEntryPlayerUncheckedUpdateWithoutPlayerInput>
    create: XOR<QueueEntryPlayerCreateWithoutPlayerInput, QueueEntryPlayerUncheckedCreateWithoutPlayerInput>
  }

  export type QueueEntryPlayerUpdateWithWhereUniqueWithoutPlayerInput = {
    where: QueueEntryPlayerWhereUniqueInput
    data: XOR<QueueEntryPlayerUpdateWithoutPlayerInput, QueueEntryPlayerUncheckedUpdateWithoutPlayerInput>
  }

  export type QueueEntryPlayerUpdateManyWithWhereWithoutPlayerInput = {
    where: QueueEntryPlayerScalarWhereInput
    data: XOR<QueueEntryPlayerUpdateManyMutationInput, QueueEntryPlayerUncheckedUpdateManyWithoutPlayerInput>
  }

  export type QueueEntryPlayerScalarWhereInput = {
    AND?: QueueEntryPlayerScalarWhereInput | QueueEntryPlayerScalarWhereInput[]
    OR?: QueueEntryPlayerScalarWhereInput[]
    NOT?: QueueEntryPlayerScalarWhereInput | QueueEntryPlayerScalarWhereInput[]
    entryId?: UuidFilter<"QueueEntryPlayer"> | string
    playerId?: UuidFilter<"QueueEntryPlayer"> | string
  }

  export type MatchParticipantUpsertWithWhereUniqueWithoutPlayerInput = {
    where: MatchParticipantWhereUniqueInput
    update: XOR<MatchParticipantUpdateWithoutPlayerInput, MatchParticipantUncheckedUpdateWithoutPlayerInput>
    create: XOR<MatchParticipantCreateWithoutPlayerInput, MatchParticipantUncheckedCreateWithoutPlayerInput>
  }

  export type MatchParticipantUpdateWithWhereUniqueWithoutPlayerInput = {
    where: MatchParticipantWhereUniqueInput
    data: XOR<MatchParticipantUpdateWithoutPlayerInput, MatchParticipantUncheckedUpdateWithoutPlayerInput>
  }

  export type MatchParticipantUpdateManyWithWhereWithoutPlayerInput = {
    where: MatchParticipantScalarWhereInput
    data: XOR<MatchParticipantUpdateManyMutationInput, MatchParticipantUncheckedUpdateManyWithoutPlayerInput>
  }

  export type MatchParticipantScalarWhereInput = {
    AND?: MatchParticipantScalarWhereInput | MatchParticipantScalarWhereInput[]
    OR?: MatchParticipantScalarWhereInput[]
    NOT?: MatchParticipantScalarWhereInput | MatchParticipantScalarWhereInput[]
    matchId?: UuidFilter<"MatchParticipant"> | string
    playerId?: UuidFilter<"MatchParticipant"> | string
    teamNumber?: IntFilter<"MatchParticipant"> | number
  }

  export type PaymentUpsertWithWhereUniqueWithoutPlayerInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPlayerInput, PaymentUncheckedUpdateWithoutPlayerInput>
    create: XOR<PaymentCreateWithoutPlayerInput, PaymentUncheckedCreateWithoutPlayerInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPlayerInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPlayerInput, PaymentUncheckedUpdateWithoutPlayerInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPlayerInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPlayerInput>
  }

  export type ShareLinkUpsertWithWhereUniqueWithoutPlayerInput = {
    where: ShareLinkWhereUniqueInput
    update: XOR<ShareLinkUpdateWithoutPlayerInput, ShareLinkUncheckedUpdateWithoutPlayerInput>
    create: XOR<ShareLinkCreateWithoutPlayerInput, ShareLinkUncheckedCreateWithoutPlayerInput>
  }

  export type ShareLinkUpdateWithWhereUniqueWithoutPlayerInput = {
    where: ShareLinkWhereUniqueInput
    data: XOR<ShareLinkUpdateWithoutPlayerInput, ShareLinkUncheckedUpdateWithoutPlayerInput>
  }

  export type ShareLinkUpdateManyWithWhereWithoutPlayerInput = {
    where: ShareLinkScalarWhereInput
    data: XOR<ShareLinkUpdateManyMutationInput, ShareLinkUncheckedUpdateManyWithoutPlayerInput>
  }

  export type SessionCreateWithoutSessionPlayersInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionPlayersInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionPlayersInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionPlayersInput, SessionUncheckedCreateWithoutSessionPlayersInput>
  }

  export type PlayerCreateWithoutSessionPlayersInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutPlayersInput
    queueEntryPlayers?: QueueEntryPlayerCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantCreateNestedManyWithoutPlayerInput
    payments?: PaymentCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutSessionPlayersInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    queueEntryPlayers?: QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutSessionPlayersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutSessionPlayersInput, PlayerUncheckedCreateWithoutSessionPlayersInput>
  }

  export type SessionUpsertWithoutSessionPlayersInput = {
    update: XOR<SessionUpdateWithoutSessionPlayersInput, SessionUncheckedUpdateWithoutSessionPlayersInput>
    create: XOR<SessionCreateWithoutSessionPlayersInput, SessionUncheckedCreateWithoutSessionPlayersInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionPlayersInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionPlayersInput, SessionUncheckedUpdateWithoutSessionPlayersInput>
  }

  export type SessionUpdateWithoutSessionPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PlayerUpsertWithoutSessionPlayersInput = {
    update: XOR<PlayerUpdateWithoutSessionPlayersInput, PlayerUncheckedUpdateWithoutSessionPlayersInput>
    create: XOR<PlayerCreateWithoutSessionPlayersInput, PlayerUncheckedCreateWithoutSessionPlayersInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutSessionPlayersInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutSessionPlayersInput, PlayerUncheckedUpdateWithoutSessionPlayersInput>
  }

  export type PlayerUpdateWithoutSessionPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutPlayersNestedInput
    queueEntryPlayers?: QueueEntryPlayerUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutSessionPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queueEntryPlayers?: QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SessionCreateWithoutQueueEntriesInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutQueueEntriesInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutQueueEntriesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutQueueEntriesInput, SessionUncheckedCreateWithoutQueueEntriesInput>
  }

  export type QueueEntryPlayerCreateWithoutEntryInput = {
    player: PlayerCreateNestedOneWithoutQueueEntryPlayersInput
  }

  export type QueueEntryPlayerUncheckedCreateWithoutEntryInput = {
    playerId: string
  }

  export type QueueEntryPlayerCreateOrConnectWithoutEntryInput = {
    where: QueueEntryPlayerWhereUniqueInput
    create: XOR<QueueEntryPlayerCreateWithoutEntryInput, QueueEntryPlayerUncheckedCreateWithoutEntryInput>
  }

  export type QueueEntryPlayerCreateManyEntryInputEnvelope = {
    data: QueueEntryPlayerCreateManyEntryInput | QueueEntryPlayerCreateManyEntryInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithoutQueueEntriesInput = {
    update: XOR<SessionUpdateWithoutQueueEntriesInput, SessionUncheckedUpdateWithoutQueueEntriesInput>
    create: XOR<SessionCreateWithoutQueueEntriesInput, SessionUncheckedCreateWithoutQueueEntriesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutQueueEntriesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutQueueEntriesInput, SessionUncheckedUpdateWithoutQueueEntriesInput>
  }

  export type SessionUpdateWithoutQueueEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutQueueEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type QueueEntryPlayerUpsertWithWhereUniqueWithoutEntryInput = {
    where: QueueEntryPlayerWhereUniqueInput
    update: XOR<QueueEntryPlayerUpdateWithoutEntryInput, QueueEntryPlayerUncheckedUpdateWithoutEntryInput>
    create: XOR<QueueEntryPlayerCreateWithoutEntryInput, QueueEntryPlayerUncheckedCreateWithoutEntryInput>
  }

  export type QueueEntryPlayerUpdateWithWhereUniqueWithoutEntryInput = {
    where: QueueEntryPlayerWhereUniqueInput
    data: XOR<QueueEntryPlayerUpdateWithoutEntryInput, QueueEntryPlayerUncheckedUpdateWithoutEntryInput>
  }

  export type QueueEntryPlayerUpdateManyWithWhereWithoutEntryInput = {
    where: QueueEntryPlayerScalarWhereInput
    data: XOR<QueueEntryPlayerUpdateManyMutationInput, QueueEntryPlayerUncheckedUpdateManyWithoutEntryInput>
  }

  export type QueueEntryCreateWithoutPlayersInput = {
    id?: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    session: SessionCreateNestedOneWithoutQueueEntriesInput
  }

  export type QueueEntryUncheckedCreateWithoutPlayersInput = {
    id?: string
    sessionId: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QueueEntryCreateOrConnectWithoutPlayersInput = {
    where: QueueEntryWhereUniqueInput
    create: XOR<QueueEntryCreateWithoutPlayersInput, QueueEntryUncheckedCreateWithoutPlayersInput>
  }

  export type PlayerCreateWithoutQueueEntryPlayersInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutPlayersInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantCreateNestedManyWithoutPlayerInput
    payments?: PaymentCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutQueueEntryPlayersInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutQueueEntryPlayersInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutQueueEntryPlayersInput, PlayerUncheckedCreateWithoutQueueEntryPlayersInput>
  }

  export type QueueEntryUpsertWithoutPlayersInput = {
    update: XOR<QueueEntryUpdateWithoutPlayersInput, QueueEntryUncheckedUpdateWithoutPlayersInput>
    create: XOR<QueueEntryCreateWithoutPlayersInput, QueueEntryUncheckedCreateWithoutPlayersInput>
    where?: QueueEntryWhereInput
  }

  export type QueueEntryUpdateToOneWithWhereWithoutPlayersInput = {
    where?: QueueEntryWhereInput
    data: XOR<QueueEntryUpdateWithoutPlayersInput, QueueEntryUncheckedUpdateWithoutPlayersInput>
  }

  export type QueueEntryUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutQueueEntriesNestedInput
  }

  export type QueueEntryUncheckedUpdateWithoutPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpsertWithoutQueueEntryPlayersInput = {
    update: XOR<PlayerUpdateWithoutQueueEntryPlayersInput, PlayerUncheckedUpdateWithoutQueueEntryPlayersInput>
    create: XOR<PlayerCreateWithoutQueueEntryPlayersInput, PlayerUncheckedCreateWithoutQueueEntryPlayersInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutQueueEntryPlayersInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutQueueEntryPlayersInput, PlayerUncheckedUpdateWithoutQueueEntryPlayersInput>
  }

  export type PlayerUpdateWithoutQueueEntryPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutPlayersNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutQueueEntryPlayersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SessionCreateWithoutMatchesInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutMatchesInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutMatchesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutMatchesInput, SessionUncheckedCreateWithoutMatchesInput>
  }

  export type MatchParticipantCreateWithoutMatchInput = {
    teamNumber: number
    player: PlayerCreateNestedOneWithoutMatchParticipantsInput
  }

  export type MatchParticipantUncheckedCreateWithoutMatchInput = {
    playerId: string
    teamNumber: number
  }

  export type MatchParticipantCreateOrConnectWithoutMatchInput = {
    where: MatchParticipantWhereUniqueInput
    create: XOR<MatchParticipantCreateWithoutMatchInput, MatchParticipantUncheckedCreateWithoutMatchInput>
  }

  export type MatchParticipantCreateManyMatchInputEnvelope = {
    data: MatchParticipantCreateManyMatchInput | MatchParticipantCreateManyMatchInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithoutMatchesInput = {
    update: XOR<SessionUpdateWithoutMatchesInput, SessionUncheckedUpdateWithoutMatchesInput>
    create: XOR<SessionCreateWithoutMatchesInput, SessionUncheckedCreateWithoutMatchesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutMatchesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutMatchesInput, SessionUncheckedUpdateWithoutMatchesInput>
  }

  export type SessionUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutMatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type MatchParticipantUpsertWithWhereUniqueWithoutMatchInput = {
    where: MatchParticipantWhereUniqueInput
    update: XOR<MatchParticipantUpdateWithoutMatchInput, MatchParticipantUncheckedUpdateWithoutMatchInput>
    create: XOR<MatchParticipantCreateWithoutMatchInput, MatchParticipantUncheckedCreateWithoutMatchInput>
  }

  export type MatchParticipantUpdateWithWhereUniqueWithoutMatchInput = {
    where: MatchParticipantWhereUniqueInput
    data: XOR<MatchParticipantUpdateWithoutMatchInput, MatchParticipantUncheckedUpdateWithoutMatchInput>
  }

  export type MatchParticipantUpdateManyWithWhereWithoutMatchInput = {
    where: MatchParticipantScalarWhereInput
    data: XOR<MatchParticipantUpdateManyMutationInput, MatchParticipantUncheckedUpdateManyWithoutMatchInput>
  }

  export type MatchCreateWithoutParticipantsInput = {
    id?: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
    session: SessionCreateNestedOneWithoutMatchesInput
  }

  export type MatchUncheckedCreateWithoutParticipantsInput = {
    id?: string
    sessionId: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
  }

  export type MatchCreateOrConnectWithoutParticipantsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput>
  }

  export type PlayerCreateWithoutMatchParticipantsInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutPlayersInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerCreateNestedManyWithoutPlayerInput
    payments?: PaymentCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutMatchParticipantsInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutMatchParticipantsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutMatchParticipantsInput, PlayerUncheckedCreateWithoutMatchParticipantsInput>
  }

  export type MatchUpsertWithoutParticipantsInput = {
    update: XOR<MatchUpdateWithoutParticipantsInput, MatchUncheckedUpdateWithoutParticipantsInput>
    create: XOR<MatchCreateWithoutParticipantsInput, MatchUncheckedCreateWithoutParticipantsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutParticipantsInput, MatchUncheckedUpdateWithoutParticipantsInput>
  }

  export type MatchUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutMatchesNestedInput
  }

  export type MatchUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlayerUpsertWithoutMatchParticipantsInput = {
    update: XOR<PlayerUpdateWithoutMatchParticipantsInput, PlayerUncheckedUpdateWithoutMatchParticipantsInput>
    create: XOR<PlayerCreateWithoutMatchParticipantsInput, PlayerUncheckedCreateWithoutMatchParticipantsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutMatchParticipantsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutMatchParticipantsInput, PlayerUncheckedUpdateWithoutMatchParticipantsInput>
  }

  export type PlayerUpdateWithoutMatchParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutPlayersNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutMatchParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SessionCreateWithoutPaymentsInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutPaymentsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutPaymentsInput, SessionUncheckedCreateWithoutPaymentsInput>
  }

  export type PlayerCreateWithoutPaymentsInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutPlayersInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutPaymentsInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutPaymentsInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutPaymentsInput, PlayerUncheckedCreateWithoutPaymentsInput>
  }

  export type SessionUpsertWithoutPaymentsInput = {
    update: XOR<SessionUpdateWithoutPaymentsInput, SessionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SessionCreateWithoutPaymentsInput, SessionUncheckedCreateWithoutPaymentsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutPaymentsInput, SessionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SessionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PlayerUpsertWithoutPaymentsInput = {
    update: XOR<PlayerUpdateWithoutPaymentsInput, PlayerUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PlayerCreateWithoutPaymentsInput, PlayerUncheckedCreateWithoutPaymentsInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutPaymentsInput, PlayerUncheckedUpdateWithoutPaymentsInput>
  }

  export type PlayerUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutPlayersNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SessionCreateWithoutShareLinksInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutShareLinksInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    sessionShareLinks?: SessionShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutShareLinksInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutShareLinksInput, SessionUncheckedCreateWithoutShareLinksInput>
  }

  export type PlayerCreateWithoutShareLinksInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutPlayersInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantCreateNestedManyWithoutPlayerInput
    payments?: PaymentCreateNestedManyWithoutPlayerInput
  }

  export type PlayerUncheckedCreateWithoutShareLinksInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutPlayerInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedCreateNestedManyWithoutPlayerInput
    matchParticipants?: MatchParticipantUncheckedCreateNestedManyWithoutPlayerInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPlayerInput
  }

  export type PlayerCreateOrConnectWithoutShareLinksInput = {
    where: PlayerWhereUniqueInput
    create: XOR<PlayerCreateWithoutShareLinksInput, PlayerUncheckedCreateWithoutShareLinksInput>
  }

  export type SessionUpsertWithoutShareLinksInput = {
    update: XOR<SessionUpdateWithoutShareLinksInput, SessionUncheckedUpdateWithoutShareLinksInput>
    create: XOR<SessionCreateWithoutShareLinksInput, SessionUncheckedCreateWithoutShareLinksInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutShareLinksInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutShareLinksInput, SessionUncheckedUpdateWithoutShareLinksInput>
  }

  export type SessionUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type PlayerUpsertWithoutShareLinksInput = {
    update: XOR<PlayerUpdateWithoutShareLinksInput, PlayerUncheckedUpdateWithoutShareLinksInput>
    create: XOR<PlayerCreateWithoutShareLinksInput, PlayerUncheckedCreateWithoutShareLinksInput>
    where?: PlayerWhereInput
  }

  export type PlayerUpdateToOneWithWhereWithoutShareLinksInput = {
    where?: PlayerWhereInput
    data: XOR<PlayerUpdateWithoutShareLinksInput, PlayerUncheckedUpdateWithoutShareLinksInput>
  }

  export type PlayerUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutPlayersNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type SessionCreateWithoutSessionShareLinksInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    creator?: UserCreateNestedOneWithoutSessionsInput
    courtSessions?: CourtSessionCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryCreateNestedManyWithoutSessionInput
    matches?: MatchCreateNestedManyWithoutSessionInput
    payments?: PaymentCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionShareLinksInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
    courtSessions?: CourtSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionPlayers?: SessionPlayerUncheckedCreateNestedManyWithoutSessionInput
    queueEntries?: QueueEntryUncheckedCreateNestedManyWithoutSessionInput
    matches?: MatchUncheckedCreateNestedManyWithoutSessionInput
    payments?: PaymentUncheckedCreateNestedManyWithoutSessionInput
    shareLinks?: ShareLinkUncheckedCreateNestedManyWithoutSessionInput
    sessionInviteLinks?: SessionInviteLinkUncheckedCreateNestedManyWithoutSessionInput
    bracketOverrides?: BracketOverrideUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionShareLinksInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionShareLinksInput, SessionUncheckedCreateWithoutSessionShareLinksInput>
  }

  export type SessionUpsertWithoutSessionShareLinksInput = {
    update: XOR<SessionUpdateWithoutSessionShareLinksInput, SessionUncheckedUpdateWithoutSessionShareLinksInput>
    create: XOR<SessionCreateWithoutSessionShareLinksInput, SessionUncheckedCreateWithoutSessionShareLinksInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionShareLinksInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionShareLinksInput, SessionUncheckedUpdateWithoutSessionShareLinksInput>
  }

  export type SessionUpdateWithoutSessionShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creator?: UserUpdateOneWithoutSessionsNestedInput
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionShareLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type UserRoleCreateManyRoleInput = {
    userId: string
  }

  export type UserRoleUpdateWithoutRoleInput = {
    user?: UserUpdateOneRequiredWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutRoleInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleCreateManyUserInput = {
    roleId: string
  }

  export type SessionCreateManyCreatorInput = {
    id?: string
    name: string
    startsAt?: Date | string | null
    endsAt?: Date | string | null
    status: $Enums.SessionStatus
    gameType?: $Enums.MatchType
    feeMode: $Enums.FeeMode
    feeAmount?: Decimal | DecimalJsLike | number | string
    defaultBracketType?: string | null
    regularJoinLimit?: number
    newJoinerLimit?: number
    returnToQueue?: boolean
    announcements?: string | null
    createdAt?: Date | string
    closedAt?: Date | string | null
  }

  export type CourtCreateManyCreatorInput = {
    id?: string
    name: string
    notes?: string | null
    active?: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PlayerCreateManyCreatorInput = {
    id?: string
    fullName: string
    nickname?: string | null
    skillLevel?: string | null
    contact?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserRoleUpdateWithoutUserInput = {
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUncheckedUpdateManyWithoutUserInput = {
    roleId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUpdateManyWithoutSessionNestedInput
    matches?: MatchUpdateManyWithoutSessionNestedInput
    payments?: PaymentUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutSessionNestedInput
    queueEntries?: QueueEntryUncheckedUpdateManyWithoutSessionNestedInput
    matches?: MatchUncheckedUpdateManyWithoutSessionNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutSessionNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionShareLinks?: SessionShareLinkUncheckedUpdateManyWithoutSessionNestedInput
    sessionInviteLinks?: SessionInviteLinkUncheckedUpdateManyWithoutSessionNestedInput
    bracketOverrides?: BracketOverrideUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    startsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumSessionStatusFieldUpdateOperationsInput | $Enums.SessionStatus
    gameType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    feeMode?: EnumFeeModeFieldUpdateOperationsInput | $Enums.FeeMode
    feeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defaultBracketType?: NullableStringFieldUpdateOperationsInput | string | null
    regularJoinLimit?: IntFieldUpdateOperationsInput | number
    newJoinerLimit?: IntFieldUpdateOperationsInput | number
    returnToQueue?: BoolFieldUpdateOperationsInput | boolean
    announcements?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourtUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courtSessions?: CourtSessionUncheckedUpdateManyWithoutCourtNestedInput
  }

  export type CourtUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PlayerUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessionPlayers?: SessionPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    queueEntryPlayers?: QueueEntryPlayerUncheckedUpdateManyWithoutPlayerNestedInput
    matchParticipants?: MatchParticipantUncheckedUpdateManyWithoutPlayerNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPlayerNestedInput
    shareLinks?: ShareLinkUncheckedUpdateManyWithoutPlayerNestedInput
  }

  export type PlayerUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    skillLevel?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourtSessionCreateManySessionInput = {
    id?: string
    courtId: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
  }

  export type SessionPlayerCreateManySessionInput = {
    id?: string
    playerId: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
  }

  export type QueueEntryCreateManySessionInput = {
    id?: string
    type: $Enums.QueueType
    status: $Enums.QueueStatus
    position: number
    manualOrder?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MatchCreateManySessionInput = {
    id?: string
    courtSessionId?: string | null
    status: $Enums.MatchStatus
    matchType: $Enums.MatchType
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: number | null
    createdAt?: Date | string
  }

  export type PaymentCreateManySessionInput = {
    id?: string
    playerId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
  }

  export type ShareLinkCreateManySessionInput = {
    id?: string
    token: string
    playerId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionShareLinkCreateManySessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionInviteLinkCreateManySessionInput = {
    id?: string
    token: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type BracketOverrideCreateManySessionInput = {
    id?: string
    matchId: string
    bracketType: string
    matchFormat: string
    winnerId?: string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CourtSessionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    court?: CourtUpdateOneRequiredWithoutCourtSessionsNestedInput
  }

  export type CourtSessionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtSessionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionPlayerUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutSessionPlayersNestedInput
  }

  export type SessionPlayerUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type SessionPlayerUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type QueueEntryUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: QueueEntryPlayerUpdateManyWithoutEntryNestedInput
  }

  export type QueueEntryUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    players?: QueueEntryPlayerUncheckedUpdateManyWithoutEntryNestedInput
  }

  export type QueueEntryUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumQueueTypeFieldUpdateOperationsInput | $Enums.QueueType
    status?: EnumQueueStatusFieldUpdateOperationsInput | $Enums.QueueStatus
    position?: IntFieldUpdateOperationsInput | number
    manualOrder?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MatchParticipantUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: MatchParticipantUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    courtSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMatchStatusFieldUpdateOperationsInput | $Enums.MatchStatus
    matchType?: EnumMatchTypeFieldUpdateOperationsInput | $Enums.MatchType
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    winnerTeam?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    player?: PlayerUpdateOneRequiredWithoutShareLinksNestedInput
  }

  export type ShareLinkUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    playerId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionShareLinkUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionShareLinkUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionShareLinkUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionInviteLinkUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionInviteLinkUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionInviteLinkUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BracketOverrideUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BracketOverrideUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BracketOverrideUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    matchId?: StringFieldUpdateOperationsInput | string
    bracketType?: StringFieldUpdateOperationsInput | string
    matchFormat?: StringFieldUpdateOperationsInput | string
    winnerId?: NullableStringFieldUpdateOperationsInput | string | null
    scoreJson?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtSessionCreateManyCourtInput = {
    id?: string
    sessionId: string
    status: $Enums.CourtStatus
    currentMatchId?: string | null
    nextMatchId?: string | null
    createdAt?: Date | string
  }

  export type CourtSessionUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutCourtSessionsNestedInput
  }

  export type CourtSessionUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourtSessionUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumCourtStatusFieldUpdateOperationsInput | $Enums.CourtStatus
    currentMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    nextMatchId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionPlayerCreateManyPlayerInput = {
    id?: string
    sessionId: string
    status: $Enums.PlayerStatus
    isNewPlayer?: boolean
    checkedInAt?: Date | string
    lastPlayedAt?: Date | string | null
    gamesPlayed?: number
    wins?: number
    losses?: number
    totalQueueSeconds?: number
  }

  export type QueueEntryPlayerCreateManyPlayerInput = {
    entryId: string
  }

  export type MatchParticipantCreateManyPlayerInput = {
    matchId: string
    teamNumber: number
  }

  export type PaymentCreateManyPlayerInput = {
    id?: string
    sessionId: string
    amount: Decimal | DecimalJsLike | number | string
    method: string
    note?: string | null
    createdAt?: Date | string
  }

  export type ShareLinkCreateManyPlayerInput = {
    id?: string
    token: string
    sessionId: string
    revokedAt?: Date | string | null
    expiresAt?: Date | string | null
    createdAt?: Date | string
  }

  export type SessionPlayerUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
    session?: SessionUpdateOneRequiredWithoutSessionPlayersNestedInput
  }

  export type SessionPlayerUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type SessionPlayerUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    status?: EnumPlayerStatusFieldUpdateOperationsInput | $Enums.PlayerStatus
    isNewPlayer?: BoolFieldUpdateOperationsInput | boolean
    checkedInAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastPlayedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gamesPlayed?: IntFieldUpdateOperationsInput | number
    wins?: IntFieldUpdateOperationsInput | number
    losses?: IntFieldUpdateOperationsInput | number
    totalQueueSeconds?: IntFieldUpdateOperationsInput | number
  }

  export type QueueEntryPlayerUpdateWithoutPlayerInput = {
    entry?: QueueEntryUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type QueueEntryPlayerUncheckedUpdateWithoutPlayerInput = {
    entryId?: StringFieldUpdateOperationsInput | string
  }

  export type QueueEntryPlayerUncheckedUpdateManyWithoutPlayerInput = {
    entryId?: StringFieldUpdateOperationsInput | string
  }

  export type MatchParticipantUpdateWithoutPlayerInput = {
    teamNumber?: IntFieldUpdateOperationsInput | number
    match?: MatchUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type MatchParticipantUncheckedUpdateWithoutPlayerInput = {
    matchId?: StringFieldUpdateOperationsInput | string
    teamNumber?: IntFieldUpdateOperationsInput | number
  }

  export type MatchParticipantUncheckedUpdateManyWithoutPlayerInput = {
    matchId?: StringFieldUpdateOperationsInput | string
    teamNumber?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    method?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    session?: SessionUpdateOneRequiredWithoutShareLinksNestedInput
  }

  export type ShareLinkUncheckedUpdateWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShareLinkUncheckedUpdateManyWithoutPlayerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QueueEntryPlayerCreateManyEntryInput = {
    playerId: string
  }

  export type QueueEntryPlayerUpdateWithoutEntryInput = {
    player?: PlayerUpdateOneRequiredWithoutQueueEntryPlayersNestedInput
  }

  export type QueueEntryPlayerUncheckedUpdateWithoutEntryInput = {
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type QueueEntryPlayerUncheckedUpdateManyWithoutEntryInput = {
    playerId?: StringFieldUpdateOperationsInput | string
  }

  export type MatchParticipantCreateManyMatchInput = {
    playerId: string
    teamNumber: number
  }

  export type MatchParticipantUpdateWithoutMatchInput = {
    teamNumber?: IntFieldUpdateOperationsInput | number
    player?: PlayerUpdateOneRequiredWithoutMatchParticipantsNestedInput
  }

  export type MatchParticipantUncheckedUpdateWithoutMatchInput = {
    playerId?: StringFieldUpdateOperationsInput | string
    teamNumber?: IntFieldUpdateOperationsInput | number
  }

  export type MatchParticipantUncheckedUpdateManyWithoutMatchInput = {
    playerId?: StringFieldUpdateOperationsInput | string
    teamNumber?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}